<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Today's Agenda</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Design System - Minimal Color Palette */
        :root {
            --color-primary: #1a1a1a;
            --color-accent: #2563eb;
            --color-bg: #ffffff;
            --color-bg-secondary: #f9fafb;
            --color-text: #1a1a1a;
            --color-text-secondary: #6b7280;
            --color-border: #e5e7eb;
            --color-hover: #f3f4f6;
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --radius-sm: 6px;
            --radius-md: 8px;
            --radius-lg: 12px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--color-bg-secondary);
            padding: var(--spacing-md);
            color: var(--color-text);
            line-height: 1.6;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: var(--color-bg);
            border-radius: var(--radius-lg);
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            padding: var(--spacing-xl);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }

        /* Prep View Toggle */
        .prep-view-toggle {
            position: absolute;
            top: 0;
            left: 0;
            background: var(--color-primary);
            color: white;
            border: none;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-md);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
            z-index: 10;
        }

        .prep-view-toggle:hover {
            background: #2d2d2d;
        }

        .prep-view-toggle.active {
            background: var(--color-accent);
        }

        /* Prep View Container */
        .prep-view-container {
            display: none;
            max-width: 600px;
            margin: 0 auto;
        }

        .prep-view-container.active {
            display: block;
        }

        /* Chat Panel Toggle */
        .chat-panel-toggle {
            position: absolute;
            top: 0;
            left: 120px;
            background: var(--color-primary);
            color: white;
            border: none;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-md);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
            z-index: 10;
        }

        .chat-panel-toggle:hover {
            background: #2d2d2d;
        }

        .chat-panel-toggle.active {
            background: var(--color-accent);
        }

        /* Chat Panel Container */
        .chat-panel-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            z-index: 1000;
            flex-direction: column;
        }

        .chat-panel-container.active {
            display: flex;
        }

        .chat-panel-header {
            background: var(--color-primary);
            color: white;
            padding: 16px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .shadow-branding {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .shadow-name {
            font-size: 18px;
            font-weight: 600;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .chat-messages-area {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            background: #fafafa;
        }

        .chat-message {
            margin-bottom: 16px;
            display: flex;
            flex-direction: column;
        }

        .chat-message.user {
            align-items: flex-end;
        }

        .chat-message.assistant {
            align-items: flex-start;
        }

        .chat-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 16px;
            word-wrap: break-word;
        }

        .chat-message.user .chat-bubble {
            background: var(--color-primary);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .chat-message.assistant .chat-bubble {
            background: white;
            color: #333;
            border: 1px solid #e5e7eb;
            border-bottom-left-radius: 4px;
        }

        .chat-timestamp {
            font-size: 11px;
            color: #9ca3af;
            margin-top: 4px;
        }

        .meeting-reminder-card {
            background: white;
            border: 2px solid var(--color-primary);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .reminder-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            color: var(--color-primary);
            font-weight: 600;
        }

        .meeting-info h4 {
            margin: 0 0 8px 0;
            font-size: 16px;
            color: #333;
        }

        .meeting-info p {
            margin: 4px 0;
            font-size: 14px;
            color: #666;
        }

        .prep-button-small {
            margin-top: 12px;
            padding: 8px 16px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .prep-button-small:hover {
            background: #2d2d2d;
        }

        .chat-input-area {
            padding: 16px 24px;
            background: white;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 12px;
        }

        .chat-input-area input {
            flex: 1;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
        }

        .chat-input-area input:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        .chat-input-area button {
            padding: 12px 24px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .chat-input-area button:hover {
            background: #2d2d2d;
        }

        /* Test Panel */
        .test-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 2000;
            max-width: 300px;
        }

        .test-panel-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #6b7280;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 12px;
            cursor: pointer;
            z-index: 1999;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .test-panel-toggle:hover {
            background: #4b5563;
        }

        .test-panel h3 {
            margin: 0 0 16px 0;
            font-size: 16px;
            color: #333;
        }

        .test-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .test-controls label {
            font-size: 13px;
            color: #666;
            font-weight: 500;
        }

        .test-controls input[type="range"] {
            width: 100%;
        }

        .test-controls select {
            padding: 8px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 13px;
        }

        .test-controls button {
            padding: 10px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
        }

        .test-controls button:hover {
            background: #2d2d2d;
        }

        /* Date Picker Card */
        .date-picker-card {
            background: white;
            border-radius: 16px;
            padding: 32px;
            margin-bottom: 24px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            text-align: center;
        }

        .date-picker-card h2 {
            color: #333;
            font-size: 24px;
            margin-bottom: 24px;
            font-weight: 600;
        }

        .date-input-group {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: center;
            margin-bottom: 24px;
        }

        .date-input {
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            color: #333;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.3s;
        }

        .date-input:hover {
            border-color: var(--color-primary);
            background: var(--color-bg);
        }

        .date-input:focus {
            outline: none;
            border-color: var(--color-primary);
            background: var(--color-bg);
            box-shadow: 0 0 0 3px rgba(26, 26, 26, 0.1);
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .action-card {
            background: var(--color-bg);
            border-radius: var(--radius-lg);
            padding: var(--spacing-xl);
            border: 1px solid var(--color-border);
            cursor: pointer;
            transition: all 0.2s;
        }

        .action-card:hover {
            border-color: var(--color-primary);
            background: var(--color-hover);
            transform: translateY(-1px);
        }

        .action-card.primary {
            background: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
        }

        .action-card.primary:hover {
            background: #2d2d2d;
        }

        .action-card.secondary {
            background: var(--color-bg);
            color: var(--color-text);
            border-color: var(--color-border);
        }

        .action-card h3 {
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .action-card p {
            font-size: 14px;
            opacity: 0.9;
            margin: 0;
        }

        /* Meeting Selection Modal */
        .meeting-selection-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .meeting-selection-modal.active {
            display: flex;
        }

        /* Loading Modal */
        .loading-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10001;
            align-items: center;
            justify-content: center;
        }

        .loading-modal-content {
            background: white;
            border-radius: 16px;
            padding: 48px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .loading-modal-content h3 {
            margin: 24px 0 8px 0;
            color: var(--color-text-primary);
            font-size: 20px;
        }

        .loading-modal-content p {
            margin: 0;
            color: var(--color-text-secondary);
            font-size: 14px;
        }

        .loading-modal-content .prep-spinner {
            margin: 0 auto;
            width: 48px;
            height: 48px;
        }

        .meeting-selection-content {
            background: white;
            border-radius: 16px;
            padding: 32px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .meeting-selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .meeting-selection-header h2 {
            color: #333;
            font-size: 24px;
            font-weight: 600;
            margin: 0;
        }

        .meeting-selection-close {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #666;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .meeting-selection-close:hover {
            background: #f0f0f0;
            color: #333;
        }

        .meeting-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .meeting-card {
            background: #fafafa;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .meeting-card:hover {
            border-color: var(--color-primary);
            background: var(--color-bg);
        }

        .meeting-card-time {
            color: var(--color-accent);
            font-size: 14px;
            font-weight: 500;
            margin-bottom: var(--spacing-sm);
        }

        .meeting-card-title {
            color: var(--color-text);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
            line-height: 1.4;
        }

        .meeting-card-attendees {
            color: var(--color-text-secondary);
            font-size: 14px;
        }

        h1 {
            color: var(--color-text);
            margin-bottom: var(--spacing-md);
            font-weight: 600;
            font-size: 28px;
        }

        .user-profile {
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .user-info {
            text-align: right;
        }

        .user-name {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .user-email {
            color: #666;
            font-size: 12px;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--color-primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            font-size: 16px;
        }

        #signInButton {
            background: var(--color-primary);
            color: white;
            border: none;
            padding: var(--spacing-sm) var(--spacing-lg);
            border-radius: var(--radius-sm);
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        #signInButton:hover {
            background: #2d2d2d;
        }

        .date-navigation {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .nav-button {
            background: #f0f0f0;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            transition: background 0.3s;
        }

        .nav-button:hover {
            background: #e0e0e0;
        }

        .current-date {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            min-width: 200px;
            text-align: center;
        }

        .events-container {
            display: none;
        }

        .events-container.visible {
            display: block;
        }

        .event {
            background: var(--color-bg);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
            border-radius: var(--radius-md);
            border-left: 3px solid var(--color-primary);
            border: 1px solid var(--color-border);
            cursor: pointer;
            transition: all 0.2s;
        }

        .event:hover {
            background: var(--color-hover);
            border-color: var(--color-primary);
        }

        .event-time {
            color: #666;
            font-size: 14px;
            margin-bottom: 6px;
        }

        .event-title {
            color: #333;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .event-description {
            color: #666;
            font-size: 14px;
        }

        .event-countdown {
            color: var(--color-accent);
            font-size: 13px;
            font-weight: 500;
            margin-top: var(--spacing-xs);
        }

        .event-countdown.past {
            color: var(--color-text-secondary);
        }

        .event-countdown.happening {
            color: var(--color-accent);
        }

        .meeting-info-toggle {
            background: var(--color-bg-secondary);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-sm);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            margin-top: var(--spacing-sm);
            transition: background 0.2s;
        }

        .meeting-info-toggle:hover {
            background: var(--color-hover);
        }

        .meeting-details {
            display: none;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e0e0e0;
        }

        .meeting-details.visible {
            display: block;
        }

        .detail-section {
            margin-bottom: 10px;
        }

        .detail-label {
            font-weight: 600;
            color: #333;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .detail-value {
            color: #666;
            font-size: 14px;
            margin-left: 8px;
        }

        .attendee {
            color: #666;
            font-size: 13px;
            margin-left: 8px;
            margin-bottom: 4px;
        }

        .context-panel {
            background: var(--color-bg-secondary);
            padding: var(--spacing-sm);
            margin-top: var(--spacing-sm);
            border-radius: var(--radius-sm);
            border-left: 3px solid var(--color-primary);
            border: 1px solid var(--color-border);
        }

        .context-header {
            font-weight: 600;
            color: #333;
            font-size: 13px;
            margin-bottom: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .context-content {
            display: none;
            margin-top: 8px;
        }

        .context-content.visible {
            display: block;
        }

        .email-item, .event-item {
            background: white;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #e0e0e0;
        }

        .email-item:hover, .event-item:hover {
            background: #f9f9f9;
        }

        .email-subject, .event-past-title {
            font-weight: 600;
            color: #333;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .email-date, .event-past-date {
            color: #999;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .email-snippet {
            color: #666;
            font-size: 12px;
            margin-top: 4px;
        }

        .email-body {
            display: none;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e0e0e0;
            color: #666;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .email-body.visible {
            display: block;
        }

        .loading-context {
            color: var(--color-text-secondary);
            font-size: 12px;
            font-style: italic;
        }

        .no-events {
            text-align: center;
            color: var(--color-text-secondary);
            padding: var(--spacing-xl);
            font-size: 16px;
        }

        .loading {
            text-align: center;
            color: var(--color-text-secondary);
            padding: var(--spacing-md);
        }

        #signOutButton, #manageAccountsButton {
            background: #666;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            margin-top: 20px;
            margin-right: 10px;
        }

        #signOutButton:hover, #manageAccountsButton:hover {
            background: #555;
        }

        #manageAccountsButton {
            background: #007bff;
        }

        #manageAccountsButton:hover {
            background: #0056b3;
        }

        /* Account Management Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-header h2 {
            margin: 0;
            color: #333;
        }

        .close-modal {
            font-size: 28px;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
            border: none;
            background: none;
        }

        .close-modal:hover {
            color: #000;
        }

        .account-list {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }

        .account-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 10px;
            background: #f9f9f9;
        }

        .account-info {
            flex: 1;
        }

        .account-email {
            font-weight: 600;
            color: #333;
        }

        .account-badge {
            display: inline-block;
            background: #007bff;
            color: white;
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 4px;
            margin-left: 8px;
        }

        .account-actions {
            display: flex;
            gap: 8px;
        }

        .account-actions button {
            padding: 6px 12px;
            font-size: 13px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-set-primary {
            background: #28a745;
            color: white;
        }

        .btn-set-primary:hover {
            background: #218838;
        }

        .btn-remove {
            background: var(--color-text-secondary);
            color: white;
        }

        .btn-remove:hover {
            background: var(--color-text);
        }

        .btn-add-account {
            width: 100%;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            margin-top: 10px;
        }

        .btn-add-account:hover {
            background: #0056b3;
        }

        .no-accounts {
            text-align: center;
            color: #666;
            padding: 20px;
        }

        /* Meeting Detail Page Styles */
        .meeting-detail-container {
            display: none;
        }

        .meeting-detail-container.visible {
            display: block;
        }

        .back-button {
            background: #f0f0f0;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 20px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .back-button:hover {
            background: #e0e0e0;
        }

        .meeting-header {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .meeting-title-large {
            font-size: 24px;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .meeting-time-large {
            font-size: 16px;
            color: #666;
            margin-bottom: 8px;
        }

        .meeting-status-large {
            font-size: 14px;
            color: var(--color-accent);
            font-weight: 500;
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            gap: 8px;
            border-bottom: 2px solid #e0e0e0;
            margin-bottom: 20px;
        }

        .tab-button {
            background: none;
            border: none;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .tab-button:hover {
            color: var(--color-primary);
        }

        .tab-button.active {
            color: var(--color-primary);
            border-bottom-color: var(--color-primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Attendee Selector */
        .attendee-filters {
            background: #f9f9f9;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .filter-header {
            font-weight: 600;
            color: #333;
            font-size: 14px;
            margin-bottom: 12px;
        }

        .attendee-checkbox-list {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .attendee-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .attendee-checkbox input[type="checkbox"] {
            cursor: pointer;
        }

        .attendee-checkbox label {
            cursor: pointer;
            font-size: 13px;
            color: #666;
        }

        .select-all-btn {
            background: var(--color-bg-secondary);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-sm);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            margin-top: var(--spacing-sm);
            transition: background 0.2s;
        }

        .select-all-btn:hover {
            background: var(--color-hover);
        }

        /* Attachments */
        .attachment-item {
            background: white;
            padding: 12px;
            margin-bottom: 12px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .attachment-icon {
            width: 40px;
            height: 40px;
            background: var(--color-bg-secondary);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text);
            font-weight: 500;
            font-size: 12px;
        }

        .attachment-info {
            flex: 1;
        }

        .attachment-name {
            font-weight: 600;
            color: #333;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .attachment-meta {
            color: #999;
            font-size: 12px;
        }

        .attachment-link {
            background: var(--color-primary);
            color: white;
            border: none;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-sm);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            text-decoration: none;
            transition: background 0.2s;
        }

        .attachment-link:hover {
            background: #2d2d2d;
        }

        .overview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }

        .overview-card {
            background: var(--color-bg-secondary);
            padding: var(--spacing-md);
            border-radius: var(--radius-md);
            border: 1px solid var(--color-border);
        }

        .overview-card-title {
            font-weight: 500;
            color: var(--color-text-secondary);
            font-size: 12px;
            margin-bottom: var(--spacing-sm);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .overview-card-content {
            color: var(--color-text);
            font-size: 14px;
        }

        .prep-button {
            background: var(--color-primary);
            color: white;
            border: none;
            padding: var(--spacing-sm) var(--spacing-lg);
            border-radius: var(--radius-sm);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            margin-left: var(--spacing-sm);
            transition: background 0.2s;
        }

        .prep-button:hover {
            background: #2d2d2d;
        }

        .prep-button:disabled {
            background: var(--color-border);
            cursor: not-allowed;
            color: var(--color-text-secondary);
        }

        .prep-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .prep-modal.visible {
            display: flex;
        }

        .prep-modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 1000px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .prep-modal-header {
            font-size: 24px;
            font-weight: 600;
            color: var(--color-text);
            margin-bottom: var(--spacing-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .prep-modal-close {
            background: none;
            border: none;
            font-size: 28px;
            color: var(--color-text-secondary);
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            line-height: 28px;
        }

        .prep-modal-close:hover {
            color: var(--color-text);
        }

        .prep-content {
            color: #333;
            font-size: 15px;
            line-height: 1.6;
        }

        .prep-content h2 {
            font-size: 18px;
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
            color: var(--color-text);
            font-weight: 600;
        }

        .prep-content h3 {
            font-size: 16px;
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
            color: var(--color-text-secondary);
            font-weight: 500;
        }

        .prep-content ul {
            margin-left: 20px;
            margin-bottom: 12px;
        }

        .prep-content li {
            margin-bottom: 6px;
        }

        /* Skeleton Loaders */
        .skeleton {
            background: linear-gradient(90deg, var(--color-bg-secondary) 25%, var(--color-hover) 50%, var(--color-bg-secondary) 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s ease-in-out infinite;
            border-radius: var(--radius-sm);
        }

        @keyframes skeleton-loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .skeleton-text {
            height: 16px;
            margin-bottom: var(--spacing-sm);
        }

        .skeleton-title {
            height: 24px;
            width: 60%;
            margin-bottom: var(--spacing-md);
        }

        .skeleton-card {
            height: 120px;
            margin-bottom: var(--spacing-md);
        }

        .prep-loading {
            text-align: center;
            padding: var(--spacing-xl);
            color: var(--color-text-secondary);
        }

        .prep-spinner {
            border: 2px solid var(--color-border);
            border-top: 2px solid var(--color-primary);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 0.8s linear infinite;
            margin: 0 auto var(--spacing-md);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Modern Brief Styles */
        .modern-brief {
            max-width: 900px;
            margin: 0 auto;
        }

        .brief-hero-card {
            background: var(--color-primary);
            color: white;
            padding: var(--spacing-xl);
            border-radius: var(--radius-lg);
            margin-bottom: var(--spacing-lg);
            border: 1px solid var(--color-border);
        }

        .brief-hero-card h2 {
            margin: 0 0 8px 0;
            font-size: 28px;
            font-weight: 700;
        }

        .meeting-time {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 16px;
        }

        .executive-summary {
            font-size: 16px;
            line-height: 1.6;
            margin: 16px 0 0 0;
            opacity: 0.95;
        }

        .brief-section {
            margin-bottom: 32px;
        }

        .brief-section h3 {
            font-size: 20px;
            font-weight: 700;
            margin: 0 0 16px 0;
            color: #333;
        }

        .attendee-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 16px;
        }

        .attendee-modern-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            display: flex;
            gap: 16px;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }

        .attendee-modern-card:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
            transform: translateY(-2px);
        }

        .attendee-avatar-modern {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--color-primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 500;
            flex-shrink: 0;
        }

        .attendee-details {
            flex: 1;
            min-width: 0;
        }

        .attendee-details h4 {
            margin: 0 0 4px 0;
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .attendee-title {
            margin: 0 0 12px 0;
            font-size: 13px;
            color: #666;
        }

        .key-facts {
            margin: 0;
            padding: 0 0 0 20px;
            list-style: none;
        }

        .key-facts li {
            font-size: 13px;
            color: #555;
            line-height: 1.6;
            margin-bottom: 6px;
            position: relative;
        }

        .key-facts li:before {
            content: 'â€¢';
            color: var(--color-primary);
            font-weight: bold;
            position: absolute;
            left: -15px;
        }

        .action-checklist {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }

        .action-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .action-item:last-child {
            border-bottom: none;
        }

        .action-item:hover {
            background: #f9f9f9;
            margin: 0 -8px;
            padding-left: 8px;
            padding-right: 8px;
            border-radius: 6px;
        }

        .action-item input[type="checkbox"] {
            margin-top: 3px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .action-item span {
            font-size: 14px;
            color: #333;
            line-height: 1.5;
        }

        /* Brief Tabs Styles */
        .brief-tabs {
            display: flex;
            gap: 4px;
            border-bottom: 2px solid #e0e0e0;
            margin-bottom: 24px;
            overflow-x: auto;
        }

        .brief-tab-button {
            background: none;
            border: none;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .brief-tab-button:hover {
            color: var(--color-primary);
            background: var(--color-bg-secondary);
        }

        .brief-tab-button.active {
            color: var(--color-primary);
            border-bottom-color: var(--color-primary);
        }

        .brief-tab-content {
            display: none;
        }

        .brief-tab-content.active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Attendee Cards */
        .attendee-card {
            background: #f9f9f9;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            border-left: 4px solid #4285f4;
        }

        .attendee-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .attendee-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--color-primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            font-size: 18px;
        }

        .attendee-info h4 {
            margin: 0;
            color: #333;
            font-size: 16px;
        }

        .attendee-info p {
            margin: 4px 0 0 0;
            color: #666;
            font-size: 13px;
        }

        .attendee-insights {
            margin-top: 12px;
        }

        .insight-section {
            margin-bottom: 12px;
        }

        .insight-label {
            font-weight: 600;
            color: #555;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .insight-value {
            color: #666;
            font-size: 14px;
            line-height: 1.5;
        }

        /* Insight Cards */
        .insight-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .insight-card h4 {
            margin: 0 0 var(--spacing-sm) 0;
            color: var(--color-text);
            font-size: 16px;
            font-weight: 600;
        }

        .insight-card ul {
            margin: 8px 0;
            padding-left: 20px;
        }

        .insight-card li {
            margin-bottom: 8px;
            color: #666;
            line-height: 1.5;
        }

        /* Source Citations */
        .source-citation {
            display: inline-block;
            background: var(--color-bg-secondary);
            color: var(--color-text);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-sm);
            font-size: 11px;
            text-decoration: none;
            margin-left: var(--spacing-sm);
            transition: background 0.2s;
            border: 1px solid var(--color-border);
        }

        .source-citation:hover {
            background: var(--color-hover);
        }

        /* Progress Bar */
        .progress-container {
            width: 100%;
            height: 4px;
            background: #f0f0f0;
            border-radius: 2px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-bar {
            height: 100%;
            background: var(--color-primary);
            width: 0%;
            transition: width 0.3s;
        }

        /* Copy Button */
        .copy-section-btn {
            background: #f0f0f0;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            float: right;
            transition: background 0.2s;
        }

        .copy-section-btn:hover {
            background: #e0e0e0;
        }

        /* Document Card */
        .document-card {
            background: #fff9e6;
            border-left: 4px solid #fbbc04;
            padding: 16px;
            margin-bottom: 16px;
            border-radius: 8px;
        }

        .document-card h4 {
            margin: 0 0 8px 0;
            color: #333;
            font-size: 15px;
        }

        .document-meta {
            color: #666;
            font-size: 12px;
            margin-bottom: 12px;
        }

        /* Analysis Sections */
        .analysis-section {
            padding: 24px;
            background: #ffffff;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .analysis-section h3 {
            margin: 0 0 16px 0;
            color: #333;
            font-size: 20px;
        }

        .analysis-text {
            color: #555;
            line-height: 1.8;
            font-size: 15px;
            white-space: pre-wrap;
        }

        /* Attendee Email */
        .attendee-email {
            color: #888;
            font-size: 13px;
            margin: 4px 0;
        }

        .key-facts-section {
            margin-top: 12px;
        }

        .key-facts-section strong {
            color: #666;
            font-size: 13px;
            display: block;
            margin-bottom: 8px;
        }

        /* Recommendations */
        .recommendations-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .recommendation-item {
            display: flex;
            gap: var(--spacing-sm);
            padding: var(--spacing-md);
            background: var(--color-bg-secondary);
            border-left: 3px solid var(--color-primary);
            border-radius: var(--radius-sm);
            margin-bottom: var(--spacing-sm);
            align-items: flex-start;
        }

        .rec-number {
            background: var(--color-primary);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            font-size: 14px;
            flex-shrink: 0;
        }

        .rec-text {
            color: #333;
            line-height: 1.6;
            font-size: 15px;
        }

        /* Real-Time Meeting Assistant Styles */
        .enter-meeting-button {
            background: var(--color-primary);
            color: white;
            border: none;
            padding: var(--spacing-sm) var(--spacing-lg);
            border-radius: var(--radius-md);
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        .enter-meeting-button:hover {
            background: #2d2d2d;
        }

        .meeting-assistant {
            margin-top: 30px;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
        }

        .assistant-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e5e7eb;
        }

        .assistant-header h2 {
            margin: 0;
            font-size: 20px;
            color: #1f2937;
        }

        .stop-assistant-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .stop-assistant-btn:hover {
            background: #dc2626;
        }

        .assistant-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .transcript-panel, .suggestions-panel {
            background: #f9fafb;
            border-radius: 8px;
            padding: 15px;
            min-height: 400px;
            max-height: 600px;
            overflow-y: auto;
        }

        .transcript-panel h3, .suggestions-panel h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #374151;
            font-weight: 600;
        }

        .transcript-content, .suggestions-content {
            font-size: 14px;
            line-height: 1.6;
        }

        .transcript-item {
            margin-bottom: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: var(--color-bg);
            border-radius: var(--radius-sm);
            border-left: 3px solid var(--color-primary);
        }

        .transcript-item.user {
            border-left-color: var(--color-accent);
            background: var(--color-bg-secondary);
        }

        .transcript-speaker {
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 4px;
            font-size: 13px;
        }

        .transcript-text {
            color: #4b5563;
        }

        .transcript-timestamp {
            font-size: 11px;
            color: #9ca3af;
            margin-top: 4px;
        }

        .suggestion-item {
            margin-bottom: 12px;
            padding: 12px;
            border-radius: 6px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .suggestion-item.info {
            background: #dbeafe;
            border-left: 3px solid #3b82f6;
        }

        .suggestion-item.warning {
            background: #fef3c7;
            border-left: 3px solid #f59e0b;
        }

        .suggestion-item.error {
            background: #fee2e2;
            border-left: 3px solid #ef4444;
        }

        .suggestion-type {
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 4px;
            letter-spacing: 0.5px;
        }

        .suggestion-item.info .suggestion-type {
            color: #1e40af;
        }

        .suggestion-item.warning .suggestion-type {
            color: #b45309;
        }

        .suggestion-item.error .suggestion-type {
            color: #991b1b;
        }

        .suggestion-message {
            color: #374151;
            font-size: 13px;
            line-height: 1.5;
        }

        .suggestion-placeholder {
            text-align: center;
            color: #9ca3af;
            padding: 40px 20px;
            font-style: italic;
        }

        /* Interactive Prep Chat Styles */
        .chat-message {
            margin-bottom: 16px;
            display: flex;
            flex-direction: column;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chat-message.user {
            align-items: flex-end;
        }

        .chat-message.assistant {
            align-items: flex-start;
        }

        .chat-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 16px;
            font-size: 14px;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .chat-message.user .chat-bubble {
            background: var(--color-primary);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .chat-message.assistant .chat-bubble {
            background: white;
            color: #333;
            border: 1px solid #e5e7eb;
            border-bottom-left-radius: 4px;
        }

        .chat-timestamp {
            font-size: 11px;
            color: #9ca3af;
            margin-top: 4px;
            padding: 0 4px;
        }

        .chat-tool-call {
            font-size: 12px;
            color: #667eea;
            font-style: italic;
            margin-top: 8px;
            padding: 8px 12px;
            background: #f3f4f6;
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }

        .chat-loading {
            display: inline-flex;
            gap: 4px;
            padding: 12px 16px;
        }

        .chat-loading-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #9ca3af;
            animation: bounce 1.4s infinite;
        }

        .chat-loading-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .chat-loading-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes bounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }

        /* ===== TIMELINE STYLES ===== */
        .timeline-container {
            position: relative;
            padding: 20px 0;
            max-height: 600px;
            overflow-y: auto;
        }

        .timeline-line {
            position: absolute;
            left: 30px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--color-border);
        }

        .timeline-event {
            position: relative;
            padding-left: 70px;
            margin-bottom: 30px;
            animation: slideIn 0.4s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .timeline-marker {
            position: absolute;
            left: 21px;
            top: 8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 0 2px #e0e0e0;
            z-index: 10;
        }

        .timeline-marker.email {
            background: var(--color-primary);
        }

        .timeline-marker.document {
            background: var(--color-text-secondary);
        }

        .timeline-marker.meeting {
            background: var(--color-accent);
        }

        .timeline-event.recent .timeline-marker {
            box-shadow: 0 0 0 2px var(--color-accent), 0 0 10px rgba(37, 99, 235, 0.2);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 0 2px var(--color-accent), 0 0 10px rgba(37, 99, 235, 0.2);
            }
            50% {
                box-shadow: 0 0 0 2px var(--color-accent), 0 0 20px rgba(37, 99, 235, 0.3);
            }
        }

        .timeline-content {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: all 0.3s;
        }

        .timeline-content:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 8px;
        }

        .timeline-type-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .timeline-type-badge.email {
            background: var(--color-bg-secondary);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }

        .timeline-type-badge.document {
            background: var(--color-bg-secondary);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }

        .timeline-type-badge.meeting {
            background: var(--color-bg-secondary);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }

        .timeline-date {
            font-size: 13px;
            color: #666;
            font-weight: 500;
        }

        .timeline-title {
            margin: 0 0 8px 0;
            font-size: 15px;
            font-weight: 600;
            color: #333;
            line-height: 1.4;
        }

        .timeline-participants {
            margin: 4px 0;
            font-size: 13px;
            color: #666;
            font-style: italic;
        }

        .timeline-snippet {
            margin: var(--spacing-sm) 0 0 0;
            font-size: 13px;
            color: var(--color-text);
            line-height: 1.5;
            padding: var(--spacing-sm);
            background: var(--color-bg-secondary);
            border-left: 3px solid var(--color-primary);
            border-radius: var(--radius-sm);
        }

        .timeline-action {
            margin: 4px 0;
            font-size: 13px;
            color: #666;
            font-weight: 500;
        }

        .timeline-recent-badge {
            display: inline-block;
            margin-top: var(--spacing-sm);
            padding: var(--spacing-xs) var(--spacing-sm);
            background: var(--color-accent);
            color: white;
            font-size: 11px;
            font-weight: 500;
            border-radius: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Relationship Analysis Styles */
        .relationship-analysis {
            line-height: 1.8;
            font-size: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button id="prepViewToggle" class="prep-view-toggle" onclick="togglePrepView()">Prep View</button>
            <button id="chatPanelToggle" class="chat-panel-toggle" onclick="toggleChatPanel()">Chat</button>
            <div id="userProfile" class="user-profile" style="display: none;">
                <div class="user-info">
                    <div class="user-name" id="userName"></div>
                    <div class="user-email" id="userEmail"></div>
                </div>
                <div class="user-avatar" id="userAvatar"></div>
            </div>
            <h1>Today's Agenda</h1>
            <button id="signInButton">Sign in with Google</button>
        </div>

        <!-- Prep View Container -->
        <div id="prepViewContainer" class="prep-view-container">
            <div class="date-picker-card">
                <h2>Select Date</h2>
                <div class="date-input-group">
                    <input type="date" id="chatModeDatePicker" class="date-input" />
                </div>
            </div>
            <div class="action-buttons">
                <div class="action-card primary" onclick="startDayPrep()">
                    <h3>ðŸ“… Day Prep</h3>
                    <p>Get a comprehensive 5-7 minute voice brief for all meetings on this day</p>
                </div>
                <div class="action-card secondary" onclick="startMeetingPrep()">
                    <h3>ðŸŽ™ï¸ Meeting Prep</h3>
                    <p>Select a specific meeting for a 2-minute voice prep brief</p>
                </div>
            </div>
        </div>

        <!-- Chat Panel Container -->
        <div id="chatPanelContainer" class="chat-panel-container">
            <div class="chat-panel-header">
                <div class="shadow-branding">
                    <span class="shadow-name">Shadow</span>
                    <span class="status-indicator" id="chatStatusIndicator">â—</span>
                </div>
                <button onclick="toggleChatPanel()" style="background: transparent; border: 1px solid white; color: white; padding: 6px 12px; border-radius: 6px; cursor: pointer;">âœ• Close</button>
            </div>
            <div class="chat-messages-area" id="chatMessagesArea">
                <!-- Messages and meeting cards appear here -->
            </div>
            <div class="chat-input-area">
                <input type="text" id="chatPanelInput" placeholder="Ask Shadow anything..." onkeypress="if(event.key==='Enter') sendChatPanelMessage()" />
                <button onclick="sendChatPanelMessage()">Send</button>
            </div>
        </div>

        <!-- Test Panel Toggle Button -->
        <button id="testPanelToggle" class="test-panel-toggle" onclick="toggleTestPanel()">Test Panel</button>

        <!-- Test Panel -->
        <div id="testPanel" class="test-panel" style="display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <h3 style="margin: 0;">Test Reminders</h3>
                <button onclick="toggleTestPanel()" style="background: transparent; border: none; font-size: 18px; cursor: pointer; color: #666;">Ã—</button>
            </div>
            <div class="test-controls">
                <label>Reminder Window (minutes):</label>
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                    <input type="range" id="reminderWindowSlider" min="1" max="60" value="15" oninput="updateReminderWindow(this.value)" style="flex: 1;" />
                    <span id="reminderWindowValue" style="min-width: 30px; text-align: right;">15</span>
                </div>
                <label style="display: block; margin-bottom: 8px;">Select Meeting:</label>
                <select id="testMeetingSelector" style="width: 100%; margin-bottom: 12px;">
                    <option value="">Select meeting...</option>
                </select>
                <button onclick="testReminder()" style="width: 100%;">Test Reminder</button>
            </div>
        </div>

        <!-- Meeting Selection Modal -->
        <div id="meetingSelectionModal" class="meeting-selection-modal">
            <div class="meeting-selection-content">
                <div class="meeting-selection-header">
                    <h2>Select Meeting</h2>
                    <button class="meeting-selection-close" onclick="closeMeetingSelection()">&times;</button>
                </div>
                <div id="meetingList" class="meeting-list">
                    <!-- Meetings will be populated here -->
                </div>
            </div>
        </div>

        <!-- Loading Modal for Meeting Prep -->
        <div id="meetingPrepLoadingModal" class="loading-modal" style="display: none;">
            <div class="loading-modal-content">
                <div class="prep-spinner"></div>
                <h3>Preparing your meeting brief...</h3>
                <p>This may take a minute. Please wait.</p>
            </div>
        </div>

        <div id="eventsContainer" class="events-container visible">
            <div class="date-navigation">
                <button class="nav-button" id="prevDay">ï¿½</button>
                <div class="current-date" id="currentDate"></div>
                <button class="nav-button" id="nextDay">ï¿½</button>
            </div>

            <div id="eventsList"></div>

            <div style="text-align: center;">
                <button id="manageAccountsButton">Manage Accounts</button>
                <button id="signOutButton">Sign Out</button>
            </div>
        </div>

        <!-- Account Management Modal -->
        <div id="accountModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Manage Connected Accounts</h2>
                    <button class="close-modal" id="closeAccountModal">&times;</button>
                </div>
                <ul id="accountList" class="account-list">
                    <li class="no-accounts">Loading accounts...</li>
                </ul>
                <button id="addAccountButton" class="btn-add-account">+ Add Another Account</button>
            </div>
        </div>

        <!-- Meeting Detail View -->
        <div id="meetingDetailContainer" class="meeting-detail-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <button class="back-button" onclick="showCalendarView()">â† Back to Calendar</button>
                <div style="display: flex; gap: 10px;">
                    <button class="prep-button" id="prepMeButton" onclick="prepareForMeeting()">Prep Me</button>
                    <button class="prep-button" id="interactivePrepButton" onclick="startInteractivePrep()" style="background: var(--color-primary);">ðŸ’¬ Interactive Prep</button>
                    <button class="prep-button" id="voicePrepButton" onclick="startVoicePrep()" style="background: var(--color-primary);">ðŸŽ™ï¸ Voice Prep Mode</button>
                    <button class="enter-meeting-button" id="enterMeetingButton" onclick="enterMeeting()" style="display: none;">ðŸŽ¤ Entering Meeting</button>
                </div>
            </div>

            <div class="meeting-header">
                <div class="meeting-title-large" id="detailTitle"></div>
                <div class="meeting-time-large" id="detailTime"></div>
                <div class="meeting-status-large" id="detailStatus"></div>
            </div>

            <div class="tab-navigation">
                <button class="tab-button active" onclick="switchTab('overview')">Overview</button>
                <button class="tab-button" onclick="switchTab('attendees')">Attendees</button>
                <button class="tab-button" onclick="switchTab('emails')">Past Emails</button>
                <button class="tab-button" onclick="switchTab('attachments')">Attachments</button>
                <button class="tab-button" onclick="switchTab('files')">Drive Files</button>
            </div>

            <div id="tab-overview" class="tab-content active">
                <div class="overview-grid" id="overviewGrid"></div>
            </div>

            <div id="tab-attendees" class="tab-content">
                <div id="attendeesList"></div>
            </div>

            <div id="tab-emails" class="tab-content">
                <div class="attendee-filters" id="emailFilters">
                    <div class="filter-header">Filter by Attendee</div>
                    <div class="attendee-checkbox-list" id="emailAttendeeCheckboxes"></div>
                    <button class="select-all-btn" onclick="toggleAllEmailFilters()">Select All / None</button>
                </div>
                <div id="emailsList"></div>
            </div>

            <div id="tab-attachments" class="tab-content">
                <div class="attendee-filters" id="attachmentFilters">
                    <div class="filter-header">Filter by Attendee</div>
                    <div class="attendee-checkbox-list" id="attachmentAttendeeCheckboxes"></div>
                    <button class="select-all-btn" onclick="toggleAllAttachmentFilters()">Select All / None</button>
                </div>
                <div id="attachmentsList"></div>
            </div>

            <div id="tab-files" class="tab-content">
                <div class="attendee-filters" id="filesFilters">
                    <div class="filter-header">Filter by Attendee</div>
                    <div class="attendee-checkbox-list" id="filesAttendeeCheckboxes"></div>
                    <button class="select-all-btn" onclick="toggleAllFilesFilters()">Select All / None</button>
                </div>
                <div id="filesList"></div>
            </div>

            <!-- Real-Time Meeting Assistant -->
            <div id="meetingAssistantContainer" class="meeting-assistant" style="display: none;">
                <div class="assistant-header">
                    <h2>ðŸŽ¤ Real-Time Meeting Assistant</h2>
                    <button class="stop-assistant-btn" onclick="stopMeetingAssistant()">Stop</button>
                </div>

                <div class="assistant-grid">
                    <!-- Live Transcript -->
                    <div class="transcript-panel">
                        <h3>Live Transcript</h3>
                        <div id="transcriptContainer" class="transcript-content"></div>
                    </div>

                    <!-- AI Suggestions -->
                    <div class="suggestions-panel">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <h3 style="margin: 0;">AI Suggestions</h3>
                            <button onclick="clearSuggestions()" style="background: #666; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 13px; cursor: pointer;">
                                Clear
                            </button>
                        </div>
                        <div id="suggestionsContainer" class="suggestions-content">
                            <div class="suggestion-placeholder">Listening for conversation...</div>
                        </div>
                    </div>
                </div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button id="signOutButton2" style="background: #666; color: white; border: none; padding: 8px 16px; border-radius: 6px; font-size: 14px; cursor: pointer;" onclick="signOut()">Sign Out</button>
            </div>
        </div>

        <!-- Prep Modal -->
        <div id="prepModal" class="prep-modal">
            <div class="prep-modal-content">
                <div class="prep-modal-header">
                    <span>Meeting Preparation Brief</span>
                    <button class="prep-modal-close" onclick="closePrepModal()">&times;</button>
                </div>
                <div id="prepModalBody"></div>
            </div>
        </div>

        <!-- Speaker Mapping Modal -->
        <div id="speakerMappingModal" class="prep-modal" style="display: none;">
            <div class="prep-modal-content" style="max-width: 500px;">
                <div class="prep-modal-header">
                    <span>ðŸ‘¤ Identify Speakers</span>
                </div>
                <div style="padding: 24px;">
                    <p style="margin-bottom: 20px; color: #666;">We've detected multiple speakers. Please identify who is speaking:</p>
                    <div id="speakerMappingList"></div>
                    <button class="enter-meeting-button" onclick="confirmSpeakerMapping()" style="width: 100%; margin-top: 20px;">
                        Continue
                    </button>
                </div>
            </div>
        </div>

        <!-- Interactive Prep Chat Interface -->
        <div id="interactivePrepOverlay" class="prep-modal" style="display: none;">
            <div class="prep-modal-content" style="max-width: 1400px; max-height: 90vh; display: flex; flex-direction: row; gap: 0;">
                <!-- Meeting Brief Sidebar -->
                <div style="width: 400px; border-right: 2px solid #e5e7eb; display: flex; flex-direction: column; background: #f9fafb;">
                    <div style="padding: 16px; border-bottom: 2px solid #e5e7eb; background: white;">
                        <h3 style="margin: 0; font-size: 16px; color: #1f2937;">ðŸ“‹ Meeting Brief</h3>
                    </div>
                    <div id="interactiveBriefContent" style="flex: 1; overflow-y: auto; padding: 20px; font-size: 13px;">
                        <div style="text-align: center; color: #999; padding: 40px 20px;">
                            Loading brief...
                        </div>
                    </div>
                </div>

                <!-- Chat Interface -->
                <div style="flex: 1; display: flex; flex-direction: column;">
                    <div class="prep-modal-header" style="flex-shrink: 0;">
                        <span>ðŸ’¬ Interactive Prep Assistant</span>
                        <button class="prep-modal-close" onclick="closeInteractivePrep()">&times;</button>
                    </div>

                    <div style="padding: 20px; flex: 1; display: flex; flex-direction: column; overflow: hidden;">
                        <div style="color: #666; font-size: 14px; margin-bottom: 12px; padding: 12px; background: #f8f9fa; border-radius: 8px;">
                            <strong id="interactiveMeetingTitle"></strong>
                            <div style="font-size: 13px; margin-top: 4px;" id="interactiveMeetingTime"></div>
                        </div>

                        <!-- Chat History -->
                        <div id="chatHistory" style="flex: 1; overflow-y: auto; margin-bottom: 16px; padding: 16px; background: #fafafa; border-radius: 8px; min-height: 300px;">
                            <div class="chat-placeholder" style="text-align: center; color: #999; padding: 40px 20px;">
                                <div style="font-size: 24px; margin-bottom: 12px;">ðŸ’¬</div>
                                <div>Ask me anything about this meeting...</div>
                                <div style="font-size: 13px; margin-top: 8px;">Try: "Tell me about the attendees" or "What documents are attached?"</div>
                            </div>
                        </div>

                    <!-- Input Area -->
                    <div style="flex-shrink: 0;">
                        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                            <input
                                type="text"
                                id="chatInput"
                                placeholder="Type a message or use voice..."
                                style="flex: 1; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px;"
                                onkeypress="if(event.key==='Enter') sendChatMessage()"
                            />
                            <button
                                id="voiceInputBtn"
                                onclick="toggleVoiceInput()"
                                style="padding: 12px 20px; background: var(--color-primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px;"
                                title="Voice input"
                            >
                                ðŸŽ¤
                            </button>
                            <button
                                onclick="sendChatMessage()"
                                style="padding: 12px 20px; background: var(--color-primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px;"
                            >
                                Send
                            </button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 12px; font-size: 13px; color: #666;">
                            <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                <input type="checkbox" id="voiceOutputToggle" checked />
                                <span>Voice responses</span>
                            </label>
                            <span id="chatStatus" style="margin-left: auto;"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Voice Prep Mode Modal (outside container for proper fixed positioning) -->
    <div id="voicePrepOverlay" class="prep-modal" style="display: none;">
        <div class="prep-modal-content" style="max-width: 800px; max-height: 90vh;">
            <div class="prep-modal-header">
                <span>ðŸŽ™ï¸ Voice Prep Mode - 2-Minute Briefing</span>
                <button class="prep-modal-close" onclick="closeVoicePrep()">&times;</button>
            </div>

            <div style="padding: 30px;">
                <!-- Meeting Info -->
                <div style="color: var(--color-text-secondary); font-size: 14px; margin-bottom: 20px; padding: 16px; background: var(--color-bg-secondary); border-radius: 8px; text-align: center; border: 1px solid var(--color-border);">
                    <strong id="voicePrepMeetingTitle"></strong>
                    <div style="font-size: 13px; margin-top: 4px;" id="voicePrepMeetingTime"></div>
                </div>

                <!-- Status and Timer -->
                <div style="margin-bottom: 20px; text-align: center;">
                    <div style="font-size: 48px; font-weight: 600; color: var(--color-primary); margin-bottom: 8px;" id="voicePrepTimer">2:00</div>
                    <div style="font-size: 14px; color: var(--color-text-secondary);" id="voicePrepStatus">Ready to start your briefing</div>
                </div>

                <!-- Waveform Visualization -->
                <div style="height: 100px; background: #f0f0f0; border-radius: 12px; margin-bottom: 20px; display: flex; align-items: center; justify-content: center; overflow: hidden;" id="voicePrepWaveform">
                    <div style="color: #999; font-size: 14px;">Audio visualization</div>
                </div>

                <!-- Transcript Display -->
                <div style="height: 200px; overflow-y: auto; background: #fafafa; border-radius: 12px; padding: 16px; margin-bottom: 20px; font-size: 14px; line-height: 1.6;" id="voicePrepTranscript">
                    <div style="text-align: center; color: #999; padding: 40px 20px;">
                        <div style="font-size: 24px; margin-bottom: 12px;">ðŸŽ™ï¸</div>
                        <div>Your 2-minute voice briefing will appear here...</div>
                        <div style="font-size: 13px; margin-top: 8px;">The AI will guide you through attendees, insights, agenda, and recommendations. You can interrupt anytime to ask questions.</div>
                    </div>
                </div>

                <!-- Controls -->
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="voicePrepStartBtn" onclick="startVoicePrepSession()" style="padding: 12px 32px; background: var(--color-primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 500;">
                        ðŸŽ™ï¸ Start Briefing
                    </button>
                    <button id="voicePrepStopBtn" onclick="stopVoicePrepSession()" style="padding: 12px 32px; background: var(--color-text-secondary); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; display: none;">
                        â¹ï¸ Stop
                    </button>
                </div>

                <!-- Instructions -->
                <div style="margin-top: 20px; padding: 12px; background: var(--color-bg-secondary); border-radius: 8px; font-size: 13px; color: var(--color-text); border: 1px solid var(--color-border);">
                    <strong>ðŸ’¡ How it works:</strong>
                    <ul style="margin: 8px 0 0 20px; padding: 0;">
                        <li>The AI will deliver a structured 2-minute briefing</li>
                        <li>Interrupt anytime by speaking - just ask your question</li>
                        <li>After the briefing, you can continue asking questions</li>
                        <li>Make sure your microphone is enabled</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script>
        const CLIENT_ID = '173246695918-vbpcthe7tuo0vhmft1d1poots6cd38l3.apps.googleusercontent.com';
        const API_KEY = 'YOUR_API_KEY'; // Not needed for OAuth flow
        const SCOPES = 'openid https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/calendar.readonly https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/drive.readonly';
        // API keys moved to backend server for security

        let tokenClient;
        let accessToken = null;
        let currentDate = new Date();
        let countdownInterval = null;
        let userEmail = null;
        let userProfile = null;
        let currentMeeting = null;
        let allEvents = [];
        let currentEmails = [];
        let currentAttachments = [];
        let currentFiles = [];

        window.onload = function() {
            // Initialize Google Identity Services - use CODE flow for multi-account support
            // NOTE: initCodeClient with ux_mode: 'popup' REQUIRES 'postmessage' in authorized redirect URIs
            tokenClient = google.accounts.oauth2.initCodeClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                ux_mode: 'popup',
                callback: async (response) => {
                    if (response.code) {
                        // Exchange code for session on backend
                        await exchangeCodeForSession(response.code);
                    } else if (response.error) {
                        // Handle OAuth errors
                        console.error('OAuth error:', response.error, response);
                        if (response.error === 'invalid_request') {
                            console.error('OAuth invalid_request error details:', {
                                error: response.error,
                                error_description: response.error_description,
                                hint: 'Google Identity Services initCodeClient with popup mode REQUIRES "postmessage" in authorized redirect URIs'
                            });
                            alert('OAuth configuration error: "postmessage" must be added to Authorized redirect URIs in Google Cloud Console.\n\nThis is required for Google Identity Services popup flow.');
                        } else {
                            alert('Sign in failed: ' + (response.error_description || response.error));
                        }
                    }
                },
            });

            // Check if already signed in (session exists)
            checkSession();

            document.getElementById('signInButton').addEventListener('click', () => {
                tokenClient.requestCode();
            });

            document.getElementById('signOutButton').addEventListener('click', signOut);
            document.getElementById('prevDay').addEventListener('click', () => changeDay(-1));
            document.getElementById('nextDay').addEventListener('click', () => changeDay(1));

            // Account management modal
            document.getElementById('manageAccountsButton').addEventListener('click', openAccountModal);
            document.getElementById('closeAccountModal').addEventListener('click', closeAccountModal);
            document.getElementById('addAccountButton').addEventListener('click', addNewAccount);
        };

        /**
         * Exchange OAuth code for session (multi-account mode)
         */
        async function exchangeCodeForSession(code) {
            try {
                const response = await fetch('/auth/google/callback', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include', // Include cookies
                    body: JSON.stringify({ code })
                });

                const data = await response.json();

                if (data.success) {
                    // Store access token for direct Google API calls
                    accessToken = data.access_token;
                    console.log('âœ… Access token stored');

                    // Session cookie is automatically set by server
                    await onSignIn();
                } else {
                    console.error('Sign in failed:', data.error);
                    alert('Sign in failed: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error exchanging code:', error);
                alert('Sign in failed. Please try again.');
            }
        }

        /**
         * Check if user already has a valid session
         */
        async function checkSession() {
            try {
                const response = await fetch('/auth/me', {
                    credentials: 'include' // Include cookies
                });

                if (response.ok) {
                    const data = await response.json();
                    userEmail = data.user.email;
                    userProfile = data.user;
                    accessToken = data.accessToken || null; // Get token if available
                    await onSignIn();
                }
            } catch (error) {
                // No valid session, user needs to sign in
                console.log('No valid session found');
            }
        }

        async function fetchUserProfile() {
            try {
                // Use session-based auth endpoint instead of direct Google API
                const response = await fetch('/auth/me', {
                    credentials: 'include'
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch user profile');
                }

                const data = await response.json();
                const user = data.user;

                userEmail = user.email;
                userProfile = user;

                // Display user profile
                document.getElementById('userName').textContent = user.name || 'User';
                document.getElementById('userEmail').textContent = user.email;

                // Get initials for avatar
                const nameParts = (user.name || user.email).split(' ');
                const initials = nameParts.length > 1
                    ? nameParts[0][0] + nameParts[nameParts.length - 1][0]
                    : nameParts[0][0];
                document.getElementById('userAvatar').textContent = initials.toUpperCase();

                document.getElementById('userProfile').style.display = 'flex';
            } catch (error) {
                console.error('Error fetching user profile:', error);
            }
        }

        async function onSignIn() {
            document.getElementById('signInButton').style.display = 'none';
            document.getElementById('eventsContainer').classList.add('visible');

            // Fetch user profile first
            await fetchUserProfile();

            // Then load events
            loadEvents();
        }

        async function signOut() {
            try {
                // Call backend logout endpoint
                await fetch('/auth/logout', {
                    method: 'POST',
                    credentials: 'include'
                });
            } catch (error) {
                console.error('Logout error:', error);
            }

            // Clear all user-specific state to prevent data leakage
            accessToken = null;
            userEmail = null;
            userProfile = null;
            interactiveBrief = null;
            meetingBrief = null;
            currentMeetingId = null;
            currentEmails = [];
            currentFiles = [];
            currentAttachments = [];
            currentMeeting = null;

            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            document.getElementById('signInButton').style.display = 'block';
            document.getElementById('eventsContainer').classList.remove('visible');
            document.getElementById('userProfile').style.display = 'none';
        }

        function changeDay(delta) {
            currentDate.setDate(currentDate.getDate() + delta);
            loadEvents();
        }

        function formatDate(date) {
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        function formatTime(dateString) {
            const date = new Date(dateString);
            return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
        }

        async function loadEvents() {
            const eventsList = document.getElementById('eventsList');
            const currentDateEl = document.getElementById('currentDate');

            currentDateEl.textContent = formatDate(currentDate);
            // Show skeleton loaders
            eventsList.innerHTML = `
                <div class="skeleton-card"></div>
                <div class="skeleton-card"></div>
                <div class="skeleton-card"></div>
            `;

            // Check if accessToken is available
            if (!accessToken) {
                eventsList.innerHTML = '<div class="no-events">Please sign in to view events.</div>';
                return;
            }

            const startOfDay = new Date(currentDate);
            startOfDay.setHours(0, 0, 0, 0);

            const endOfDay = new Date(currentDate);
            endOfDay.setHours(23, 59, 59, 999);

            try {
                const response = await fetch(
                    `https://www.googleapis.com/calendar/v3/calendars/primary/events?` +
                    `timeMin=${startOfDay.toISOString()}&` +
                    `timeMax=${endOfDay.toISOString()}&` +
                    `singleEvents=true&` +
                    `orderBy=startTime`,
                    {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    }
                );

                // Handle 401 errors (token expired/revoked)
                if (response.status === 401) {
                    console.warn('Token expired or revoked, clearing session');
                    accessToken = null;
                    eventsList.innerHTML = '<div class="no-events">Your session has expired. Please sign in again.</div>';
                    return;
                }

                if (!response.ok) {
                    throw new Error(`Failed to load events: ${response.status}`);
                }

                const data = await response.json();
                allEvents = data.items || [];
                displayEvents(allEvents);
            } catch (error) {
                console.error('Error loading events:', error);
                eventsList.innerHTML = '<div class="no-events">Error loading events. Please try again.</div>';
            }
        }

        function getTimeUntil(dateString) {
            if (!dateString) return null;

            const eventTime = new Date(dateString);
            const now = new Date();
            const diff = eventTime - now;
            const diffAbs = Math.abs(diff);

            const minutes = Math.floor(diffAbs / 60000);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (diffAbs < 60000) {
                return { text: 'Happening now', class: 'happening' };
            } else if (diff > 0) {
                // Future event
                if (days > 0) {
                    return { text: `in ${days} day${days > 1 ? 's' : ''}`, class: '' };
                } else if (hours > 0) {
                    const remainingMins = minutes % 60;
                    return { text: `in ${hours}h ${remainingMins}m`, class: '' };
                } else {
                    return { text: `in ${minutes} minute${minutes !== 1 ? 's' : ''}`, class: '' };
                }
            } else {
                // Past event
                if (days > 0) {
                    return { text: `${days} day${days > 1 ? 's' : ''} ago`, class: 'past' };
                } else if (hours > 0) {
                    const remainingMins = minutes % 60;
                    return { text: `${hours}h ${remainingMins}m ago`, class: 'past' };
                } else {
                    return { text: `${minutes} minute${minutes !== 1 ? 's' : ''} ago`, class: 'past' };
                }
            }
        }

        function getEventStatus(startString, endString) {
            if (!startString || !endString) return null;

            const start = new Date(startString);
            const end = new Date(endString);
            const now = new Date();

            const diffStart = start - now;
            const diffEnd = end - now;
            const diffStartAbs = Math.abs(diffStart);
            const diffEndAbs = Math.abs(diffEnd);

            const minutesStart = Math.floor(diffStartAbs / 60000);
            const hoursStart = Math.floor(minutesStart / 60);
            const minutesEnd = Math.floor(diffEndAbs / 60000);
            const hoursEnd = Math.floor(minutesEnd / 60);

            const duration = Math.floor((end - start) / 60000);
            const durationHours = Math.floor(duration / 60);
            const durationMins = duration % 60;

            let durationText = '';
            if (durationHours > 0) {
                durationText = `${durationHours}h ${durationMins}m`;
            } else {
                durationText = `${durationMins}m`;
            }

            // Event is happening now
            if (now >= start && now <= end) {
                const remainingMins = minutesEnd;
                const remainingHours = hoursEnd;
                const elapsedMins = minutesStart;
                const elapsedHours = hoursStart;

                let statusText = 'Happening now';
                if (elapsedHours > 0) {
                    statusText += ` â€¢ Started ${elapsedHours}h ${elapsedMins % 60}m ago`;
                } else if (elapsedMins > 0) {
                    statusText += ` â€¢ Started ${elapsedMins}m ago`;
                }

                if (remainingHours > 0) {
                    statusText += ` â€¢ Ending in ${remainingHours}h ${remainingMins % 60}m`;
                } else if (remainingMins > 0) {
                    statusText += ` â€¢ Ending in ${remainingMins}m`;
                }

                statusText += ` â€¢ Duration: ${durationText}`;
                return statusText;
            }

            // Event ended
            if (now > end) {
                let endedText = '';
                if (hoursEnd > 0) {
                    endedText = `Ended ${hoursEnd}h ${minutesEnd % 60}m ago`;
                } else {
                    endedText = `Ended ${minutesEnd}m ago`;
                }
                return `${endedText} â€¢ Duration: ${durationText}`;
            }

            // Event is upcoming
            return `Duration: ${durationText}`;
        }

        function updateCountdowns() {
            const countdowns = document.querySelectorAll('.event-countdown[data-event-time]');
            countdowns.forEach(countdown => {
                const eventTime = countdown.dataset.eventTime;
                const eventEnd = countdown.dataset.eventEnd;

                if (eventTime) {
                    const timeInfo = getTimeUntil(eventTime);
                    if (timeInfo) {
                        countdown.textContent = timeInfo.text;
                        countdown.className = `event-countdown ${timeInfo.class}`;
                    }
                }

                // Update status line if it exists
                const statusLine = countdown.nextElementSibling;
                if (statusLine && eventEnd && statusLine.classList.contains('event-countdown')) {
                    const eventStatus = getEventStatus(eventTime, eventEnd);
                    if (eventStatus) {
                        statusLine.textContent = eventStatus;
                    }
                }
            });
        }

        async function fetchPastEmails(attendeeEmails) {
            if (!attendeeEmails || attendeeEmails.length === 0) return [];

            // Filter out the user's own email
            const otherAttendees = attendeeEmails.filter(email => email !== userEmail);
            if (otherAttendees.length === 0) return [];

            try {
                // Expand time range to last 6 months
                const sixMonthsAgo = new Date();
                sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
                const afterDate = sixMonthsAgo.toISOString().split('T')[0].replace(/-/g, '/');

                const queries = otherAttendees.map(email => `from:${email} OR to:${email}`).join(' OR ');
                const fullQuery = `(${queries}) after:${afterDate}`;

                const response = await fetch(
                    `https://www.googleapis.com/gmail/v1/users/me/messages?q=${encodeURIComponent(fullQuery)}&maxResults=50`,
                    {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    }
                );

                const data = await response.json();
                if (!data.messages) return [];

                // Fetch full email details - increased to 20
                const emailPromises = data.messages.slice(0, 20).map(async (msg) => {
                    const msgResponse = await fetch(
                        `https://www.googleapis.com/gmail/v1/users/me/messages/${msg.id}?format=full`,
                        {
                            headers: {
                                'Authorization': `Bearer ${accessToken}`
                            }
                        }
                    );
                    return msgResponse.json();
                });

                const emails = await Promise.all(emailPromises);
                return emails.map(email => {
                    const headers = email.payload.headers;
                    const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject';
                    const from = headers.find(h => h.name === 'From')?.value || '';
                    const date = headers.find(h => h.name === 'Date')?.value || '';

                    let body = '';
                    if (email.payload.body?.data) {
                        body = atob(email.payload.body.data.replace(/-/g, '+').replace(/_/g, '/'));
                    } else if (email.payload.parts) {
                        const textPart = email.payload.parts.find(p => p.mimeType === 'text/plain');
                        if (textPart?.body?.data) {
                            body = atob(textPart.body.data.replace(/-/g, '+').replace(/_/g, '/'));
                        }
                    }

                    return {
                        id: email.id,
                        subject,
                        from,
                        date,
                        snippet: email.snippet,
                        body: body.substring(0, 1000) // Limit body length
                    };
                });
            } catch (error) {
                console.error('Error fetching emails:', error);
                return [];
            }
        }

        async function fetchPastEvents(attendeeEmails) {
            if (!attendeeEmails || attendeeEmails.length === 0) return [];

            // Filter out the user's own email
            const otherAttendees = attendeeEmails.filter(email => email !== userEmail);
            if (otherAttendees.length === 0) return [];

            try {
                const now = new Date();
                const pastDate = new Date(now.getTime() - 180 * 24 * 60 * 60 * 1000); // 6 months (180 days) ago

                const response = await fetch(
                    `https://www.googleapis.com/calendar/v3/calendars/primary/events?` +
                    `timeMin=${pastDate.toISOString()}&` +
                    `timeMax=${now.toISOString()}&` +
                    `singleEvents=true&` +
                    `orderBy=startTime&` +
                    `maxResults=100`,
                    {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    }
                );

                const data = await response.json();
                if (!data.items) return [];

                // Filter events that have at least one matching attendee (excluding the user)
                const relevantEvents = data.items.filter(event => {
                    if (!event.attendees) return false;
                    return event.attendees.some(att =>
                        otherAttendees.includes(att.email)
                    );
                });

                return relevantEvents.slice(0, 15).map(event => ({
                    id: event.id,
                    summary: event.summary || 'Untitled Event',
                    start: event.start.dateTime || event.start.date,
                    end: event.end.dateTime || event.end.date,
                    description: event.description || '',
                    attendees: event.attendees || []
                }));
            } catch (error) {
                console.error('Error fetching past events:', error);
                return [];
            }
        }

        function toggleMeetingInfo(eventId) {
            const details = document.getElementById(`details-${eventId}`);
            const button = document.getElementById(`toggle-${eventId}`);

            if (details.classList.contains('visible')) {
                details.classList.remove('visible');
                button.textContent = 'Show Meeting Info';
            } else {
                details.classList.add('visible');
                button.textContent = 'Hide Meeting Info';
            }
        }

        function toggleContext(contextId) {
            const content = document.getElementById(contextId);
            content.classList.toggle('visible');
        }

        function toggleEmailBody(emailId) {
            const body = document.getElementById(emailId);
            body.classList.toggle('visible');
        }

        async function loadContextData(eventId, attendeeEmails) {
            const emailsContent = document.getElementById(`emails-content-${eventId}`);
            const eventsContent = document.getElementById(`events-content-${eventId}`);

            if (emailsContent.dataset.loaded === 'true') return;

            emailsContent.innerHTML = '<div class="loading-context">Loading past emails...</div>';
            eventsContent.innerHTML = '<div class="loading-context">Loading past events...</div>';

            // Load emails and events
            const [emails, events] = await Promise.all([
                fetchPastEmails(attendeeEmails),
                fetchPastEvents(attendeeEmails)
            ]);

            // Display emails
            if (emails.length > 0) {
                emailsContent.innerHTML = emails.map((email, idx) => `
                    <div class="email-item" onclick="toggleEmailBody('email-body-${eventId}-${idx}')">
                        <div class="email-subject">${email.subject}</div>
                        <div class="email-date">${email.from} â€¢ ${new Date(email.date).toLocaleDateString()}</div>
                        <div class="email-snippet">${email.snippet}</div>
                        <div class="email-body" id="email-body-${eventId}-${idx}">
                            <strong>Full Email:</strong><br>
                            ${email.body.replace(/\n/g, '<br>')}
                        </div>
                    </div>
                `).join('');
            } else {
                emailsContent.innerHTML = '<div class="loading-context">No past emails found</div>';
            }

            // Display events
            if (events.length > 0) {
                eventsContent.innerHTML = events.map(event => `
                    <div class="event-item">
                        <div class="event-past-title">${event.summary}</div>
                        <div class="event-past-date">${new Date(event.start).toLocaleString()}</div>
                        ${event.description ? `<div class="email-snippet">${event.description.substring(0, 100)}...</div>` : ''}
                    </div>
                `).join('');
            } else {
                eventsContent.innerHTML = '<div class="loading-context">No past events found</div>';
            }

            emailsContent.dataset.loaded = 'true';
        }

        function displayEvents(events) {
            const eventsList = document.getElementById('eventsList');

            if (countdownInterval) {
                clearInterval(countdownInterval);
            }

            if (events.length === 0) {
                eventsList.innerHTML = '<div class="no-events">No events scheduled for this day</div>';
                return;
            }

            eventsList.innerHTML = events.map((event, index) => {
                const start = event.start.dateTime || event.start.date;
                const end = event.end.dateTime || event.end.date;
                const isAllDay = !event.start.dateTime;

                let timeString;
                if (isAllDay) {
                    timeString = 'All day';
                } else {
                    timeString = `${formatTime(start)} - ${formatTime(end)}`;
                }

                const eventId = `event-${index}`;
                const timeInfo = !isAllDay && start ? getTimeUntil(start) : null;
                const eventStatus = !isAllDay && start && end ? getEventStatus(start, end) : null;

                // Prepare meeting details
                const attendees = event.attendees || [];
                const attendeeEmails = attendees.map(att => att.email).filter(Boolean);
                const location = event.location || '';
                const hangoutLink = event.hangoutLink || '';
                const description = event.description || '';
                const timezone = event.start.timeZone || 'Local time';

                return `
                    <div class="event" onclick="showMeetingDetail(${index})">
                        <div class="event-time">${timeString}</div>
                        <div class="event-title">${event.summary || 'Untitled Event'}</div>
                        ${timeInfo ? `<div class="event-countdown ${timeInfo.class}" data-event-time="${start}" data-event-end="${end}">${timeInfo.text}</div>` : ''}
                        ${eventStatus ? `<div class="event-countdown" style="margin-top: 4px;">${eventStatus}</div>` : ''}
                        <div style="margin-top: 10px; color: var(--color-accent); font-size: 13px; font-weight: 500;">Click for details â†’</div>
                    </div>
                `;
            }).join('');

            // Update countdowns every minute
            countdownInterval = setInterval(updateCountdowns, 60000);
        }

        // View Navigation Functions
        function showMeetingDetail(index) {
            // Clear cached state from previous meeting to prevent data leakage
            currentEmails = [];
            currentAttachments = [];
            currentFiles = [];

            // CRITICAL: Clear prep data to prevent cross-meeting contamination
            meetingBrief = null;
            currentMeetingId = null;
            interactiveBrief = null;

            // Close and clear prep modal if open
            const prepModal = document.getElementById('prepModal');
            prepModal.classList.remove('visible');
            document.getElementById('prepModalBody').innerHTML = '';

            // Hide "Enter Meeting" button until new prep is generated
            const enterMeetingBtn = document.getElementById('enterMeetingButton');
            if (enterMeetingBtn) {
                enterMeetingBtn.style.display = 'none';
            }

            currentMeeting = allEvents[index];
            document.getElementById('eventsContainer').classList.remove('visible');
            document.getElementById('meetingDetailContainer').classList.add('visible');

            loadMeetingDetails();
        }

        function showCalendarView() {
            // Clear all meeting-specific cached state
            currentEmails = [];
            currentAttachments = [];
            currentFiles = [];
            meetingBrief = null;
            currentMeetingId = null;
            interactiveBrief = null;

            document.getElementById('eventsContainer').classList.add('visible');
            document.getElementById('meetingDetailContainer').classList.remove('visible');
            currentMeeting = null;
        }

        // Tab Switching
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');

            // Load data for specific tabs
            if (tabName === 'emails') {
                loadEmailsTab();
            } else if (tabName === 'attachments') {
                loadAttachmentsTab();
            } else if (tabName === 'files') {
                loadFilesTab();
            }
        }

        // Load Meeting Detail Data
        async function loadMeetingDetails() {
            const meeting = currentMeeting;
            const start = meeting.start.dateTime || meeting.start.date;
            const end = meeting.end.dateTime || meeting.end.date;
            const isAllDay = !meeting.start.dateTime;

            // Set header
            document.getElementById('detailTitle').textContent = meeting.summary || 'Untitled Event';

            let timeString;
            if (isAllDay) {
                timeString = 'All day';
            } else {
                timeString = `${formatTime(start)} - ${formatTime(end)}`;
            }
            document.getElementById('detailTime').textContent = timeString;

            const eventStatus = !isAllDay && start && end ? getEventStatus(start, end) : '';
            document.getElementById('detailStatus').textContent = eventStatus;

            // Load Overview Tab
            loadOverviewTab();

            // Load Attendees Tab
            loadAttendeesTab();
        }

        function loadOverviewTab() {
            const meeting = currentMeeting;
            const start = meeting.start.dateTime || meeting.start.date;
            const end = meeting.end.dateTime || meeting.end.date;
            const isAllDay = !meeting.start.dateTime;

            let timeString;
            if (isAllDay) {
                timeString = 'All day';
            } else {
                timeString = `${formatTime(start)} - ${formatTime(end)}`;
            }

            const timezone = meeting.start.timeZone || 'Local time';
            const location = meeting.location || 'No location specified';
            const hangoutLink = meeting.hangoutLink || '';
            const description = meeting.description || 'No description';
            const attendees = meeting.attendees || [];

            let overviewHTML = `
                <div class="overview-card">
                    <div class="overview-card-title">Time</div>
                    <div class="overview-card-content">${timeString}${!isAllDay ? ` (${timezone})` : ''}</div>
                </div>
                <div class="overview-card">
                    <div class="overview-card-title">Location</div>
                    <div class="overview-card-content">${location}</div>
                </div>
                <div class="overview-card">
                    <div class="overview-card-title">Attendees</div>
                    <div class="overview-card-content">${attendees.length} participant${attendees.length !== 1 ? 's' : ''}</div>
                </div>
            `;

            if (hangoutLink) {
                overviewHTML += `
                    <div class="overview-card">
                        <div class="overview-card-title">Meeting Link</div>
                        <div class="overview-card-content"><a href="${hangoutLink}" target="_blank">Join Meeting</a></div>
                    </div>
                `;
            }

            overviewHTML += `
                <div class="overview-card" style="grid-column: 1 / -1;">
                    <div class="overview-card-title">Description</div>
                    <div class="overview-card-content">${description.replace(/\n/g, '<br>')}</div>
                </div>
            `;

            document.getElementById('overviewGrid').innerHTML = overviewHTML;
        }

        function loadAttendeesTab() {
            const attendees = currentMeeting.attendees || [];

            if (attendees.length === 0) {
                document.getElementById('attendeesList').innerHTML = '<div class="loading-context">No attendees</div>';
                return;
            }

            let html = '<div class="overview-grid">';
            attendees.forEach(att => {
                html += `
                    <div class="overview-card">
                        <div class="overview-card-title">${att.displayName || att.email}</div>
                        <div class="overview-card-content">
                            ${att.email}<br>
                            ${att.organizer ? '<strong>Organizer</strong>' : ''}
                            ${att.responseStatus ? `Status: ${att.responseStatus}` : ''}
                        </div>
                    </div>
                `;
            });
            html += '</div>';

            document.getElementById('attendeesList').innerHTML = html;
        }

        async function loadEmailsTab() {
            const attendees = currentMeeting.attendees || [];
            const attendeeEmails = attendees.map(att => att.email).filter(Boolean);

            // Setup filters
            setupAttendeeFilters('email', attendeeEmails);

            // Load emails
            document.getElementById('emailsList').innerHTML = '<div class="loading-context">Loading emails...</div>';

            currentEmails = await fetchPastEmails(attendeeEmails);
            displayFilteredEmails();
        }

        async function loadAttachmentsTab() {
            const attendees = currentMeeting.attendees || [];
            const attendeeEmails = attendees.map(att => att.email).filter(Boolean);

            // Setup filters
            setupAttendeeFilters('attachment', attendeeEmails);

            // Load attachments
            document.getElementById('attachmentsList').innerHTML = '<div class="loading-context">Loading attachments...</div>';

            currentAttachments = await fetchAttachments(attendeeEmails);
            displayFilteredAttachments();
        }

        function setupAttendeeFilters(type, attendeeEmails) {
            const otherAttendees = attendeeEmails.filter(email => email !== userEmail);
            let containerId, filterFunctionName;

            if (type === 'email') {
                containerId = 'emailAttendeeCheckboxes';
                filterFunctionName = 'Emails';
            } else if (type === 'attachment') {
                containerId = 'attachmentAttendeeCheckboxes';
                filterFunctionName = 'Attachments';
            } else if (type === 'files') {
                containerId = 'filesAttendeeCheckboxes';
                filterFunctionName = 'Files';
            }

            let html = '';
            otherAttendees.forEach((email, idx) => {
                html += `
                    <div class="attendee-checkbox">
                        <input type="checkbox" id="${type}-filter-${idx}" value="${email}" checked onchange="filter${filterFunctionName}()">
                        <label for="${type}-filter-${idx}">${email}</label>
                    </div>
                `;
            });

            document.getElementById(containerId).innerHTML = html;
        }

        function toggleAllEmailFilters() {
            const checkboxes = document.querySelectorAll('#emailAttendeeCheckboxes input[type="checkbox"]');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);

            checkboxes.forEach(cb => cb.checked = !allChecked);
            filterEmails();
        }

        function toggleAllAttachmentFilters() {
            const checkboxes = document.querySelectorAll('#attachmentAttendeeCheckboxes input[type="checkbox"]');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);

            checkboxes.forEach(cb => cb.checked = !allChecked);
            filterAttachments();
        }

        function filterEmails() {
            displayFilteredEmails();
        }

        function filterAttachments() {
            displayFilteredAttachments();
        }

        function displayFilteredEmails() {
            const checkboxes = document.querySelectorAll('#emailAttendeeCheckboxes input[type="checkbox"]:checked');
            const selectedEmails = Array.from(checkboxes).map(cb => cb.value);

            const filtered = currentEmails.filter(email => {
                return selectedEmails.some(selectedEmail =>
                    email.from.includes(selectedEmail)
                );
            });

            const emailsList = document.getElementById('emailsList');

            if (filtered.length === 0) {
                emailsList.innerHTML = '<div class="loading-context">No emails found for selected attendees</div>';
                return;
            }

            emailsList.innerHTML = filtered.map((email, idx) => `
                <div class="email-item" onclick="toggleEmailBody('detail-email-${idx}')">
                    <div class="email-subject">${email.subject}</div>
                    <div class="email-date">${email.from} â€¢ ${new Date(email.date).toLocaleDateString()}</div>
                    <div class="email-snippet">${email.snippet}</div>
                    <div class="email-body" id="detail-email-${idx}">
                        <strong>Full Email:</strong><br>
                        ${email.body.replace(/\n/g, '<br>')}
                    </div>
                </div>
            `).join('');
        }

        function displayFilteredAttachments() {
            const checkboxes = document.querySelectorAll('#attachmentAttendeeCheckboxes input[type="checkbox"]:checked');
            const selectedEmails = Array.from(checkboxes).map(cb => cb.value);

            const filtered = currentAttachments.filter(att => {
                return selectedEmails.some(selectedEmail =>
                    att.from.includes(selectedEmail)
                );
            });

            const attachmentsList = document.getElementById('attachmentsList');

            if (filtered.length === 0) {
                attachmentsList.innerHTML = '<div class="loading-context">No attachments found for selected attendees</div>';
                return;
            }

            attachmentsList.innerHTML = filtered.map(att => {
                const ext = att.filename.split('.').pop().toUpperCase();
                return `
                    <div class="attachment-item">
                        <div class="attachment-icon">${ext}</div>
                        <div class="attachment-info">
                            <div class="attachment-name">${att.filename}</div>
                            <div class="attachment-meta">From: ${att.from} â€¢ ${att.date} â€¢ ${formatBytes(att.size)}</div>
                        </div>
                        <a href="${att.url}" class="attachment-link" target="_blank">View</a>
                    </div>
                `;
            }).join('');
        }

        async function fetchAttachments(attendeeEmails) {
            const otherAttendees = attendeeEmails.filter(email => email !== userEmail);
            if (otherAttendees.length === 0) return [];

            try {
                // Expand time range to last 6 months
                const sixMonthsAgo = new Date();
                sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
                const afterDate = sixMonthsAgo.toISOString().split('T')[0].replace(/-/g, '/');

                const queries = otherAttendees.map(email => `from:${email} OR to:${email} has:attachment`).join(' OR ');
                const fullQuery = `(${queries}) after:${afterDate}`;

                const response = await fetch(
                    `https://www.googleapis.com/gmail/v1/users/me/messages?q=${encodeURIComponent(fullQuery)}&maxResults=50`,
                    {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    }
                );

                const data = await response.json();
                if (!data.messages) return [];

                // Fetch messages with attachments - increased to 25
                const messagePromises = data.messages.slice(0, 25).map(async (msg) => {
                    try {
                        const msgResponse = await fetch(
                            `https://www.googleapis.com/gmail/v1/users/me/messages/${msg.id}`,
                            {
                                headers: {
                                    'Authorization': `Bearer ${accessToken}`
                                }
                            }
                        );
                        if (!msgResponse.ok) {
                            console.warn(`Failed to fetch message ${msg.id}: ${msgResponse.status}`);
                            return null;
                        }
                        return msgResponse.json();
                    } catch (error) {
                        console.warn(`Error fetching message ${msg.id}:`, error);
                        return null;
                    }
                });

                const messages = await Promise.all(messagePromises);
                const attachments = [];

                messages.forEach(message => {
                    // Skip if message is undefined or invalid (due to rate limiting or errors)
                    if (!message || !message.payload || !message.payload.headers) {
                        return;
                    }

                    const headers = message.payload.headers;
                    const from = headers.find(h => h.name === 'From')?.value || '';
                    const date = headers.find(h => h.name === 'Date')?.value || '';

                    // Recursive function to find attachments in nested parts
                    function extractAttachments(parts) {
                        if (!parts) return;
                        parts.forEach(part => {
                            if (part.filename && part.body && (part.body.attachmentId || part.body.size > 0)) {
                                attachments.push({
                                    filename: part.filename,
                                    mimeType: part.mimeType,
                                    size: part.body.size || 0,
                                    attachmentId: part.body.attachmentId,
                                    messageId: message.id,
                                    from,
                                    date: new Date(date).toLocaleDateString(),
                                    url: `https://mail.google.com/mail/u/0/#inbox/${message.id}`
                                });
                            }
                            // Recursively check nested parts
                            if (part.parts) {
                                extractAttachments(part.parts);
                            }
                        });
                    }

                    extractAttachments(message.payload.parts);
                });

                return attachments;
            } catch (error) {
                console.error('Error fetching attachments:', error);
                return [];
            }
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        async function loadFilesTab() {
            const attendees = currentMeeting.attendees || [];
            const attendeeEmails = attendees.map(att => att.email).filter(Boolean);

            // Setup filters
            setupAttendeeFilters('files', attendeeEmails);

            // Load files
            document.getElementById('filesList').innerHTML = '<div class="loading-context">Loading Drive files...</div>';

            currentFiles = await fetchDriveFiles(attendeeEmails);
            displayFilteredFiles();
        }

        async function fetchDriveFiles(attendeeEmails) {
            const otherAttendees = attendeeEmails.filter(email => email !== userEmail);
            if (otherAttendees.length === 0) return [];

            try {
                // Expand time range to last 6 months
                const sixMonthsAgo = new Date();
                sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

                // Build query to find files shared with or by any of the attendees
                // Using correct Drive API query syntax
                const queries = otherAttendees.map(email => `'${email}' in readers or '${email}' in writers`).join(' or ');

                const response = await fetch(
                    `https://www.googleapis.com/drive/v3/files?` +
                    `q=${encodeURIComponent(`(${queries}) and modifiedTime > '${sixMonthsAgo.toISOString()}'`)}&` +
                    `fields=files(id,name,mimeType,modifiedTime,owners,size,webViewLink,iconLink)&` +
                    `orderBy=modifiedTime desc&` +
                    `pageSize=50`,
                    {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    }
                );

                const data = await response.json();
                if (!data.files) return [];

                return data.files.map(file => ({
                    id: file.id,
                    name: file.name,
                    mimeType: file.mimeType,
                    size: file.size || 0,
                    modifiedTime: file.modifiedTime,
                    owner: file.owners && file.owners.length > 0 ? file.owners[0].displayName || file.owners[0].emailAddress : 'Unknown',
                    ownerEmail: file.owners && file.owners.length > 0 ? file.owners[0].emailAddress : '',
                    url: file.webViewLink,
                    iconLink: file.iconLink
                }));
            } catch (error) {
                console.error('Error fetching Drive files:', error);
                return [];
            }
        }

        function toggleAllFilesFilters() {
            const checkboxes = document.querySelectorAll('#filesAttendeeCheckboxes input[type="checkbox"]');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);

            checkboxes.forEach(cb => cb.checked = !allChecked);
            filterFiles();
        }

        function filterFiles() {
            displayFilteredFiles();
        }

        function displayFilteredFiles() {
            const checkboxes = document.querySelectorAll('#filesAttendeeCheckboxes input[type="checkbox"]:checked');
            const selectedEmails = Array.from(checkboxes).map(cb => cb.value);

            const filtered = currentFiles.filter(file => {
                return selectedEmails.some(selectedEmail =>
                    file.ownerEmail === selectedEmail
                );
            });

            const filesList = document.getElementById('filesList');

            if (filtered.length === 0) {
                filesList.innerHTML = '<div class="loading-context">No Drive files found for selected attendees</div>';
                return;
            }

            filesList.innerHTML = filtered.map(file => {
                const fileType = getFileType(file.mimeType, file.name);
                const modifiedDate = new Date(file.modifiedTime).toLocaleDateString();

                return `
                    <div class="attachment-item">
                        <div class="attachment-icon">${fileType}</div>
                        <div class="attachment-info">
                            <div class="attachment-name">${file.name}</div>
                            <div class="attachment-meta">
                                Owner: ${file.owner} â€¢ Modified: ${modifiedDate}
                                ${file.size ? ` â€¢ ${formatBytes(parseInt(file.size))}` : ''}
                            </div>
                        </div>
                        <a href="${file.url}" class="attachment-link" target="_blank">Open</a>
                    </div>
                `;
            }).join('');
        }

        function getFileType(mimeType, filename) {
            // Check for Google Workspace types
            if (mimeType.includes('spreadsheet')) return 'SHEET';
            if (mimeType.includes('document')) return 'DOC';
            if (mimeType.includes('presentation')) return 'SLIDE';
            if (mimeType.includes('folder')) return 'FLDR';
            if (mimeType.includes('form')) return 'FORM';

            // Check by file extension
            if (filename) {
                const ext = filename.split('.').pop().toUpperCase();
                if (ext && ext.length <= 4) return ext;
            }

            // Check by MIME type
            if (mimeType.includes('pdf')) return 'PDF';
            if (mimeType.includes('image')) return 'IMG';
            if (mimeType.includes('video')) return 'VID';
            if (mimeType.includes('audio')) return 'AUD';
            if (mimeType.includes('zip') || mimeType.includes('compressed')) return 'ZIP';
            if (mimeType.includes('text')) return 'TXT';

            return 'FILE';
        }

        async function fetchDriveFileContents(files) {
            const filesWithContent = [];
            const MAX_CONTENT_PER_FILE = 20000; // 20k chars per file - reasonable for analysis

            for (const file of files) {
                try {
                    let content = '';
                    let fetchUrl = '';
                    let mimeType = '';

                    // Handle Google Docs
                    if (file.mimeType.includes('document')) {
                        fetchUrl = `https://www.googleapis.com/drive/v3/files/${file.id}/export?mimeType=text/plain`;
                        mimeType = 'text/plain';
                    }
                    // Handle Google Sheets
                    else if (file.mimeType.includes('spreadsheet')) {
                        fetchUrl = `https://www.googleapis.com/drive/v3/files/${file.id}/export?mimeType=text/csv`;
                        mimeType = 'text/csv';
                    }
                    // Handle Google Slides
                    else if (file.mimeType.includes('presentation')) {
                        fetchUrl = `https://www.googleapis.com/drive/v3/files/${file.id}/export?mimeType=text/plain`;
                        mimeType = 'text/plain';
                    }
                    // Handle PDFs
                    else if (file.mimeType.includes('pdf')) {
                        fetchUrl = `https://www.googleapis.com/drive/v3/files/${file.id}/export?mimeType=text/plain`;
                        mimeType = 'text/plain';
                    }
                    // Handle plain text files
                    else if (file.mimeType.includes('text/plain') || file.mimeType.includes('text/')) {
                        fetchUrl = `https://www.googleapis.com/drive/v3/files/${file.id}?alt=media`;
                        mimeType = 'text/plain';
                    }

                    if (fetchUrl) {
                        console.log(`Fetching content for: ${file.name}`);
                        const response = await fetch(fetchUrl, {
                            headers: {
                                'Authorization': `Bearer ${accessToken}`
                            }
                        });

                        if (response.ok) {
                            content = await response.text();
                            // Limit but keep substantial content
                            if (content.length > MAX_CONTENT_PER_FILE) {
                                content = content.substring(0, MAX_CONTENT_PER_FILE) + '\n\n[Content truncated due to length - showing first 80k chars]';
                            }
                            console.log(`âœ“ Fetched ${content.length} chars for: ${file.name}`);
                        } else {
                            console.warn(`Failed to fetch ${file.name}: ${response.status} ${response.statusText}`);
                        }
                    }

                    filesWithContent.push({
                        ...file,
                        content: content,
                        hasContent: content.length > 0
                    });

                } catch (error) {
                    console.warn(`Error fetching content for file ${file.name}:`, error);
                    filesWithContent.push({
                        ...file,
                        content: '',
                        hasContent: false
                    });
                }

                // Small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 150));
            }

            return filesWithContent;
        }

        // ===== PARALLEL AI WEB RESEARCH FUNCTIONS =====

        // Use GPT to craft optimized search queries
        async function craftSearchQueries(context) {
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [{
                            role: 'system',
                            content: 'You are a search query optimization expert. Generate EXACTLY 3 highly specific, effective web search queries that will find the most relevant and recent information. Return ONLY a JSON array of 3 query strings, no other text. Example: ["query 1", "query 2", "query 3"]'
                        }, {
                            role: 'user',
                            content: context
                        }],
                        temperature: 0.7,
                        max_tokens: 200
                    })
                });

                const data = await response.json();
                const queriesText = data.choices[0].message.content.trim();

                // Parse JSON array from GPT response
                try {
                    let queries = JSON.parse(queriesText);
                    if (Array.isArray(queries)) {
                        // Limit to maximum 5 queries (Parallel AI limit)
                        return queries.slice(0, 5);
                    }
                    return [];
                } catch {
                    // Fallback: split by newlines if not valid JSON
                    const queries = queriesText.split('\n')
                        .filter(q => q.trim().length > 0)
                        .map(q => q.replace(/^[-â€¢*"'\d.)\]]\s*/, '').replace(/["']$/, '').trim())
                        .filter(q => q.length > 5);
                    return queries.slice(0, 5);
                }
            } catch (error) {
                console.error('Error crafting search queries:', error);
                return [];
            }
        }

        async function searchAttendee(attendee) {
            const name = attendee.displayName || attendee.email.split('@')[0];
            const domain = attendee.email.split('@')[1];
            const company = domain.split('.')[0];

            try {
                // Simple, effective search queries (max 5 per Parallel AI limit)
                const queries = [
                    `${name} ${company} LinkedIn profile`,
                    `${name} ${company} role position`,
                    `${name} ${company} news ${new Date().getFullYear()}`
                ];

                const response = await fetch('/api/parallel-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        objective: `Find comprehensive professional information about ${name} from ${company}: background, current role, recent activities, achievements, and public presence`,
                        search_queries: queries,
                        mode: 'one-shot',
                        max_results: 8,
                        max_chars_per_result: 3000
                    })
                });

                if (!response.ok) {
                    console.warn(`Parallel AI search failed for ${name}: ${response.status}`);
                    return { attendee, results: [] };
                }

                const data = await response.json();
                console.log(`âœ“ Web research for ${name}: ${data.results?.length || 0} results`);
                return { attendee, results: data.results || [] };
            } catch (error) {
                console.error(`Error researching ${name}:`, error);
                return { attendee, results: [] };
            }
        }

        async function searchCompany(companyDomain) {
            const companyName = companyDomain.split('.')[0];

            try {
                // Simple, effective search queries (max 5 per Parallel AI limit)
                const queries = [
                    `${companyName} company overview ${new Date().getFullYear()}`,
                    `${companyName} news announcements ${new Date().getFullYear()}`,
                    `${companyName} products services`
                ];

                const response = await fetch('/api/parallel-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        objective: `Find comprehensive company information for ${companyName}: business overview, recent news, products, funding, market position, and key developments`,
                        search_queries: queries,
                        mode: 'one-shot',
                        max_results: 8,
                        max_chars_per_result: 3000
                    })
                });

                if (!response.ok) {
                    console.warn(`Parallel AI search failed for ${companyName}: ${response.status}`);
                    return { company: companyName, results: [] };
                }

                const data = await response.json();
                console.log(`âœ“ Web research for ${companyName}: ${data.results?.length || 0} results`);
                return { company: companyName, results: data.results || [] };
            } catch (error) {
                console.error(`Error researching ${companyName}:`, error);
                return { company: companyName, results: [] };
            }
        }

        async function searchMeetingContext(meeting) {
            const title = meeting.summary || 'Meeting';
            const description = meeting.description || '';

            try {
                // Simple, effective search queries (max 5 per Parallel AI limit)
                const queries = [
                    `${title} ${new Date().getFullYear()}`,
                    `${title} trends news`,
                    `${title} insights`
                ].filter(q => q.length > 10); // Only valid queries

                const response = await fetch('/api/parallel-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        objective: `Find comprehensive contextual information for meeting topic "${title}": recent developments, industry trends, relevant news, and strategic insights`,
                        search_queries: queries,
                        mode: 'one-shot',
                        max_results: 8,
                        max_chars_per_result: 3000
                    })
                });

                if (!response.ok) {
                    console.warn(`Parallel AI search failed for meeting context: ${response.status}`);
                    return { results: [] };
                }

                const data = await response.json();
                console.log(`âœ“ Web research for meeting context: ${data.results?.length || 0} results`);
                return { results: data.results || [] };
            } catch (error) {
                console.error('Error researching meeting context:', error);
                return { results: [] };
            }
        }

        function extractCompaniesFromAttendees(attendees) {
            const domains = attendees.map(att => att.email.split('@')[1]).filter(Boolean);
            return [...new Set(domains)];
        }

        // ===== SPECIALIZED GPT ANALYSIS FUNCTIONS =====

        async function analyzeEmailsWithGPT(emails) {
            if (!emails || emails.length === 0) return null;

            try {
                const emailContext = emails.slice(0, 10).map((email, idx) => `
Email ${idx + 1}: ${email.subject}
From: ${email.from}
Date: ${email.date}
Content: ${email.body || email.snippet}
---`).join('\n\n');

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [{
                            role: 'system',
                            content: 'Analyze email threads and extract: key themes, pending issues, relationship dynamics, important quotes, and sentiment patterns. Be specific and cite emails.'
                        }, {
                            role: 'user',
                            content: `Analyze these email threads:\n\n${emailContext}`
                        }],
                        temperature: 0.7,
                        max_tokens: 2000
                    })
                });

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('Error analyzing emails:', error);
                return null;
            }
        }

        async function analyzeDocumentsWithGPT(files) {
            if (!files || files.length === 0) return null;

            try {
                const docContext = files.filter(f => f.hasContent).slice(0, 5).map(file => `
Document: ${file.name}
Owner: ${file.owner}
Content: ${file.content.substring(0, 15000)}
---`).join('\n\n');

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [{
                            role: 'system',
                            content: 'Deeply analyze documents and extract: key insights, decisions made, action items, data points, concerns raised, and proposals. Be specific and quote relevant sections.'
                        }, {
                            role: 'user',
                            content: `Analyze these documents:\n\n${docContext}`
                        }],
                        temperature: 0.7,
                        max_tokens: 2500
                    })
                });

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('Error analyzing documents:', error);
                return null;
            }
        }

        async function analyzeAttendeeDynamicsWithGPT(attendees, emails, webResearch) {
            try {
                const attendeeList = attendees.map(att =>
                    `${att.displayName || att.email} (${att.email})${att.organizer ? ' [ORGANIZER]' : ''}`
                ).join('\n');

                const webInsights = webResearch.map(wr => `
${wr.attendee.displayName || wr.attendee.email}:
${wr.results?.map(r => `- ${(r.excerpts?.join(' ') || 'No content').substring(0, 300)}`).join('\n') || 'No web research available'}
`).join('\n');

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [{
                            role: 'system',
                            content: 'Analyze attendee relationships, power dynamics, likely positions, and strategic insights. Identify decision makers, influencers, and potential allies/concerns.'
                        }, {
                            role: 'user',
                            content: `Attendees:\n${attendeeList}\n\nWeb Research:\n${webInsights}\n\nEmail history: ${emails.length} emails available\n\nAnalyze the dynamics.`
                        }],
                        temperature: 0.7,
                        max_tokens: 2000
                    })
                });

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('Error analyzing dynamics:', error);
                return null;
            }
        }

        async function generateStrategyWithGPT(meeting, allContext) {
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [{
                            role: 'system',
                            content: 'Generate strategic recommendations including: key talking points, questions to ask, positions to take, risks to mitigate, and opportunities to seize. Be specific and actionable.'
                        }, {
                            role: 'user',
                            content: `Meeting: ${meeting.summary}\n\nBased on all available context (emails, documents, web research), provide strategic recommendations for this meeting.`
                        }],
                        temperature: 0.7,
                        max_tokens: 2000
                    })
                });

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('Error generating strategy:', error);
                return null;
            }
        }

        async function synthesizeWebIntelligenceWithGPT(webResearch, companyResearch, meetingContext) {
            try {
                const attendeeIntel = webResearch.map(wr => `
${wr.attendee.displayName || wr.attendee.email}:
${wr.results?.map(r => `- ${r.title || 'Result'}: ${(r.excerpts?.join(' ') || 'No content').substring(0, 400)} [${r.url || ''}]`).join('\n') || 'No results'}
`).join('\n\n');

                const companyIntel = companyResearch.map(cr => `
${cr.company}:
${cr.results?.map(r => `- ${r.title || 'Result'}: ${(r.excerpts?.join(' ') || 'No content').substring(0, 400)} [${r.url || ''}]`).join('\n') || 'No results'}
`).join('\n\n');

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [{
                            role: 'system',
                            content: 'Synthesize web research into actionable intelligence: attendee backgrounds, company news, industry context, and strategic implications. Include source citations.'
                        }, {
                            role: 'user',
                            content: `Attendee Research:\n${attendeeIntel}\n\nCompany Research:\n${companyIntel}\n\nMeeting Context: ${meetingContext.results?.length || 0} results\n\nSynthesize this intelligence.`
                        }],
                        temperature: 0.7,
                        max_tokens: 3000
                    })
                });

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('Error synthesizing web intelligence:', error);
                return null;
            }
        }

        async function prepareForMeeting() {
            // CRITICAL: Prevent concurrent prep requests
            if (prepRequestInProgress) {
                console.log('Prep request already in progress');
                return;
            }
            prepRequestInProgress = true;

            const button = document.getElementById('prepMeButton');
            button.disabled = true;
            button.textContent = 'Preparing...';

            // Open modal with loading state - use skeleton loaders
            const modal = document.getElementById('prepModal');
            const modalBody = document.getElementById('prepModalBody');
            modalBody.innerHTML = `
                <div class="prep-loading">
                    <div class="prep-spinner"></div>
                    <div id="loadingMessage" style="margin-bottom: 20px; font-weight: 500;">Generating your meeting brief...</div>
                    <div style="max-width: 600px; margin: 0 auto;">
                        <div class="skeleton-title"></div>
                        <div class="skeleton-text"></div>
                        <div class="skeleton-text" style="width: 80%;"></div>
                        <div class="skeleton-card" style="margin-top: 20px;"></div>
                        <div class="skeleton-card"></div>
                    </div>
                    <p style="color: var(--color-text-secondary); font-size: 13px; margin-top: 20px;">This may take 15-20 seconds</p>
                </div>
            `;
            modal.classList.add('visible');

            try {
                const meeting = currentMeeting;
                const attendees = meeting.attendees || [];

                // Clear cached data to prevent cross-meeting contamination
                currentEmails = [];
                currentFiles = [];

                // Call backend to generate brief (server now fetches emails/files from ALL connected accounts)
                const response = await fetch('/api/prep-meeting', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include', // Include session cookie
                    body: JSON.stringify({
                        meeting,
                        attendees
                        // No accessToken needed - session-based auth automatically fetches from ALL accounts
                    })
                });

                if (!response.ok) {
                    // Try to parse error response body
                    let errorMessage = `Server error: ${response.status}`;
                    let errorDetails = null;
                    
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.message || errorMessage;
                        errorDetails = errorData;
                        
                        // Check for revoked token error
                        if (response.status === 401 && (errorData.error === 'TokenRevoked' || errorData.revoked === true)) {
                            // Clear session and redirect to sign-in
                            document.cookie = 'session=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
                            alert('Your session has expired. Please sign in again.');
                            window.location.href = '/';
                            return;
                        }
                        
                        // Log full error details to console for debugging
                        console.error('Server error response:', {
                            status: response.status,
                            statusText: response.statusText,
                            error: errorData
                        });
                    } catch (parseError) {
                        // If response isn't JSON, try to get text
                        try {
                            const errorText = await response.text();
                            console.error('Server error (non-JSON):', errorText);
                            errorMessage = errorText || errorMessage;
                        } catch (textError) {
                            console.error('Failed to parse error response:', textError);
                        }
                    }
                    
                    const error = new Error(errorMessage);
                    error.status = response.status;
                    error.details = errorDetails;
                    throw error;
                }

                const brief = await response.json();

                // Store brief globally for meeting assistant
                meetingBrief = brief;
                currentMeetingId = meeting.id;

                // Add metadata for validation
                meetingBrief._meetingId = meeting.id;
                meetingBrief._generatedAt = Date.now();

                // Render the clean brief
                renderModernBrief(brief, meeting);

                // Show "Entering Meeting" button
                const enterMeetingBtn = document.getElementById('enterMeetingButton');
                if (enterMeetingBtn) {
                    enterMeetingBtn.style.display = 'inline-block';
                }

            } catch (error) {
                console.error('Error preparing meeting brief:', error);
                
                // Build detailed error message for display
                let errorDisplay = error.message || 'An error occurred while preparing your meeting brief';
                
                if (error.details) {
                    // Add field-level details if available
                    if (error.details.field) {
                        errorDisplay += `\n\nField: ${error.details.field}`;
                    }
                    if (error.details.expected) {
                        errorDisplay += `\nExpected: ${error.details.expected}`;
                    }
                    if (error.details.received !== undefined) {
                        const receivedStr = typeof error.details.received === 'object' 
                            ? JSON.stringify(error.details.received).substring(0, 100)
                            : String(error.details.received).substring(0, 100);
                        errorDisplay += `\nReceived: ${receivedStr}`;
                    }
                    if (error.details.requestId) {
                        errorDisplay += `\n\nRequest ID: ${error.details.requestId}`;
                    }
                }
                
                modalBody.innerHTML = `
                    <div class="prep-content">
                        <p style="color: #d32f2f;">Failed to generate meeting brief. Please try again.</p>
                        <p style="color: #666; font-size: 13px; margin-top: 10px;">Error: ${error.message}</p>
                    </div>
                `;
            } finally {
                button.disabled = false;
                button.textContent = 'Prep Me';
                prepRequestInProgress = false;
            }
        }

        // ===== MODERN BRIEF RENDERING =====

        function renderModernBrief(brief, meeting) {
            const modalBody = document.getElementById('prepModalBody');

            const getInitials = (name) => {
                return name.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);
            };

            // Create tabbed interface with comprehensive sections
            modalBody.innerHTML = `
                <div class="modern-brief">
                    <!-- Hero Card -->
                    <div class="brief-hero-card">
                        <h2>${meeting.summary}</h2>
                        <div class="meeting-time">${formatMeetingTime(meeting)}</div>
                        ${brief.summary ? `<p class="executive-summary">${brief.summary}</p>` : ''}
                    </div>

                    <!-- Tab Navigation -->
                    <div class="brief-tabs">
                        <button class="brief-tab-button active" onclick="switchBriefTab('attendees')">Attendees</button>
                        <button class="brief-tab-button" onclick="switchBriefTab('relationships')">Relationships</button>
                        <button class="brief-tab-button" onclick="switchBriefTab('timeline')">Timeline</button>
                        <button class="brief-tab-button" onclick="switchBriefTab('emails')">Email Analysis</button>
                        <button class="brief-tab-button" onclick="switchBriefTab('documents')">Documents</button>
                        <button class="brief-tab-button" onclick="switchBriefTab('company')">Company Intel</button>
                        <button class="brief-tab-button" onclick="switchBriefTab('strategy')">Recommendations</button>
                        <button class="brief-tab-button" onclick="switchBriefTab('actions')">Action Items</button>
                    </div>

                    <!-- Tab: Attendees -->
                    <div id="brief-tab-attendees" class="brief-tab-content active">
                        ${brief.attendees && Array.isArray(brief.attendees) && brief.attendees.length > 0 ? `
                            <div class="attendee-grid">
                                ${brief.attendees.map(att => {
                                    try {
                                        const name = att?.name || 'Unknown';
                                        const title = att?.title || 'No title';
                                        const email = att?.email || 'No email';
                                        const keyFacts = Array.isArray(att?.keyFacts) ? att.keyFacts : [];
                                        const dataSource = att?.dataSource || '';
                                        return `
                                    <div class="attendee-modern-card">
                                        <div class="attendee-avatar-modern">${getInitials(name)}</div>
                                        <div class="attendee-details">
                                            <h4>${name}</h4>
                                            <p class="attendee-title">${title}</p>
                                            <p class="attendee-email">${email}</p>
                                            ${keyFacts.length > 0 ? `
                                                <div class="key-facts-section">
                                                    <strong>Key Information:</strong>
                                                    ${dataSource ? `<span style="font-size: 11px; color: #999; margin-left: 8px;">(${dataSource === 'local' ? 'from emails' : dataSource === 'web' ? 'from web search' : dataSource === 'local+web' ? 'from emails & web' : 'basic info'})</span>` : ''}
                                                    <ul class="key-facts">
                                                        ${keyFacts.map(fact => `<li>${typeof fact === 'string' ? fact : JSON.stringify(fact)}</li>`).join('')}
                                                    </ul>
                                                </div>
                                            ` : '<p style="color: #888;">Limited information available</p>'}
                                        </div>
                                    </div>
                                `;
                                    } catch (e) {
                                        console.error('Error rendering attendee:', e);
                                        return '<div class="attendee-modern-card"><p style="color: #d32f2f;">Error loading attendee data</p></div>';
                                    }
                                }).join('')}
                            </div>
                        ` : '<p style="color: #888;">No attendee information available.</p>'}
                    </div>

                    <!-- Tab: Relationships -->
                    <div id="brief-tab-relationships" class="brief-tab-content">
                        <div class="analysis-section">
                            <h3>ðŸ¤ Working Relationship Dynamics</h3>
                            ${brief.relationshipAnalysis && typeof brief.relationshipAnalysis === 'string' && brief.relationshipAnalysis.trim().length > 0 ? `
                                <p class="analysis-text relationship-analysis">${brief.relationshipAnalysis}</p>
                            ` : '<p style="color: #888;">No relationship analysis available.</p>'}
                        </div>
                    </div>

                    <!-- Tab: Timeline -->
                    <div id="brief-tab-timeline" class="brief-tab-content">
                        <div class="analysis-section">
                            <h3>ðŸ“… Interaction Timeline</h3>
                            ${brief.timeline && brief.timeline.length > 0 ? `
                                <div class="timeline-container">
                                    <div class="timeline-line"></div>
                                    ${brief.timeline.map((event, idx) => {
                                        const eventDate = new Date(event.date);
                                        const now = new Date();
                                        const daysAgo = Math.floor((now - eventDate) / (1000 * 60 * 60 * 24));
                                        const isRecent = daysAgo <= 7;

                                        // Format date
                                        const dateStr = eventDate.toLocaleDateString('en-US', {
                                            month: 'short',
                                            day: 'numeric',
                                            year: 'numeric'
                                        });
                                        const timeStr = eventDate.toLocaleTimeString('en-US', {
                                            hour: '2-digit',
                                            minute: '2-digit'
                                        });

                                        return `
                                            <div class="timeline-event ${event.type} ${isRecent ? 'recent' : ''}" data-index="${idx}">
                                                <div class="timeline-marker ${event.type}"></div>
                                                <div class="timeline-content">
                                                    <div class="timeline-header">
                                                        <span class="timeline-type-badge ${event.type}">
                                                            ${event.type === 'email' ? 'ðŸ“§ Email' : event.type === 'document' ? 'ðŸ“„ Document' : 'ðŸ“… Meeting'}
                                                        </span>
                                                        <span class="timeline-date">${dateStr} â€¢ ${timeStr}</span>
                                                    </div>
                                                    ${event.type === 'email' ? `
                                                        <h4 class="timeline-title">${event.subject}</h4>
                                                        ${event.participants && event.participants.length > 0 ? `
                                                            <p class="timeline-participants">From: ${event.participants.join(', ')}</p>
                                                        ` : ''}
                                                        ${event.snippet ? `
                                                            <p class="timeline-snippet">${event.snippet}</p>
                                                        ` : ''}
                                                    ` : event.type === 'document' ? `
                                                        <h4 class="timeline-title">${event.name}</h4>
                                                        <p class="timeline-action">${event.action === 'created' ? 'Created' : 'Modified'}</p>
                                                        ${event.participants && event.participants.length > 0 ? `
                                                            <p class="timeline-participants">By: ${event.participants.join(', ')}</p>
                                                        ` : ''}
                                                    ` : ''}
                                                    ${isRecent ? '<span class="timeline-recent-badge">Recent</span>' : ''}
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            ` : '<p style="color: #888;">No interaction history available.</p>'}
                        </div>
                    </div>

                    <!-- Tab: Email Analysis -->
                    <div id="brief-tab-emails" class="brief-tab-content">
                        <div class="analysis-section">
                            <h3>ðŸ“§ Email Thread Analysis</h3>
                            ${brief.emailAnalysis ? `
                                <p class="analysis-text">${brief.emailAnalysis}</p>
                            ` : '<p style="color: #888;">No recent email activity to analyze.</p>'}
                        </div>
                    </div>

                    <!-- Tab: Documents -->
                    <div id="brief-tab-documents" class="brief-tab-content">
                        <div class="analysis-section">
                            <h3>ðŸ“„ Document Review</h3>
                            ${brief.documentAnalysis ? `
                                <p class="analysis-text">${brief.documentAnalysis}</p>
                            ` : '<p style="color: #888;">No relevant documents identified.</p>'}
                        </div>
                    </div>

                    <!-- Tab: Company Intel -->
                    <div id="brief-tab-company" class="brief-tab-content">
                        <div class="analysis-section">
                            <h3>ðŸ¢ Company & Context Research</h3>
                            ${brief.companyResearch ? `
                                <p class="analysis-text">${brief.companyResearch}</p>
                            ` : '<p style="color: #888;">No company research available.</p>'}
                        </div>
                    </div>

                    <!-- Tab: Strategic Recommendations -->
                    <div id="brief-tab-strategy" class="brief-tab-content">
                        <div class="analysis-section">
                            <h3>ðŸ’¡ Strategic Recommendations</h3>
                            ${brief.recommendations && brief.recommendations.length > 0 ? `
                                <ul class="recommendations-list">
                                    ${brief.recommendations.map((rec, idx) => `
                                        <li class="recommendation-item">
                                            <span class="rec-number">${idx + 1}</span>
                                            <span class="rec-text">${rec}</span>
                                        </li>
                                    `).join('')}
                                </ul>
                            ` : '<p style="color: #888;">No recommendations generated.</p>'}
                        </div>
                    </div>

                    <!-- Tab: Action Items -->
                    <div id="brief-tab-actions" class="brief-tab-content">
                        <div class="analysis-section">
                            <h3>âœ… Preparation Checklist</h3>
                            ${brief.actionItems && brief.actionItems.length > 0 ? `
                                <div class="action-checklist">
                                    ${brief.actionItems.map(item => `
                                        <label class="action-item">
                                            <input type="checkbox">
                                            <span>${item}</span>
                                        </label>
                                    `).join('')}
                                </div>
                            ` : '<p style="color: #888;">No action items identified.</p>'}
                        </div>
                    </div>
                </div>
            `;
        }

        // Tab switching function
        window.switchBriefTab = function(tabName) {
            // Hide all tabs
            document.querySelectorAll('.brief-tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.brief-tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            const selectedTab = document.getElementById(`brief-tab-${tabName}`);
            const selectedButton = event.target;
            if (selectedTab) {
                selectedTab.classList.add('active');
                selectedButton.classList.add('active');
            }
        };

        function formatMeetingTime(meeting) {
            const start = new Date(meeting.start.dateTime || meeting.start.date);
            const end = new Date(meeting.end.dateTime || meeting.end.date);
            return `${start.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} - ${end.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
        }

        // ===== TABBED BRIEF RENDERING (OLD - KEEPING FOR NOW) =====

        function renderBriefWithTabs(briefData) {
            const modalBody = document.getElementById('prepModalBody');
            const { meeting, attendees, attendeeResearch, companyResearch, emails, filesWithContent,
                    emailAnalysis, docAnalysis, dynamicsAnalysis, strategyAnalysis, webIntelAnalysis } = briefData;

            modalBody.innerHTML = `
                <div class="brief-tabs">
                    <button class="brief-tab-button active" onclick="switchBriefTab('overview')">Overview</button>
                    <button class="brief-tab-button" onclick="switchBriefTab('attendees')">Attendees</button>
                    <button class="brief-tab-button" onclick="switchBriefTab('emails')">Email Analysis</button>
                    <button class="brief-tab-button" onclick="switchBriefTab('documents')">Documents</button>
                    <button class="brief-tab-button" onclick="switchBriefTab('web')">Web Research</button>
                    <button class="brief-tab-button" onclick="switchBriefTab('strategy')">Strategy</button>
                </div>

                <div id="brief-tab-overview" class="brief-tab-content active">
                    ${renderOverviewTab(meeting, dynamicsAnalysis)}
                </div>

                <div id="brief-tab-attendees" class="brief-tab-content">
                    ${renderAttendeesTab(attendees, attendeeResearch)}
                </div>

                <div id="brief-tab-emails" class="brief-tab-content">
                    ${renderEmailAnalysisTab(emails, emailAnalysis)}
                </div>

                <div id="brief-tab-documents" class="brief-tab-content">
                    ${renderDocumentsTab(filesWithContent, docAnalysis)}
                </div>

                <div id="brief-tab-web" class="brief-tab-content">
                    ${renderWebResearchTab(webIntelAnalysis, companyResearch)}
                </div>

                <div id="brief-tab-strategy" class="brief-tab-content">
                    ${renderStrategyTab(strategyAnalysis)}
                </div>
            `;
        }

        function switchBriefTab(tabName) {
            document.querySelectorAll('.brief-tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.brief-tab-content').forEach(content => content.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(`brief-tab-${tabName}`).classList.add('active');
        }

        function renderOverviewTab(meeting, dynamicsAnalysis) {
            const start = meeting.start.dateTime || meeting.start.date;
            const end = meeting.end.dateTime || meeting.end.date;
            const status = getEventStatus(start, end) || '';

            return `
                <div class="insight-card">
                    <h4>Meeting Overview</h4>
                    <p><strong>Title:</strong> ${meeting.summary || 'Untitled Meeting'}</p>
                    <p><strong>Time:</strong> ${new Date(start).toLocaleString()}</p>
                    <p><strong>Status:</strong> ${status}</p>
                    ${meeting.location ? `<p><strong>Location:</strong> ${meeting.location}</p>` : ''}
                    ${meeting.description ? `<p><strong>Description:</strong> ${meeting.description}</p>` : ''}
                </div>

                <div class="insight-card">
                    <h4>Attendee Dynamics & Power Structure</h4>
                    <div>${formatMarkdown(dynamicsAnalysis || 'Analysis unavailable')}</div>
                </div>
            `;
        }

        function renderAttendeesTab(attendees, attendeeResearch) {
            return attendees.map(att => {
                const research = attendeeResearch.find(r => r.attendee.email === att.email);
                const initials = (att.displayName || att.email).split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);

                return `
                    <div class="attendee-card">
                        <div class="attendee-card-header">
                            <div class="attendee-avatar">${initials}</div>
                            <div class="attendee-info">
                                <h4>${att.displayName || att.email}</h4>
                                <p>${att.email}${att.organizer ? ' â€¢ <strong>Organizer</strong>' : ''}</p>
                            </div>
                        </div>
                        <div class="attendee-insights">
                            ${research && research.results && research.results.length > 0 ? `
                                <div class="insight-section">
                                    <div class="insight-label">Web Research:</div>
                                    ${research.results.slice(0, 3).map(r => `
                                        <div class="insight-value">
                                            <strong>${r.title || 'Web Result'}</strong><br>
                                            ${(r.excerpts?.join(' ') || 'No content available').substring(0, 300)}...
                                            <a href="${r.url || '#'}" class="source-citation" target="_blank">Source</a>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : '<p style="color: #999;">No web research available</p>'}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderEmailAnalysisTab(emails, emailAnalysis) {
            return `
                <div class="insight-card">
                    <h4>Email Thread Analysis (${emails.length} emails)</h4>
                    <button class="copy-section-btn" onclick="navigator.clipboard.writeText(this.nextElementSibling.innerText)">Copy</button>
                    <div>${formatMarkdown(emailAnalysis || 'No email analysis available')}</div>
                </div>

                <div class="insight-card">
                    <h4>Recent Email Threads</h4>
                    ${emails.slice(0, 5).map((email, idx) => `
                        <div style="margin-bottom: 16px; padding-bottom: 16px; border-bottom: 1px solid #e0e0e0;">
                            <strong>${email.subject}</strong><br>
                            <span style="color: #666; font-size: 13px;">From: ${email.from} â€¢ ${email.date}</span><br>
                            <p style="margin-top: 8px;">${email.snippet}</p>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderDocumentsTab(filesWithContent, docAnalysis) {
            return `
                <div class="insight-card">
                    <h4>Document Analysis</h4>
                    <button class="copy-section-btn" onclick="navigator.clipboard.writeText(this.nextElementSibling.innerText)">Copy</button>
                    <div>${formatMarkdown(docAnalysis || 'No document analysis available')}</div>
                </div>

                ${filesWithContent.filter(f => f.hasContent).map(file => `
                    <div class="document-card">
                        <h4>${file.name}</h4>
                        <div class="document-meta">
                            Owner: ${file.owner} â€¢ Modified: ${new Date(file.modifiedTime).toLocaleDateString()}
                        </div>
                        <p>${file.content.substring(0, 500)}...</p>
                        <a href="${file.url}" target="_blank" class="source-citation">View Full Document</a>
                    </div>
                `).join('')}
            `;
        }

        function renderWebResearchTab(webIntelAnalysis, companyResearch) {
            return `
                <div class="insight-card">
                    <h4>Web Intelligence Synthesis</h4>
                    <button class="copy-section-btn" onclick="navigator.clipboard.writeText(this.nextElementSibling.innerText)">Copy</button>
                    <div>${formatMarkdown(webIntelAnalysis || 'No web intelligence available')}</div>
                </div>

                ${companyResearch.map(cr => `
                    <div class="insight-card">
                        <h4>Company: ${cr.company}</h4>
                        ${cr.results && cr.results.length > 0 ? cr.results.map(r => `
                            <div style="margin-bottom: 12px;">
                                <strong>${r.title || 'Research Result'}</strong><br>
                                <p>${(r.excerpts?.join(' ') || 'No content available').substring(0, 400)}...</p>
                                <a href="${r.url || '#'}" class="source-citation" target="_blank">Read More</a>
                            </div>
                        `).join('') : '<p>No results found</p>'}
                    </div>
                `).join('')}
            `;
        }

        function renderStrategyTab(strategyAnalysis) {
            return `
                <div class="insight-card">
                    <h4>Strategic Recommendations</h4>
                    <button class="copy-section-btn" onclick="navigator.clipboard.writeText(this.nextElementSibling.innerText)">Copy</button>
                    <div>${formatMarkdown(strategyAnalysis || 'No strategic analysis available')}</div>
                </div>
            `;
        }

        function buildPrepPrompt(meeting, attendees, emails, attachments, files, pastEvents) {
            const start = meeting.start.dateTime || meeting.start.date;
            const end = meeting.end.dateTime || meeting.end.date;

            let prompt = `I need you to prepare me for an upcoming meeting. Here is all the context:\n\n`;

            // User information
            prompt += `## MY INFORMATION\n`;
            prompt += `Name: ${userProfile?.name || 'Unknown'}\n`;
            prompt += `Email: ${userEmail}\n\n`;

            // Meeting details
            prompt += `## MEETING DETAILS\n`;
            prompt += `Title: ${meeting.summary || 'Untitled Meeting'}\n`;
            prompt += `Date & Time: ${new Date(start).toLocaleString()} - ${new Date(end).toLocaleTimeString()}\n`;
            if (meeting.location) prompt += `Location: ${meeting.location}\n`;
            if (meeting.description) prompt += `Description: ${meeting.description}\n`;
            prompt += `\n`;

            // Attendees
            prompt += `## ATTENDEES (${attendees.length} people)\n`;
            attendees.forEach(att => {
                prompt += `- ${att.displayName || att.email} (${att.email})`;
                if (att.organizer) prompt += ` [ORGANIZER]`;
                if (att.responseStatus) prompt += ` - Status: ${att.responseStatus}`;
                prompt += `\n`;
            });
            prompt += `\n`;

            // Past interactions via email - include MORE context
            if (emails.length > 0) {
                prompt += `## RECENT EMAIL HISTORY (${emails.length} emails)\n\n`;
                emails.slice(0, 15).forEach((email, idx) => {
                    prompt += `### Email ${idx + 1}: ${email.subject}\n`;
                    prompt += `**From:** ${email.from}\n`;
                    prompt += `**Date:** ${email.date}\n`;
                    prompt += `**Preview:** ${email.snippet}\n\n`;
                    if (email.body && email.body.length > 0) {
                        // Include FULL email body, not just snippet - critical for context
                        prompt += `**FULL EMAIL CONTENT:**\n${email.body}\n`;
                    }
                    prompt += `\n--- END EMAIL ${idx + 1} ---\n\n`;
                });
            }

            // Past meetings
            if (pastEvents.length > 0) {
                prompt += `## PAST MEETINGS WITH ATTENDEES (${pastEvents.length} meetings)\n`;
                pastEvents.slice(0, 5).forEach(event => {
                    prompt += `- ${event.summary} on ${new Date(event.start).toLocaleDateString()}`;
                    if (event.description) prompt += ` - ${event.description.substring(0, 100)}`;
                    prompt += `\n`;
                });
                prompt += `\n`;
            }

            // Shared files with content
            if (files.length > 0) {
                prompt += `## RELEVANT SHARED FILES (${files.length} files)\n\n`;
                files.forEach(file => {
                    prompt += `### File: ${file.name}\n`;
                    prompt += `Type: ${getFileType(file.mimeType, file.name)}\n`;
                    prompt += `Owner: ${file.owner}\n`;
                    prompt += `Modified: ${new Date(file.modifiedTime).toLocaleDateString()}\n`;

                    if (file.hasContent && file.content) {
                        prompt += `\n**FULL CONTENT:**\n`;
                        prompt += `${file.content}\n`;
                        prompt += `--- END OF ${file.name} ---\n\n`;
                    } else {
                        prompt += `(Content not available for this file type)\n\n`;
                    }
                });
            }

            // Attachments from emails
            if (attachments.length > 0) {
                prompt += `## EMAIL ATTACHMENTS (${attachments.length} attachments)\n`;
                attachments.slice(0, 10).forEach(att => {
                    prompt += `- ${att.filename} from ${att.from} on ${att.date}\n`;
                });
                prompt += `\n`;
            }

            prompt += `## YOUR TASK\n\n`;
            prompt += `You have been provided with EXTENSIVE context including full document contents, email threads, and relationship history. `;
            prompt += `This is NOT a surface-level brief - you must deeply analyze ALL the information provided.\n\n`;

            prompt += `Create a comprehensive, executive-level meeting preparation brief that includes:\n\n`;

            prompt += `1. **Executive Summary** (2-3 sentences)\n`;
            prompt += `   - What is this meeting really about at its core?\n`;
            prompt += `   - What are the stakes?\n\n`;

            prompt += `2. **Meeting Context & Objectives**\n`;
            prompt += `   - Analyze the meeting agenda and documents in detail\n`;
            prompt += `   - What are the explicit and implicit goals?\n`;
            prompt += `   - What decisions need to be made?\n\n`;

            prompt += `3. **Key Participants Analysis**\n`;
            prompt += `   - For each important attendee: their role, interests, and likely positions\n`;
            prompt += `   - What does our email history reveal about their priorities?\n`;
            prompt += `   - Who are the decision makers and influencers?\n\n`;

            prompt += `4. **Document Deep Dive**\n`;
            prompt += `   - Synthesize the KEY insights from all shared documents\n`;
            prompt += `   - What are the main themes, concerns, or proposals?\n`;
            prompt += `   - What specific details or data points are most relevant?\n`;
            prompt += `   - What questions or gaps exist in the materials?\n\n`;

            prompt += `5. **Relationship & History Analysis**\n`;
            prompt += `   - What patterns emerge from past emails and meetings?\n`;
            prompt += `   - What's the trajectory of this relationship?\n`;
            prompt += `   - Any concerns or wins from recent interactions?\n\n`;

            prompt += `6. **Strategic Preparation Points**\n`;
            prompt += `   - Specific talking points I should prepare\n`;
            prompt += `   - Questions I should be ready to answer\n`;
            prompt += `   - Data or information I should have at hand\n`;
            prompt += `   - Potential objections and how to address them\n\n`;

            prompt += `7. **Likely Discussion Topics & Your Position**\n`;
            prompt += `   - Based on documents and context, what will be discussed?\n`;
            prompt += `   - What should my stance be on each topic?\n`;
            prompt += `   - Where might there be disagreement?\n\n`;

            prompt += `8. **Recommendations & Action Items**\n`;
            prompt += `   - What should I do before the meeting?\n`;
            prompt += `   - What outcomes should I push for?\n`;
            prompt += `   - What follow-ups will likely be needed?\n\n`;

            prompt += `Be thorough, insightful, and strategic. Reference specific details from the documents and emails. `;
            prompt += `This brief should make me the most prepared person in the meeting. Format using clear markdown sections.`;

            return prompt;
        }

        function formatMarkdown(text) {
            // Simple markdown formatting
            return text
                .replace(/### (.*)/g, '<h3>$1</h3>')
                .replace(/## (.*)/g, '<h2>$1</h2>')
                .replace(/# (.*)/g, '<h2>$1</h2>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/^- (.*)/gm, '<li>$1</li>')
                .replace(/^\d+\. (.*)/gm, '<li>$1</li>')
                .replace(/\n\n/g, '</p><p>')
                .replace(/^(?!<[h|l|p])/gm, '<p>')
                .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
                .replace(/<\/li>\n<li>/g, '</li><li>');
        }

        function closePrepModal() {
            // Don't clear meetingBrief - keep it for "Entering Meeting" and "Voice Prep Mode" buttons
            // It will be cleared when user switches meetings or goes back to calendar

            // Clear DOM content to prevent stale data display
            document.getElementById('prepModalBody').innerHTML = '';

            document.getElementById('prepModal').classList.remove('visible');
        }

        // Make functions available globally
        window.toggleMeetingInfo = toggleMeetingInfo;
        window.toggleContext = toggleContext;
        window.toggleEmailBody = toggleEmailBody;
        window.loadContextData = loadContextData;
        window.showMeetingDetail = showMeetingDetail;
        window.showCalendarView = showCalendarView;
        window.switchTab = switchTab;
        window.toggleAllEmailFilters = toggleAllEmailFilters;
        window.toggleAllAttachmentFilters = toggleAllAttachmentFilters;
        window.toggleAllFilesFilters = toggleAllFilesFilters;
        window.filterEmails = filterEmails;
        window.filterAttachments = filterAttachments;
        window.filterFiles = filterFiles;
        window.prepareForMeeting = prepareForMeeting;
        window.closePrepModal = closePrepModal;
        window.switchBriefTab = switchBriefTab;

        // ===== REAL-TIME MEETING ASSISTANT =====

        let meetingAssistantWs = null;
        let mediaRecorder = null;
        let audioContext = null;
        let scriptProcessor = null;
        let mediaStream = null;
        let meetingBrief = null;
        let currentMeetingId = null;
        let prepRequestInProgress = false;

        // Speaker mapping state
        let detectedSpeakers = new Set();
        let speakerMappings = new Map();
        let pendingMappingModal = false;
        let recentSuggestions = new Set(); // Client-side deduplication

        async function enterMeeting() {
            try {
                // CRITICAL: Validate meeting context before entering
                if (!currentMeeting) {
                    alert('Please select a meeting first.');
                    return;
                }

                if (!meetingBrief || !currentMeetingId) {
                    alert('Please generate a meeting prep first by clicking "Prep Me".');
                    return;
                }

                if (currentMeetingId !== currentMeeting.id) {
                    alert('Meeting prep is out of sync. Please generate a new prep for this meeting.');
                    meetingBrief = null;
                    currentMeetingId = null;
                    document.getElementById('enterMeetingButton').style.display = 'none';
                    return;
                }

                // Check browser compatibility
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert('Your browser does not support audio recording. Please use Chrome, Firefox, or Safari.');
                    return;
                }

                if (!window.MediaRecorder) {
                    alert('Your browser does not support MediaRecorder API. Please update your browser.');
                    return;
                }

                if (!window.WebSocket) {
                    alert('Your browser does not support WebSocket. Please update your browser.');
                    return;
                }

                // Show the assistant UI
                document.getElementById('meetingAssistantContainer').style.display = 'block';
                document.getElementById('enterMeetingButton').disabled = true;
                document.getElementById('enterMeetingButton').textContent = 'ðŸŽ¤ Active...';

                // Get microphone access
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 16000
                    }
                });

                // Connect to WebSocket
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const host = window.location.host;
                meetingAssistantWs = new WebSocket(`${protocol}//${host}`);

                meetingAssistantWs.onopen = () => {
                    console.log('âœ“ Connected to meeting assistant');

                    // Send initialization with meeting context
                    meetingAssistantWs.send(JSON.stringify({
                        type: 'init',
                        meetingId: currentMeetingId,
                        context: meetingBrief || {},
                        userEmail: userEmail || ''
                    }));
                };

                meetingAssistantWs.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    if (data.type === 'ready') {
                        console.log('âœ“ Meeting assistant ready');
                        startAudioCapture(stream);
                    }
                    else if (data.type === 'deepgram_ready') {
                        console.log('âœ“ Deepgram connection ready');
                        // Show visual feedback
                        const suggestionsContainer = document.getElementById('suggestionsContainer');
                        suggestionsContainer.innerHTML = '<div class="suggestion-placeholder">ðŸŽ¤ Listening... Start speaking.</div>';
                    }
                    else if (data.type === 'transcript') {
                        // Track detected speakers
                        if (data.speakerId !== null && data.speakerId !== undefined) {
                            if (!detectedSpeakers.has(data.speakerId) && !speakerMappings.has(data.speakerId)) {
                                detectedSpeakers.add(data.speakerId);
                                // Show mapping modal after 2-3 speakers detected
                                if (detectedSpeakers.size >= 2 && !pendingMappingModal) {
                                    pendingMappingModal = true;
                                    showSpeakerMappingModal();
                                }
                            }
                        }
                        addTranscriptItem(data);
                    }
                    else if (data.type === 'speaker_mapped') {
                        console.log(`âœ“ Speaker ${data.speakerId} mapped to ${data.name}`);
                    }
                    else if (data.type === 'suggestions') {
                        addSuggestions(data.suggestions);
                    }
                    else if (data.type === 'error') {
                        console.error('Assistant error:', data.message);
                        // Show error in UI
                        const suggestionsContainer = document.getElementById('suggestionsContainer');
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'suggestion-item error';
                        errorDiv.innerHTML = `
                            <div class="suggestion-type">Error</div>
                            <div class="suggestion-message">${data.message}</div>
                        `;
                        suggestionsContainer.insertBefore(errorDiv, suggestionsContainer.firstChild);
                    }
                };

                meetingAssistantWs.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    alert('Connection error. Please try again.');
                };

                meetingAssistantWs.onclose = () => {
                    console.log('Meeting assistant disconnected');
                    stopAudioCapture();
                };

            } catch (error) {
                console.error('Failed to start meeting assistant:', error);
                alert('Failed to access microphone. Please check permissions.');
                document.getElementById('enterMeetingButton').disabled = false;
                document.getElementById('enterMeetingButton').textContent = 'ðŸŽ¤ Entering Meeting';
            }
        }

        function startAudioCapture(stream) {
            try {
                mediaStream = stream;

                // Create AudioContext with 16kHz sample rate (Deepgram requirement)
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000
                });

                console.log(`âœ“ AudioContext created (${audioContext.sampleRate}Hz)`);

                // Create source from microphone stream
                const source = audioContext.createMediaStreamSource(stream);

                // Create ScriptProcessor for raw PCM extraction
                // Buffer size 4096 gives good balance of latency vs processing overhead
                scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);

                scriptProcessor.onaudioprocess = (e) => {
                    if (meetingAssistantWs && meetingAssistantWs.readyState === WebSocket.OPEN) {
                        const inputData = e.inputBuffer.getChannelData(0); // Float32Array [-1, 1]

                        // Convert Float32 to Int16 PCM (linear16 format for Deepgram)
                        const pcmData = new Int16Array(inputData.length);
                        for (let i = 0; i < inputData.length; i++) {
                            // Clamp to [-1, 1] and convert to 16-bit signed integer
                            const s = Math.max(-1, Math.min(1, inputData[i]));
                            pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                        }

                        // Convert Int16Array to base64
                        const uint8Array = new Uint8Array(pcmData.buffer);
                        const base64Audio = btoa(String.fromCharCode(...uint8Array));

                        // Send raw PCM audio to backend
                        meetingAssistantWs.send(JSON.stringify({
                            type: 'audio',
                            audio: base64Audio
                        }));
                    }
                };

                // Connect audio pipeline: microphone -> processor -> destination
                source.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);

                console.log('âœ“ Audio capture started (raw PCM, 16kHz, Int16)');

            } catch (error) {
                console.error('Failed to start audio capture:', error);
                alert(`Failed to start audio: ${error.message}`);
            }
        }

        function stopAudioCapture() {
            // Disconnect and clean up ScriptProcessor
            if (scriptProcessor) {
                scriptProcessor.disconnect();
                scriptProcessor = null;
            }

            // Close AudioContext
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            // Stop all media stream tracks
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }

            console.log('âœ“ Audio capture stopped');
        }

        function addTranscriptItem(data) {
            const container = document.getElementById('transcriptContainer');
            const placeholder = container.querySelector('.suggestion-placeholder');
            if (placeholder) placeholder.remove();

            const item = document.createElement('div');
            item.className = `transcript-item ${data.isUser ? 'user' : ''}`;
            item.innerHTML = `
                <div class="transcript-speaker">${data.speaker}${data.isUser ? ' (You)' : ''}</div>
                <div class="transcript-text">${data.text}</div>
                <div class="transcript-timestamp">${new Date(data.timestamp).toLocaleTimeString()}</div>
            `;

            container.appendChild(item);
            container.scrollTop = container.scrollHeight;
        }

        function addSuggestions(suggestions) {
            const container = document.getElementById('suggestionsContainer');
            const placeholder = container.querySelector('.suggestion-placeholder');
            if (placeholder) placeholder.remove();

            suggestions.forEach(sugg => {
                // Client-side deduplication
                const normalized = sugg.message.toLowerCase().replace(/[^\w\s]/g, '').trim().substring(0, 80);
                if (recentSuggestions.has(normalized)) {
                    console.log('Skipping duplicate suggestion:', sugg.message.substring(0, 40) + '...');
                    return; // Skip duplicate
                }
                recentSuggestions.add(normalized);

                // Auto-cleanup after 60 seconds
                setTimeout(() => recentSuggestions.delete(normalized), 60000);

                const item = document.createElement('div');
                item.className = `suggestion-item ${sugg.severity}`;
                item.innerHTML = `
                    <div class="suggestion-type">${sugg.type}</div>
                    <div class="suggestion-message">${sugg.message}</div>
                `;

                container.insertBefore(item, container.firstChild);

                // Keep only last 15 suggestions (reduced from 20 to prevent clutter)
                const items = container.querySelectorAll('.suggestion-item');
                if (items.length > 15) {
                    items[items.length - 1].remove();
                }
            });
        }

        function stopMeetingAssistant() {
            if (meetingAssistantWs) {
                meetingAssistantWs.send(JSON.stringify({ type: 'stop' }));
                meetingAssistantWs.close();
                meetingAssistantWs = null;
            }

            stopAudioCapture();

            document.getElementById('meetingAssistantContainer').style.display = 'none';
            document.getElementById('enterMeetingButton').disabled = false;
            document.getElementById('enterMeetingButton').textContent = 'ðŸŽ¤ Entering Meeting';

            // Clear content
            document.getElementById('transcriptContainer').innerHTML = '<div class="suggestion-placeholder">Session ended</div>';
            document.getElementById('suggestionsContainer').innerHTML = '<div class="suggestion-placeholder">Session ended</div>';
        }

        // Show speaker mapping modal
        function showSpeakerMappingModal() {
            const modal = document.getElementById('speakerMappingModal');
            const listContainer = document.getElementById('speakerMappingList');

            // Build dropdown options from meeting attendees
            const attendees = meetingBrief?.attendees || [];
            const options = [
                '<option value="You">You</option>',
                ...attendees.map(att => `<option value="${att.name}">${att.name} (${att.email})</option>`)
            ];

            // Create a mapping UI for each detected speaker
            listContainer.innerHTML = Array.from(detectedSpeakers).map(speakerId => `
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 6px; font-weight: 500;">Speaker ${speakerId}:</label>
                    <select id="speaker-${speakerId}-mapping" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;">
                        ${options.join('')}
                    </select>
                </div>
            `).join('');

            modal.style.display = 'flex';
        }

        // Confirm speaker mapping and send to server
        function confirmSpeakerMapping() {
            detectedSpeakers.forEach(speakerId => {
                const select = document.getElementById(`speaker-${speakerId}-mapping`);
                const name = select.value;
                speakerMappings.set(speakerId, name);

                // Send mapping to server
                if (meetingAssistantWs && meetingAssistantWs.readyState === WebSocket.OPEN) {
                    meetingAssistantWs.send(JSON.stringify({
                        type: 'map_speaker',
                        speakerId,
                        name
                    }));
                }
            });

            // Close modal
            document.getElementById('speakerMappingModal').style.display = 'none';

            // Update all existing transcript items with new labels
            updateTranscriptLabels();
        }

        // Update transcript labels after mapping
        function updateTranscriptLabels() {
            const items = document.querySelectorAll('.transcript-item');
            items.forEach(item => {
                const speakerDiv = item.querySelector('.transcript-speaker');
                if (speakerDiv) {
                    const speakerText = speakerDiv.textContent;
                    // Extract speaker ID from "Speaker X" format
                    const match = speakerText.match(/Speaker (\d+)/);
                    if (match) {
                        const speakerId = parseInt(match[1]);
                        const mappedName = speakerMappings.get(speakerId);
                        if (mappedName) {
                            const isYou = mappedName === 'You';
                            speakerDiv.textContent = mappedName + (isYou ? '' : '');
                            if (isYou) {
                                item.classList.add('user');
                            }
                        }
                    }
                }
            });
        }

        // Clear all suggestions
        function clearSuggestions() {
            document.getElementById('suggestionsContainer').innerHTML = '<div class="suggestion-placeholder">Suggestions cleared. Listening...</div>';
            recentSuggestions.clear();
        }

        window.enterMeeting = enterMeeting;
        window.stopMeetingAssistant = stopMeetingAssistant;
        window.confirmSpeakerMapping = confirmSpeakerMapping;
        window.clearSuggestions = clearSuggestions;

        // ===== INTERACTIVE PREP FUNCTIONS =====

        let interactivePrepWs = null;
        let interactiveBrief = null;
        let chatMessagesArray = []; // Renamed to avoid conflict with DOM element id
        let isVoiceActive = false;
        let isSpeaking = false;
        let chatAudioContext = null;
        let chatScriptProcessor = null;
        let chatMediaStream = null;
        let conversationHistory = [];
        let voiceConversationMode = false; // True = continuous conversation, False = single utterance
        let currentAIUtterance = null; // For TTS interruption

        async function startInteractivePrep() {
            const button = document.getElementById('interactivePrepButton');
            button.disabled = true;
            button.textContent = 'â³ Preparing...';

            try {
                const meeting = currentMeeting;
                if (!meeting) {
                    throw new Error('No meeting selected');
                }

                const attendees = meeting.attendees || [];

                // Clear cached data to prevent cross-meeting contamination
                currentEmails = [];
                currentFiles = [];

                // Call backend to generate brief (server now fetches emails/files)
                const response = await fetch('/api/prep-meeting', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        meeting,
                        attendees,
                        accessToken: accessToken // Server uses this to fetch emails/files
                    })
                });

                if (!response.ok) throw new Error('Failed to generate meeting prep');

                interactiveBrief = await response.json();

                // Add meeting info to brief for context
                interactiveBrief.meeting = meeting;

                // Format meeting time
                const startTime = new Date(meeting.start.dateTime || meeting.start.date);
                const endTime = new Date(meeting.end.dateTime || meeting.end.date);
                const timeStr = `${startTime.toLocaleDateString()} ${startTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} - ${endTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;

                // Populate the brief sidebar
                populateBriefSidebar(interactiveBrief);

                // Open chat interface
                document.getElementById('interactiveMeetingTitle').textContent = meeting.summary;
                document.getElementById('interactiveMeetingTime').textContent = timeStr;
                document.getElementById('interactivePrepOverlay').style.display = 'flex';

                // Initialize WebSocket connection for interactive prep
                initializeInteractiveWebSocket();

                // Add initial AI greeting
                addChatMessage('assistant', `Hi! I've prepared all the context for your meeting "${meeting.summary}". Ask me anything about the attendees, agenda, related documents, or any other preparation you need.`);

            } catch (error) {
                console.error('Error starting interactive prep:', error);
                alert('Failed to start interactive prep: ' + error.message);
            } finally {
                button.disabled = false;
                button.textContent = 'ðŸ’¬ Interactive Prep';
            }
        }

        function populateBriefSidebar(brief) {
            const container = document.getElementById('interactiveBriefContent');

            let html = '';

            // Summary
            if (brief.summary) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 8px 0; color: #1f2937; font-size: 14px;">ðŸ“ Summary</h4>
                        <p style="margin: 0; color: #4b5563; line-height: 1.6;">${brief.summary}</p>
                    </div>
                `;
            }

            // Attendees
            if (brief.attendees && brief.attendees.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 12px 0; color: #1f2937; font-size: 14px;">ðŸ‘¥ Attendees (${brief.attendees.length})</h4>
                `;
                brief.attendees.forEach(att => {
                    html += `
                        <div style="margin-bottom: 12px; padding: 10px; background: var(--color-bg); border-radius: 6px; border-left: 3px solid var(--color-primary); border: 1px solid var(--color-border);">
                            <div style="font-weight: 600; color: #1f2937; margin-bottom: 4px;">${att.name}</div>
                            <div style="font-size: 12px; color: #6b7280; margin-bottom: 6px;">${att.title || att.email}</div>
                            ${att.keyFacts && att.keyFacts.length > 0 ? `
                                <ul style="margin: 6px 0 0 0; padding-left: 18px; font-size: 12px; color: #4b5563;">
                                    ${att.keyFacts.map(fact => `<li style="margin-bottom: 4px;">${fact}</li>`).join('')}
                                </ul>
                            ` : ''}
                        </div>
                    `;
                });
                html += `</div>`;
            }

            // Action Items
            if (brief.actionItems && brief.actionItems.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 12px 0; color: #1f2937; font-size: 14px;">âœ… Action Items</h4>
                        <ul style="margin: 0; padding-left: 18px; color: #4b5563; line-height: 1.6;">
                            ${brief.actionItems.map(item => `<li style="margin-bottom: 8px;">${item}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            // Recommendations
            if (brief.recommendations && brief.recommendations.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 12px 0; color: #1f2937; font-size: 14px;">ðŸ’¡ Recommendations</h4>
                        <ul style="margin: 0; padding-left: 18px; color: #4b5563; line-height: 1.6;">
                            ${brief.recommendations.map(rec => `<li style="margin-bottom: 8px;">${rec}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            // Email Analysis
            if (brief.emailAnalysis && brief.emailAnalysis.length > 20) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 8px 0; color: #1f2937; font-size: 14px;">ðŸ“§ Email Context</h4>
                        <p style="margin: 0; color: #4b5563; line-height: 1.6; font-size: 12px;">${brief.emailAnalysis}</p>
                    </div>
                `;
            }

            // Document Analysis
            if (brief.documentAnalysis && brief.documentAnalysis.length > 20) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 8px 0; color: #1f2937; font-size: 14px;">ðŸ“„ Document Insights</h4>
                        <p style="margin: 0; color: #4b5563; line-height: 1.6; font-size: 12px;">${brief.documentAnalysis}</p>
                    </div>
                `;
            }

            // Company Research
            if (brief.companyResearch && brief.companyResearch.length > 20) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 8px 0; color: #1f2937; font-size: 14px;">ðŸ¢ Company Context</h4>
                        <p style="margin: 0; color: #4b5563; line-height: 1.6; font-size: 12px;">${brief.companyResearch}</p>
                    </div>
                `;
            }

            container.innerHTML = html || '<div style="text-align: center; color: #999; padding: 40px 20px;">No brief data available</div>';
        }

        function initializeInteractiveWebSocket() {
            // Dynamic WebSocket URL for Railway deployment
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsHost = window.location.host;
            interactivePrepWs = new WebSocket(`${wsProtocol}//${wsHost}`);

            interactivePrepWs.onopen = () => {
                console.log('âœ… Interactive prep WebSocket connected');

                // Send initial context
                interactivePrepWs.send(JSON.stringify({
                    type: 'interactive_prep_init',
                    meetingBrief: interactiveBrief
                }));

                updateChatStatus('Connected', '#10b981');
            };

            interactivePrepWs.onmessage = (event) => {
                const data = JSON.parse(event.data);

                if (data.type === 'interactive_response') {
                    // AI response received
                    addChatMessage('assistant', data.message, data.toolCall);

                    // Speak response if voice output enabled
                    const voiceEnabled = document.getElementById('voiceOutputToggle').checked;
                    if (voiceEnabled && data.message) {
                        speakText(data.message);
                    }
                }
                else if (data.type === 'interactive_error') {
                    addChatMessage('system', `Error: ${data.message}`);
                }
                // Voice Conversation events
                else if (data.type === 'voice_ready') {
                    console.log('âœ… Voice conversation ready');
                    updateChatStatus('Voice conversation ready', '#10b981');
                }
                else if (data.type === 'voice_transcript') {
                    // Live transcript from user
                    console.log('ðŸ“ Transcript:', data.text);
                    // Could show interim results in UI
                }
                else if (data.type === 'ai_response') {
                    // AI response in voice conversation mode
                    addChatMessage('assistant', data.text);
                    // Speak the response
                    speakText(data.text);
                }
                else if (data.type === 'stop_tts') {
                    // User interrupted - stop speaking
                    if (currentAIUtterance) {
                        window.speechSynthesis.cancel();
                        currentAIUtterance = null;
                    }
                }
                else if (data.type === 'state_change') {
                    // Update UI based on conversation state
                    const stateLabels = {
                        'listening': 'Listening...',
                        'processing': 'Thinking...',
                        'speaking': 'Speaking...',
                        'interrupted': 'Interrupted'
                    };
                    updateChatStatus(stateLabels[data.state] || 'Connected', '#10b981');
                }
                else if (data.type === 'function_call') {
                    // Web search indicator
                    console.log('ðŸ” Function call:', data.function, data.query);
                    updateChatStatus(`Searching: ${data.query}`, '#3b82f6');
                }
            };

            interactivePrepWs.onerror = (error) => {
                console.error('Interactive prep WebSocket error:', error);
                updateChatStatus('Connection error', '#ef4444');
            };

            interactivePrepWs.onclose = () => {
                console.log('Interactive prep WebSocket closed');
                updateChatStatus('Disconnected', '#6b7280');
            };
        }

        function closeInteractivePrep() {
            // Stop any ongoing speech
            stopTTS();

            // Stop voice input if active
            if (isVoiceActive) {
                if (voiceConversationMode) {
                    stopVoiceConversation();
                } else {
                    stopChatVoiceInput();
                }
            }

            // Close WebSocket
            if (interactivePrepWs && interactivePrepWs.readyState === WebSocket.OPEN) {
                interactivePrepWs.close();
            }

            // Clear state to prevent data leakage
            interactivePrepWs = null;
            interactiveBrief = null;
            meetingBrief = null;
            currentMeetingId = null;
            chatMessagesArray = [];
            conversationHistory = [];
            voiceConversationMode = false;

            // Clear chat UI
            document.getElementById('chatHistory').innerHTML = `
                <div class="chat-placeholder" style="text-align: center; color: #999; padding: 40px 20px;">
                    <div style="font-size: 24px; margin-bottom: 12px;">ðŸ’¬</div>
                    <div>Ask me anything about this meeting...</div>
                    <div style="font-size: 13px; margin-top: 8px;">Try: "Tell me about the attendees" or "What documents are attached?"</div>
                </div>
            `;
            document.getElementById('chatInput').value = '';

            // Close overlay
            document.getElementById('interactivePrepOverlay').style.display = 'none';
        }

        function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();

            if (!message) return;
            if (!interactivePrepWs || interactivePrepWs.readyState !== WebSocket.OPEN) {
                alert('Not connected to server');
                return;
            }

            // Add user message to UI
            addChatMessage('user', message);

            // Add to conversation history
            conversationHistory.push({ role: 'user', content: message });

            // Clear input
            input.value = '';

            // Show loading indicator
            showChatLoading();

            // Send to backend
            interactivePrepWs.send(JSON.stringify({
                type: 'interactive_message',
                message: message,
                conversationHistory: conversationHistory
            }));
        }

        async function toggleVoiceInput() {
            if (!isVoiceActive) {
                // Check if we should use conversation mode or single utterance mode
                // Use conversation mode by default for better UX
                voiceConversationMode = true;

                if (voiceConversationMode) {
                    await startVoiceConversation();
                } else {
                    await startChatVoiceInput();
                }
            } else {
                if (voiceConversationMode) {
                    stopVoiceConversation();
                } else {
                    stopChatVoiceInput();
                }
            }
        }

        async function startChatVoiceInput() {
            try {
                const button = document.getElementById('voiceInputBtn');
                button.style.background = '#ef4444';
                button.textContent = 'âºï¸';
                updateChatStatus('Listening...', '#ef4444');

                // Request microphone access
                chatMediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });

                // Set up audio context
                chatAudioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                const source = chatAudioContext.createMediaStreamSource(chatMediaStream);
                chatScriptProcessor = chatAudioContext.createScriptProcessor(4096, 1, 1);

                chatScriptProcessor.onaudioprocess = (e) => {
                    if (!isVoiceActive) return;

                    const float32Audio = e.inputBuffer.getChannelData(0);
                    const int16Audio = new Int16Array(float32Audio.length);

                    for (let i = 0; i < float32Audio.length; i++) {
                        const s = Math.max(-1, Math.min(1, float32Audio[i]));
                        int16Audio[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }

                    if (interactivePrepWs && interactivePrepWs.readyState === WebSocket.OPEN) {
                        interactivePrepWs.send(JSON.stringify({
                            type: 'interactive_voice_data',
                            audio: Array.from(int16Audio)
                        }));
                    }
                };

                source.connect(chatScriptProcessor);
                chatScriptProcessor.connect(chatAudioContext.destination);

                isVoiceActive = true;

                // Send voice start signal
                if (interactivePrepWs && interactivePrepWs.readyState === WebSocket.OPEN) {
                    interactivePrepWs.send(JSON.stringify({
                        type: 'interactive_voice_start'
                    }));
                }

            } catch (error) {
                console.error('Error starting voice input:', error);
                alert('Failed to access microphone: ' + error.message);
                stopChatVoiceInput();
            }
        }

        function stopChatVoiceInput() {
            const button = document.getElementById('voiceInputBtn');
            button.style.background = 'var(--color-primary)';
            button.textContent = 'ðŸŽ¤';
            updateChatStatus('Connected', '#10b981');

            isVoiceActive = false;

            if (chatScriptProcessor) {
                chatScriptProcessor.disconnect();
                chatScriptProcessor = null;
            }

            if (chatAudioContext) {
                chatAudioContext.close();
                chatAudioContext = null;
            }

            if (chatMediaStream) {
                chatMediaStream.getTracks().forEach(track => track.stop());
                chatMediaStream = null;
            }

            // Send voice stop signal
            if (interactivePrepWs && interactivePrepWs.readyState === WebSocket.OPEN) {
                interactivePrepWs.send(JSON.stringify({
                    type: 'interactive_voice_stop'
                }));
            }
        }

        // ===== VOICE CONVERSATION MODE (Continuous back-and-forth) =====

        async function startVoiceConversation() {
            try {
                const button = document.getElementById('voiceInputBtn');
                button.style.background = '#ef4444';
                button.textContent = 'ðŸ”´ Stop';
                updateChatStatus('Starting voice conversation...', '#ef4444');

                // Request microphone access
                chatMediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // Set up audio context for streaming
                chatAudioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                const source = chatAudioContext.createMediaStreamSource(chatMediaStream);
                chatScriptProcessor = chatAudioContext.createScriptProcessor(4096, 1, 1);

                chatScriptProcessor.onaudioprocess = (e) => {
                    if (!isVoiceActive) return;

                    const float32Audio = e.inputBuffer.getChannelData(0);
                    const int16Audio = new Int16Array(float32Audio.length);

                    // Convert float32 to int16
                    for (let i = 0; i < float32Audio.length; i++) {
                        const s = Math.max(-1, Math.min(1, float32Audio[i]));
                        int16Audio[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }

                    // Stream audio to backend
                    if (interactivePrepWs && interactivePrepWs.readyState === WebSocket.OPEN) {
                        // Convert to base64 for transmission
                        const audioArray = Array.from(int16Audio);
                        const base64Audio = btoa(String.fromCharCode.apply(null, new Uint8Array(int16Audio.buffer)));

                        interactivePrepWs.send(JSON.stringify({
                            type: 'voice_conversation_audio',
                            audio: base64Audio
                        }));
                    }
                };

                source.connect(chatScriptProcessor);
                chatScriptProcessor.connect(chatAudioContext.destination);

                isVoiceActive = true;

                // Initialize voice conversation on backend
                if (interactivePrepWs && interactivePrepWs.readyState === WebSocket.OPEN) {
                    interactivePrepWs.send(JSON.stringify({
                        type: 'voice_conversation_start'
                    }));
                }

                console.log('âœ… Voice conversation started');

            } catch (error) {
                console.error('Error starting voice conversation:', error);
                alert('Failed to start voice conversation: ' + error.message);
                stopVoiceConversation();
            }
        }

        function stopVoiceConversation() {
            const button = document.getElementById('voiceInputBtn');
            button.style.background = 'var(--color-primary)';
            button.textContent = 'ðŸŽ¤';
            updateChatStatus('Connected', '#10b981');

            isVoiceActive = false;

            // Stop audio processing
            if (chatScriptProcessor) {
                chatScriptProcessor.disconnect();
                chatScriptProcessor = null;
            }

            if (chatAudioContext) {
                chatAudioContext.close();
                chatAudioContext = null;
            }

            if (chatMediaStream) {
                chatMediaStream.getTracks().forEach(track => track.stop());
                chatMediaStream = null;
            }

            // Stop any ongoing speech
            if (currentAIUtterance) {
                window.speechSynthesis.cancel();
                currentAIUtterance = null;
            }

            // Notify backend to stop voice conversation
            if (interactivePrepWs && interactivePrepWs.readyState === WebSocket.OPEN) {
                interactivePrepWs.send(JSON.stringify({
                    type: 'voice_conversation_stop'
                }));
            }

            console.log('ðŸ›‘ Voice conversation stopped');
        }

        // ==================== Voice Prep Mode Functions ====================

        let voicePrepWs = null;
        let voicePrepMediaStream = null;
        let voicePrepAudioContext = null;
        let voicePrepScriptProcessor = null;
        let voicePrepActive = false;
        let voicePrepTimerInterval = null;

        // Audio streaming state for Deepgram Aura TTS
        let voicePrepPlaybackContext = null;
        let voicePrepAudioQueue = [];
        let voicePrepIsPlaying = false;
        let voicePrepAudioSources = []; // Track active audio sources for cancellation
        let voicePrepNextStartTime = 0;

        async function startVoicePrep() {
            console.log('ðŸŽ™ï¸ startVoicePrep called');
            
            // Use stored brief if available (from meeting prep or day prep)
            const briefToUse = window.currentMeetingBrief || meetingBrief;
            console.log('Brief to use:', briefToUse);

            // Check if prep has been generated
            if (!briefToUse) {
                alert('Please generate a meeting prep first by clicking "Prep Me" or use Day Prep.');
                return;
            }

            console.log('Opening voice prep modal...');

            // Show the modal
            const modal = document.getElementById('voicePrepOverlay');
            console.log('Modal element:', modal);

            if (!modal) {
                alert('Voice Prep modal not found! Please refresh the page.');
                return;
            }

            modal.style.display = 'flex';
            console.log('Modal display set to flex');

            // Set meeting details
            const brief = briefToUse || meetingBrief;
            const meetingTitle = brief.summary || brief.title || (brief.date ? `Day Prep for ${new Date(brief.date).toLocaleDateString()}` : 'Meeting');
            document.getElementById('voicePrepMeetingTitle').textContent = meetingTitle;
            const startDate = brief.start?.dateTime || brief.start?.date || (brief.date ? new Date(brief.date).toISOString() : null);
            document.getElementById('voicePrepMeetingTime').textContent = startDate ? new Date(startDate).toLocaleString() : (brief.date ? new Date(brief.date).toLocaleDateString() : 'Time not specified');

            console.log('Voice prep modal opened successfully');
        }

        function closeVoicePrep() {
            // Stop session if active
            if (voicePrepActive) {
                stopVoicePrepSession();
            }

            // Close modal
            document.getElementById('voicePrepOverlay').style.display = 'none';

            // Reset UI
            document.getElementById('voicePrepTimer').textContent = '2:00';
            document.getElementById('voicePrepStatus').textContent = 'Ready to start your briefing';
            document.getElementById('voicePrepTranscript').innerHTML = `
                <div style="text-align: center; color: #999; padding: 40px 20px;">
                    <div style="font-size: 24px; margin-bottom: 12px;">ðŸŽ™ï¸</div>
                    <div>Your 2-minute voice briefing will appear here...</div>
                    <div style="font-size: 13px; margin-top: 8px;">The AI will guide you through attendees, insights, agenda, and recommendations. You can interrupt anytime to ask questions.</div>
                </div>
            `;
        }

        async function startVoicePrepSession() {
            try {
                // Request microphone access
                voicePrepMediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // Set up audio context for streaming
                voicePrepAudioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                const source = voicePrepAudioContext.createMediaStreamSource(voicePrepMediaStream);
                voicePrepScriptProcessor = voicePrepAudioContext.createScriptProcessor(4096, 1, 1);

                // Connect to WebSocket
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}`;
                voicePrepWs = new WebSocket(wsUrl);

                    voicePrepWs.onopen = async () => {
                    console.log('ðŸŽ™ï¸ Voice prep WebSocket connected');

                    // Initialize/resume audio playback context for user interaction
                    if (!voicePrepPlaybackContext) {
                        voicePrepPlaybackContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
                        voicePrepNextStartTime = voicePrepPlaybackContext.currentTime;
                        console.log('ðŸ”Š Initialized audio playback context');
                    }
                    // Resume AudioContext if suspended (required for autoplay policies)
                    if (voicePrepPlaybackContext.state === 'suspended') {
                        try {
                            await voicePrepPlaybackContext.resume();
                            console.log('ðŸ”Š Resumed AudioContext for playback');
                        } catch (resumeError) {
                            console.warn('Failed to resume AudioContext:', resumeError);
                        }
                    }
                    console.log('AudioContext state:', voicePrepPlaybackContext.state);

                    // Send voice_prep_start message
                    // Use stored brief from window (set in startVoicePrep)
                    const brief = window.currentMeetingBrief || meetingBrief;
                    // For day prep, use narrative as the brief content
                    const voicePrepBrief = brief && brief.narrative ? {
                        summary: brief.summary || 'Day Prep',
                        narrative: brief.narrative,
                        meetings: brief.meetings || [],
                        date: brief.date
                    } : brief;
                    
                    voicePrepWs.send(JSON.stringify({
                        type: 'voice_prep_start',
                        brief: voicePrepBrief
                    }));

                    voicePrepActive = true;

                    // Update UI
                    document.getElementById('voicePrepStartBtn').style.display = 'none';
                    document.getElementById('voicePrepStopBtn').style.display = 'block';
                    document.getElementById('voicePrepStatus').textContent = 'Briefing in progress...';

                    // Start audio streaming
                    voicePrepScriptProcessor.onaudioprocess = (e) => {
                        if (!voicePrepActive) return;

                        const float32Audio = e.inputBuffer.getChannelData(0);
                        const int16Audio = new Int16Array(float32Audio.length);

                        // Convert float32 to int16
                        for (let i = 0; i < float32Audio.length; i++) {
                            const s = Math.max(-1, Math.min(1, float32Audio[i]));
                            int16Audio[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                        }

                        // Stream audio to backend
                        if (voicePrepWs && voicePrepWs.readyState === WebSocket.OPEN) {
                            const base64Audio = btoa(String.fromCharCode.apply(null, new Uint8Array(int16Audio.buffer)));
                            voicePrepWs.send(JSON.stringify({
                                type: 'voice_prep_audio',
                                audio: base64Audio
                            }));
                        }
                    };

                    source.connect(voicePrepScriptProcessor);
                    voicePrepScriptProcessor.connect(voicePrepAudioContext.destination);
                };

                voicePrepWs.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    handleVoicePrepMessage(data);
                };

                voicePrepWs.onerror = (error) => {
                    console.error('Voice prep WebSocket error:', error);
                    alert('Connection error. Please try again.');
                    stopVoicePrepSession();
                };

                voicePrepWs.onclose = () => {
                    console.log('ðŸ›‘ Voice prep WebSocket closed');
                    stopVoicePrepSession();
                };

            } catch (error) {
                console.error('Error starting voice prep session:', error);
                alert('Failed to start voice prep: ' + error.message);
                stopVoicePrepSession();
            }
        }

        function stopVoicePrepSession() {
            voicePrepActive = false;

            // Stop audio processing
            if (voicePrepScriptProcessor) {
                voicePrepScriptProcessor.disconnect();
                voicePrepScriptProcessor = null;
            }

            if (voicePrepAudioContext) {
                voicePrepAudioContext.close();
                voicePrepAudioContext = null;
            }

            if (voicePrepMediaStream) {
                voicePrepMediaStream.getTracks().forEach(track => track.stop());
                voicePrepMediaStream = null;
            }

            // Clean up playback context
            if (voicePrepPlaybackContext) {
                // Stop all active sources before closing
                stopAllVoicePrepAudio();
                voicePrepPlaybackContext.close();
                voicePrepPlaybackContext = null;
            }
            voicePrepAudioQueue = [];
            voicePrepIsPlaying = false;
            voicePrepNextStartTime = 0;
            voicePrepAudioSources = [];

            // Stop timer
            if (voicePrepTimerInterval) {
                clearInterval(voicePrepTimerInterval);
                voicePrepTimerInterval = null;
            }

            // Notify backend
            if (voicePrepWs && voicePrepWs.readyState === WebSocket.OPEN) {
                voicePrepWs.send(JSON.stringify({
                    type: 'voice_prep_stop'
                }));
                voicePrepWs.close();
            }

            voicePrepWs = null;

            // Update UI
            document.getElementById('voicePrepStartBtn').style.display = 'block';
            document.getElementById('voicePrepStopBtn').style.display = 'none';
            document.getElementById('voicePrepStatus').textContent = 'Session ended';

            console.log('ðŸ›‘ Voice prep session stopped');
        }

        function handleVoicePrepMessage(data) {
            switch (data.type) {
                case 'voice_prep_ready':
                case 'realtime_ready':
                    console.log('âœ… Voice prep ready');
                    document.getElementById('voicePrepStatus').textContent = data.message || 'Starting briefing...';
                    break;

                case 'voice_prep_transcript':
                    // Display user or AI transcript
                    addVoicePrepTranscript(data.speaker || 'You', data.text, data.isFinal);
                    break;

                case 'voice_prep_response':
                    // AI response text
                    addVoicePrepTranscript('AI', data.text, true);
                    break;

                case 'voice_prep_audio':
                    // Legacy: Play complete audio (for OpenAI TTS)
                    playVoicePrepAudio(data.audio);
                    break;

                case 'voice_prep_audio_chunk':
                    // NEW: Stream audio chunks from Deepgram Aura
                    playVoicePrepAudioChunk(data.audio);
                    break;

                case 'realtime_audio':
                    // NEW: Stream PCM16 audio chunks from OpenAI Realtime API
                    playRealtimeAudioChunk(data.audio);
                    break;

                case 'realtime_audio_done':
                    // Signal end of Realtime API audio stream
                    console.log('ðŸ”Š Realtime API audio stream complete');
                    voicePrepIsPlaying = false;
                    break;

                case 'voice_prep_audio_complete':
                    // Signal end of audio stream
                    console.log('ðŸ”Š Audio stream complete');
                    break;

                case 'voice_prep_time_update':
                    // Update timer
                    updateVoicePrepTimer(data.elapsed, data.total);
                    break;

                case 'voice_prep_section_change':
                    // Section transition
                    document.getElementById('voicePrepStatus').textContent = `Section: ${data.section}`;
                    break;

                case 'voice_prep_interrupted':
                    document.getElementById('voicePrepStatus').textContent = data.message || 'Paused for your question';
                    // Stop any ongoing audio playback when interrupted
                    stopAllVoicePrepAudio();
                    break;

                case 'realtime_response_cancelled':
                    console.log('ðŸ›‘ AI response cancelled - ready for user input');
                    document.getElementById('voicePrepStatus').textContent = 'Listening...';
                    // Stop any ongoing audio playback
                    stopAllVoicePrepAudio();
                    break;

                case 'error':
                    console.error('Voice prep error:', data.message);
                    document.getElementById('voicePrepStatus').textContent = 'Error: ' + data.message;
                    break;
            }
        }

        // Track last transcript to prevent duplicates
        // Track recent transcripts for deduplication (store last 10 transcripts)
        let recentTranscripts = [];
        const MAX_RECENT_TRANSCRIPTS = 10;
        const DEDUP_WINDOW_MS = 2000; // 2 second window for deduplication

        function addVoicePrepTranscript(speaker, text, isFinal) {
            const transcriptDiv = document.getElementById('voicePrepTranscript');

            // Remove placeholder if exists
            const placeholder = transcriptDiv.querySelector('div[style*="text-align: center"]');
            if (placeholder) {
                transcriptDiv.innerHTML = '';
            }

            // Improved deduplication: Check against all recent transcripts
            const now = Date.now();
            if (isFinal && text.trim()) {
                // Check if this exact transcript was added recently
                const isDuplicate = recentTranscripts.some(transcript => {
                    return transcript.text === text.trim() && 
                           transcript.speaker === speaker && 
                           (now - transcript.timestamp) < DEDUP_WINDOW_MS;
                });

                if (isDuplicate) {
                    console.log('Duplicate transcript detected, skipping', { speaker, text: text.substring(0, 50) });
                return;
            }

                // Add to recent transcripts list
                recentTranscripts.push({
                    text: text.trim(),
                    speaker: speaker,
                    timestamp: now
                });

                // Keep only recent transcripts (remove old ones)
                recentTranscripts = recentTranscripts.filter(t => (now - t.timestamp) < DEDUP_WINDOW_MS);
                
                // Limit to max size
                if (recentTranscripts.length > MAX_RECENT_TRANSCRIPTS) {
                    recentTranscripts = recentTranscripts.slice(-MAX_RECENT_TRANSCRIPTS);
                }
            }

            // Check if we should update the last message (for interim results)
            if (!isFinal && transcriptDiv.lastChild && transcriptDiv.lastChild.dataset.speaker === speaker && transcriptDiv.lastChild.dataset.isFinal !== 'true') {
                // Update existing interim message
                transcriptDiv.lastChild.innerHTML = `<strong>${speaker}:</strong> ${text}`;
            } else {
                // Create new message
                const messageDiv = document.createElement('div');
                messageDiv.dataset.speaker = speaker;
                messageDiv.dataset.isFinal = isFinal ? 'true' : 'false';
                messageDiv.style.marginBottom = '12px';
                messageDiv.style.color = speaker === 'You' ? '#2563eb' : '#059669';
                messageDiv.innerHTML = `<strong>${speaker}:</strong> ${text}`;
                transcriptDiv.appendChild(messageDiv);
            }

            // Auto-scroll to bottom
            transcriptDiv.scrollTop = transcriptDiv.scrollHeight;
        }

        async function playVoicePrepAudio(base64Audio) {
            try {
                // Decode base64 to array buffer
                const binaryString = atob(base64Audio);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                // Create audio context and play
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await audioContext.decodeAudioData(bytes.buffer);
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                source.start(0);

                console.log('ðŸ”Š Playing voice prep audio');
            } catch (error) {
                console.error('Error playing voice prep audio:', error);
            }
        }

        async function playVoicePrepAudioChunk(base64Audio) {
            try {
                // Initialize playback context if needed
                if (!voicePrepPlaybackContext) {
                    voicePrepPlaybackContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
                    voicePrepNextStartTime = voicePrepPlaybackContext.currentTime;
                    console.log('ðŸ”Š Initialized audio playback context for streaming');
                }

                // Decode base64 to array buffer
                const binaryString = atob(base64Audio);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                // Decode audio chunk
                const audioBuffer = await voicePrepPlaybackContext.decodeAudioData(bytes.buffer);

                // Schedule this chunk for playback
                const source = voicePrepPlaybackContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(voicePrepPlaybackContext.destination);

                // Schedule at the next available time for seamless playback
                const currentTime = voicePrepPlaybackContext.currentTime;
                const startTime = Math.max(currentTime, voicePrepNextStartTime);
                source.start(startTime);

                // Update next start time
                voicePrepNextStartTime = startTime + audioBuffer.duration;

                if (!voicePrepIsPlaying) {
                    voicePrepIsPlaying = true;
                    console.log('ðŸ”Š Started streaming audio playback');
                }

            } catch (error) {
                console.error('Error playing voice prep audio chunk:', error);
            }
        }

        // Play PCM16 audio chunks from OpenAI Realtime API
        async function playRealtimeAudioChunk(base64Audio) {
            try {
                // Set playing flag at start - cancellation is handled by stopAllVoicePrepAudio()
                if (!voicePrepIsPlaying) {
                    voicePrepIsPlaying = true;
                }
                
                // Initialize playback context if needed (Realtime API uses 24kHz PCM16)
                if (!voicePrepPlaybackContext) {
                    voicePrepPlaybackContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
                    voicePrepNextStartTime = voicePrepPlaybackContext.currentTime;
                    console.log('ðŸ”Š Initialized audio playback context for Realtime API');
                }

                // Resume AudioContext if suspended (required for autoplay policies)
                if (voicePrepPlaybackContext.state === 'suspended') {
                    await voicePrepPlaybackContext.resume();
                    console.log('ðŸ”Š Resumed AudioContext');
                }

                // Decode base64 to array buffer
                const binaryString = atob(base64Audio);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                // Convert PCM16 (little-endian) to Float32Array
                // PCM16 is 16-bit signed integers, 2 bytes per sample
                const sampleCount = Math.floor(bytes.length / 2);
                if (sampleCount === 0) {
                    console.warn('Empty audio chunk received, skipping');
                    return;
                }

                const float32Data = new Float32Array(sampleCount);
                const dataView = new DataView(bytes.buffer);
                
                // Read as little-endian 16-bit signed integers
                for (let i = 0; i < sampleCount; i++) {
                    const int16Value = dataView.getInt16(i * 2, true); // true = little-endian
                    // Convert from -32768 to 32767 range to -1.0 to 1.0 range
                    float32Data[i] = Math.max(-1, Math.min(1, int16Value / 32768.0));
                }

                // Create audio buffer from float32 data
                const audioBuffer = voicePrepPlaybackContext.createBuffer(1, float32Data.length, 24000);
                audioBuffer.copyToChannel(float32Data, 0);

                // Schedule this chunk for playback
                const source = voicePrepPlaybackContext.createBufferSource();
                source.buffer = audioBuffer;
                source.playbackRate = 2.0; // Speed up voice by 2x
                source.connect(voicePrepPlaybackContext.destination);

                // Track this source so we can stop it if cancellation happens
                voicePrepAudioSources.push(source);
                
                // Clean up source when it finishes playing
                source.onended = () => {
                    const index = voicePrepAudioSources.indexOf(source);
                    if (index > -1) {
                        voicePrepAudioSources.splice(index, 1);
                    }
                };

                // Schedule at the next available time for seamless playback
                const currentTime = voicePrepPlaybackContext.currentTime;
                const startTime = Math.max(currentTime, voicePrepNextStartTime);
                source.start(startTime);

                // Update next start time
                voicePrepNextStartTime = startTime + audioBuffer.duration;

                // Log first chunk for debugging
                if (voicePrepAudioSources.length === 1) {
                    console.log('ðŸ”Š Started Realtime API audio playback', { 
                        chunkSize: bytes.length, 
                        samples: float32Data.length,
                        duration: audioBuffer.duration.toFixed(3) + 's',
                        contextState: voicePrepPlaybackContext.state
                    });
                } else {
                    console.debug('ðŸ”Š Playing audio chunk', { 
                        samples: float32Data.length,
                        duration: audioBuffer.duration.toFixed(3) + 's',
                        startTime: startTime.toFixed(3)
                    });
                }

            } catch (error) {
                console.error('Error playing Realtime API audio chunk:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    base64Length: base64Audio?.length
                });
            }
        }

        // Stop all active audio playback (for cancellation)
        function stopAllVoicePrepAudio() {
            if (!voicePrepIsPlaying && voicePrepAudioSources.length === 0) {
                return; // Already stopped
            }

            console.log('ðŸ›‘ Stopping all voice prep audio playback', { 
                sourcesCount: voicePrepAudioSources.length 
            });

            // Stop all active audio sources
            voicePrepAudioSources.forEach((source, index) => {
                try {
                    source.stop();
                } catch (error) {
                    // Source may have already finished or been stopped
                    console.debug('Could not stop audio source', { index, error: error.message });
                }
            });
            voicePrepAudioSources = [];

            // Reset playback state
            voicePrepIsPlaying = false;
            voicePrepAudioQueue = [];

            // Reset timing to current time to prevent future scheduling
            if (voicePrepPlaybackContext) {
                voicePrepNextStartTime = voicePrepPlaybackContext.currentTime;
            } else {
                voicePrepNextStartTime = 0;
            }

            console.log('âœ… All voice prep audio stopped');
        }

        function updateVoicePrepTimer(elapsed, total) {
            const remaining = Math.max(0, total - elapsed);
            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('voicePrepTimer').textContent = display;
        }

        // ==================== End Voice Prep Mode Functions ====================

        function addChatMessage(role, content, toolCall = null) {
            const chatHistory = document.getElementById('chatHistory');
            const placeholder = chatHistory.querySelector('.chat-placeholder');
            if (placeholder) placeholder.remove();

            // Remove loading indicator
            const loading = chatHistory.querySelector('.chat-loading-message');
            if (loading) loading.remove();

            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}`;

            if (role === 'system') {
                messageDiv.innerHTML = `
                    <div class="chat-bubble" style="background: #fef3c7; color: #92400e; border: 1px solid #fbbf24;">
                        ${content}
                    </div>
                `;
            } else {
                let bubbleContent = content;

                // Add tool call indicator if present
                if (toolCall) {
                    bubbleContent = `
                        <div class="chat-tool-call" style="background: #f0f9ff; border-left: 3px solid #3b82f6; padding: 8px; margin-bottom: 8px; border-radius: 6px; font-size: 13px;">
                            <strong>ðŸ” Web Search:</strong> ${toolCall.query || 'Searching...'}
                        </div>
                        ${content}
                    `;
                }

                messageDiv.innerHTML = `
                    <div class="chat-bubble">${bubbleContent}</div>
                    <div class="chat-timestamp" style="font-size: 11px; color: #9ca3af; margin-top: 4px;">
                        ${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                    </div>
                `;
            }

            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;

            // Add to history if not system message
            if (role !== 'system') {
                chatMessagesArray.push({ role, content });
            }
        }

        function showChatLoading() {
            const chatHistory = document.getElementById('chatHistory');

            // Remove existing loading indicator
            const existing = chatHistory.querySelector('.chat-loading-message');
            if (existing) existing.remove();

            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'chat-message assistant chat-loading-message';
            loadingDiv.innerHTML = `
                <div class="chat-loading">
                    <div class="chat-loading-dot" style="animation-delay: 0s"></div>
                    <div class="chat-loading-dot" style="animation-delay: 0.2s"></div>
                    <div class="chat-loading-dot" style="animation-delay: 0.4s"></div>
                </div>
            `;
            chatHistory.appendChild(loadingDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        function updateChatStatus(text, color) {
            const status = document.getElementById('chatStatus');
            status.textContent = text;
            status.style.color = color;
        }

        // Audio queue for TTS playback
        let ttsAudioQueue = [];
        let currentTTSAudio = null;
        let isTTSPlaying = false;

        async function speakText(text) {
            // Stop any ongoing speech
            stopTTS();

            try {
                isSpeaking = true;
                updateChatStatus('Generating speech...', '#3b82f6');

                // Call our backend TTS endpoint (which proxies OpenAI)
                const response = await fetch('/api/tts', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ text })
                });

                if (!response.ok) {
                    throw new Error('TTS generation failed');
                }

                // Get audio blob
                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);

                // Play audio
                currentTTSAudio = new Audio(audioUrl);
                currentAIUtterance = currentTTSAudio;

                currentTTSAudio.onplay = () => {
                    isSpeaking = true;
                    isTTSPlaying = true;
                    updateChatStatus('Speaking...', '#10b981');
                };

                currentTTSAudio.onended = () => {
                    isSpeaking = false;
                    isTTSPlaying = false;
                    currentTTSAudio = null;
                    currentAIUtterance = null;
                    URL.revokeObjectURL(audioUrl);
                    updateChatStatus('Connected', '#10b981');
                };

                currentTTSAudio.onerror = (error) => {
                    console.error('Audio playback error:', error);
                    isSpeaking = false;
                    isTTSPlaying = false;
                    currentTTSAudio = null;
                    currentAIUtterance = null;
                    updateChatStatus('Connected', '#10b981');
                };

                await currentTTSAudio.play();

            } catch (error) {
                console.error('TTS error:', error);
                // Fallback to Web Speech API
                console.log('Falling back to Web Speech API');
                fallbackToWebSpeech(text);
            }
        }

        function fallbackToWebSpeech(text) {
            window.speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1.1;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            utterance.onstart = () => {
                isSpeaking = true;
                currentAIUtterance = utterance;
            };

            utterance.onend = () => {
                isSpeaking = false;
                currentAIUtterance = null;
            };

            utterance.onerror = (error) => {
                console.error('Speech synthesis error:', error);
                isSpeaking = false;
                currentAIUtterance = null;
            };

            window.speechSynthesis.speak(utterance);
        }

        function stopTTS() {
            // Stop HTML5 audio
            if (currentTTSAudio) {
                currentTTSAudio.pause();
                currentTTSAudio.currentTime = 0;
                currentTTSAudio = null;
            }

            // Stop Web Speech API fallback
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }

            currentAIUtterance = null;
            isSpeaking = false;
            isTTSPlaying = false;
        }

        // Export functions
        window.startInteractivePrep = startInteractivePrep;
        window.closeInteractivePrep = closeInteractivePrep;
        window.sendChatMessage = sendChatMessage;
        window.toggleVoiceInput = toggleVoiceInput;

        // Voice Prep Mode functions
        window.startVoicePrep = startVoicePrep;
        window.closeVoicePrep = closeVoicePrep;

        // ==================== Prep View Functions ====================
        let prepViewActive = false;

        function togglePrepView() {
            prepViewActive = !prepViewActive;
            const prepViewContainer = document.getElementById('prepViewContainer');
            const eventsContainer = document.getElementById('eventsContainer');
            const toggleButton = document.getElementById('prepViewToggle');
            const datePicker = document.getElementById('chatModeDatePicker');

            if (prepViewActive) {
                prepViewContainer.classList.add('active');
                eventsContainer.classList.remove('visible');
                toggleButton.classList.add('active');
                toggleButton.textContent = 'Calendar View';
                
                // Always set default date to today when opening prep view
                const today = new Date().toISOString().split('T')[0];
                datePicker.value = today;
                console.log('Prep view opened - date picker set to:', today);
            } else {
                prepViewContainer.classList.remove('active');
                eventsContainer.classList.add('visible');
                toggleButton.classList.remove('active');
                toggleButton.textContent = 'Prep View';
            }
        }

        // ==================== Chat Panel Functions ====================
        let chatPanelActive = false;
        let chatPanelWs = null;
        let reminderInterval = null;
        let shownReminders = new Set();
        let reminderWindowMinutes = 15;

        function toggleChatPanel() {
            chatPanelActive = !chatPanelActive;
            const chatPanelContainer = document.getElementById('chatPanelContainer');
            const toggleButton = document.getElementById('chatPanelToggle');
            const eventsContainer = document.getElementById('eventsContainer');
            const prepViewContainer = document.getElementById('prepViewContainer');

            if (chatPanelActive) {
                chatPanelContainer.classList.add('active');
                eventsContainer.classList.remove('visible');
                prepViewContainer.classList.remove('active');
                toggleButton.classList.add('active');
                
                // Initialize chat panel
                initializeChatPanel();
                
                // Start reminder polling
                startReminderPolling();
            } else {
                chatPanelContainer.classList.remove('active');
                eventsContainer.classList.add('visible');
                toggleButton.classList.remove('active');
                
                // Stop reminder polling
                stopReminderPolling();
                
                // Close WebSocket if open
                if (chatPanelWs) {
                    chatPanelWs.close();
                    chatPanelWs = null;
                }
            }
        }

        async function initializeChatPanel() {
            // Clear messages area
            const messagesArea = document.getElementById('chatMessagesArea');
            messagesArea.innerHTML = '';
            
            // Connect WebSocket
            await connectChatPanelWebSocket();
            
            // Fetch today's meetings and generate initial update
            try {
                const today = new Date().toISOString().split('T')[0];
                const response = await fetch(`/api/meetings-for-day?date=${today}`);
                const data = await response.json();
                const meetings = data.meetings || [];
                
                if (meetings && meetings.length > 0) {
                    // Generate initial update using OpenAI
                    const updateMessage = await generateInitialUpdate(meetings);
                    addChatMessage('assistant', updateMessage);
                } else {
                    addChatMessage('assistant', "You have no meetings scheduled for today. I'm here to help whenever you need me!");
                }
            } catch (error) {
                console.error('Error fetching meetings:', error);
                addChatMessage('assistant', "Hi! I'm Shadow, your executive assistant. How can I help you today?");
            }
        }

        async function connectChatPanelWebSocket() {
            return new Promise((resolve, reject) => {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}`;
                
                chatPanelWs = new WebSocket(wsUrl);
                
                chatPanelWs.onopen = () => {
                    console.log('Chat panel WebSocket connected');
                    updateChatStatus('Connected', '#10b981');
                    resolve();
                };
                
                chatPanelWs.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'chat_panel_response') {
                            // stripMarkdown is called inside addChatMessage
                            addChatMessage('assistant', data.message);
                        }
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                    }
                };
                
                chatPanelWs.onerror = (error) => {
                    console.error('Chat panel WebSocket error:', error);
                    updateChatStatus('Connection error', '#ef4444');
                    reject(error);
                };
                
                chatPanelWs.onclose = () => {
                    console.log('Chat panel WebSocket closed');
                    updateChatStatus('Disconnected', '#9ca3af');
                };
            });
        }

        async function generateInitialUpdate(meetings) {
            try {
                const meetingList = meetings.map((m, idx) => {
                    // Handle time display - check if it's an all-day event (date only) vs timed event
                    const startTime = m.start?.dateTime || m.start?.date || m.start;
                    let timeStr = 'Time TBD';
                    
                    if (startTime) {
                        if (m.start?.dateTime) {
                            // Timed event - show time
                            timeStr = new Date(startTime).toLocaleTimeString('en-US', {
                                hour: 'numeric',
                                minute: '2-digit',
                                hour12: true
                            });
                        } else if (m.start?.date) {
                            // All-day event - show "All day"
                            timeStr = 'All day';
                        } else if (typeof startTime === 'string') {
                            // Try parsing as date string
                            const parsedDate = new Date(startTime);
                            if (!isNaN(parsedDate.getTime())) {
                                timeStr = parsedDate.toLocaleTimeString('en-US', {
                                    hour: 'numeric',
                                    minute: '2-digit',
                                    hour12: true
                                });
                            }
                        }
                    }
                    
                    const attendees = (m.attendees || []).map(a => a.displayName || a.email).join(', ');
                    return `${idx + 1}. ${m.summary || 'Untitled Meeting'} at ${timeStr}${attendees ? ` with ${attendees}` : ''}`;
                }).join('\n');

                // Use the REST endpoint instead of calling OpenAI directly
                const response = await fetch('/api/chat-panel', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: `Generate a quick update about today's meetings:\n\n${meetingList}`
                    })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const data = await response.json();
                return data.message || `You have ${meetings.length} meeting${meetings.length !== 1 ? 's' : ''} scheduled for today. Ready to help you prepare!`;
            } catch (error) {
                console.error('Error generating initial update:', error);
                // Fallback to simple message
                return `You have ${meetings.length} meeting${meetings.length !== 1 ? 's' : ''} scheduled for today. Ready to help you prepare!`;
            }
        }

        function sendChatPanelMessage() {
            const input = document.getElementById('chatPanelInput');
            const message = input.value.trim();

            if (!message) return;

            // Add user message to UI
            addChatMessage('user', message);

            // Clear input
            input.value = '';

            // Send to server via WebSocket
            if (chatPanelWs && chatPanelWs.readyState === WebSocket.OPEN) {
                chatPanelWs.send(JSON.stringify({
                    type: 'chat_panel_message',
                    message: message
                }));
            } else {
                // Fallback: use REST API
                fetch('/api/chat-panel', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ message })
                })
                .then(res => res.json())
                .then(data => {
                    addChatMessage('assistant', data.message);
                })
                .catch(error => {
                    console.error('Error sending message:', error);
                    addChatMessage('assistant', 'Sorry, I encountered an error. Please try again.');
                });
            }
        }

        function stripMarkdown(text) {
            if (!text) return text;
            // Remove markdown formatting: **bold**, *italic*, `code`, etc.
            return text
                .replace(/\*\*([^*]+)\*\*/g, '$1')
                .replace(/\*([^*]+)\*/g, '$1')
                .replace(/`([^`]+)`/g, '$1')
                .replace(/#{1,6}\s+/g, '') // Remove headers
                .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1') // Remove links, keep text
                .trim();
        }

        function addChatMessage(role, message, timestamp = null) {
            const messagesArea = document.getElementById('chatMessagesArea');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}`;
            
            // Strip markdown formatting for clean display
            const cleanMessage = stripMarkdown(message);
            
            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble';
            bubble.textContent = cleanMessage;
            
            const time = timestamp || new Date();
            const timeStr = time.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'chat-timestamp';
            timestampDiv.textContent = timeStr;
            
            messageDiv.appendChild(bubble);
            messageDiv.appendChild(timestampDiv);
            messagesArea.appendChild(messageDiv);
            
            // Scroll to bottom
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        function updateChatStatus(text, color) {
            const indicator = document.getElementById('chatStatusIndicator');
            if (indicator) {
                indicator.style.background = color;
                indicator.title = text;
            }
        }

        // ==================== Reminder System ====================
        function startReminderPolling() {
            // Check immediately
            checkForReminders();
            
            // Then check every 60 seconds
            reminderInterval = setInterval(checkForReminders, 60000);
        }

        function stopReminderPolling() {
            if (reminderInterval) {
                clearInterval(reminderInterval);
                reminderInterval = null;
            }
        }

        async function checkForReminders() {
            try {
                const today = new Date().toISOString().split('T')[0];
                const response = await fetch(`/api/meetings-for-day?date=${today}`);
                const data = await response.json();
                
                // Handle different response structures
                let meetings = [];
                if (Array.isArray(data)) {
                    meetings = data;
                } else if (data && Array.isArray(data.meetings)) {
                    meetings = data.meetings;
                } else if (data && Array.isArray(data.events)) {
                    meetings = data.events;
                } else if (data && data.items && Array.isArray(data.items)) {
                    meetings = data.items;
                }
                
                if (!meetings || meetings.length === 0) return;
                
                const now = new Date();
                const reminderWindowMs = reminderWindowMinutes * 60 * 1000;
                
                meetings.forEach(meeting => {
                    if (!meeting.start?.dateTime) return;
                    
                    const meetingStart = new Date(meeting.start.dateTime);
                    const timeUntilMeeting = meetingStart - now;
                    const meetingId = meeting.id || meeting.summary;
                    
                    // Check if meeting is within reminder window (14-15 minutes before)
                    const minutesUntilMeeting = timeUntilMeeting / (60 * 1000);
                    if (minutesUntilMeeting > reminderWindowMinutes - 1 && minutesUntilMeeting <= reminderWindowMinutes && !shownReminders.has(meetingId)) {
                        showReminderCard(meeting);
                        shownReminders.add(meetingId);
                    }
                });
            } catch (error) {
                console.error('Error checking reminders:', error);
            }
        }

        function showReminderCard(meeting) {
            const messagesArea = document.getElementById('chatMessagesArea');
            const cardDiv = document.createElement('div');
            cardDiv.className = 'meeting-reminder-card';
            
            // Handle time display - check if it's an all-day event (date only) vs timed event
            const startTime = meeting.start?.dateTime || meeting.start?.date || meeting.start;
            let timeStr = 'Time TBD';
            
            if (startTime) {
                if (meeting.start?.dateTime) {
                    // Timed event - show time
                    timeStr = new Date(startTime).toLocaleTimeString('en-US', {
                        hour: 'numeric',
                        minute: '2-digit',
                        hour12: true
                    });
                } else if (meeting.start?.date) {
                    // All-day event - show "All day"
                    timeStr = 'All day';
                } else if (typeof startTime === 'string') {
                    // Try parsing as date string
                    const parsedDate = new Date(startTime);
                    if (!isNaN(parsedDate.getTime())) {
                        timeStr = parsedDate.toLocaleTimeString('en-US', {
                            hour: 'numeric',
                            minute: '2-digit',
                            hour12: true
                        });
                    }
                }
            }
            
            const attendees = (meeting.attendees || []).map(a => a.displayName || a.email).join(', ') || 'No attendees listed';
            
            cardDiv.innerHTML = `
                <div class="reminder-header">
                    <span class="reminder-text">Meeting starting in ${reminderWindowMinutes} minutes</span>
                </div>
                <div class="meeting-info">
                    <h4>${meeting.summary || 'Untitled Meeting'}</h4>
                    <p>${timeStr}</p>
                    <p>Attendees: ${attendees}</p>
                </div>
                <button class="prep-button-small" onclick="startVoicePrepForMeeting('${meeting.id || ''}')">
                    Start Prep
                </button>
            `;
            
            messagesArea.appendChild(cardDiv);
            messagesArea.scrollTop = messagesArea.scrollHeight;
            
            // Also send a text message from Shadow
            addChatMessage('assistant', `Your meeting "${meeting.summary || 'Untitled Meeting'}" starts in ${reminderWindowMinutes} minutes. Ready to prep?`);
        }

        async function startVoicePrepForMeeting(meetingId) {
            try {
                // Find the meeting
                const today = new Date().toISOString().split('T')[0];
                const response = await fetch(`/api/meetings-for-day?date=${today}`);
                const meetings = await response.json();
                
                const meeting = meetings.find(m => (m.id || '') === meetingId);
                if (!meeting) {
                    alert('Meeting not found');
                    return;
                }
                
                // Close chat panel
                toggleChatPanel();
                
                // Start voice prep (reuse existing function)
                if (window.selectMeetingForPrep) {
                    await window.selectMeetingForPrep(meeting);
                } else {
                    // Fallback: navigate to meeting detail and start prep
                    showMeetingDetail(meeting);
                    setTimeout(() => {
                        if (window.startVoicePrep) {
                            window.startVoicePrep();
                        }
                    }, 500);
                }
            } catch (error) {
                console.error('Error starting voice prep:', error);
                alert('Error starting prep. Please try again.');
            }
        }

        // ==================== Test Functions ====================
        function testReminder() {
            const selector = document.getElementById('testMeetingSelector');
            const meetingId = selector.value;
            
            if (!meetingId) {
                alert('Please select a meeting');
                return;
            }
            
            // Find the meeting and show reminder
            fetch(`/api/meetings-for-day?date=${new Date().toISOString().split('T')[0]}`)
                .then(res => res.json())
                .then(data => {
                    const meetings = data.meetings || [];
                    const meeting = meetings.find(m => (m.id || '') === meetingId);
                    if (meeting) {
                        showReminderCard(meeting);
                    } else {
                        alert('Meeting not found');
                    }
                })
                .catch(error => {
                    console.error('Error testing reminder:', error);
                    alert('Error testing reminder');
                });
        }

        async function populateTestMeetings() {
            const selector = document.getElementById('testMeetingSelector');
            selector.innerHTML = '<option value="">Select meeting...</option>';
            
            try {
                const today = new Date().toISOString().split('T')[0];
                const response = await fetch(`/api/meetings-for-day?date=${today}`);
                const data = await response.json();
                const meetings = data.meetings || [];
                
                meetings.forEach(meeting => {
                    const option = document.createElement('option');
                    option.value = meeting.id || '';
                    option.textContent = `${meeting.summary || 'Untitled Meeting'} - ${meeting.start?.dateTime ? new Date(meeting.start.dateTime).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }) : 'Time TBD'}`;
                    selector.appendChild(option);
                });
            } catch (error) {
                console.error('Error populating test meetings:', error);
            }
        }

        function toggleTestPanel() {
            const testPanel = document.getElementById('testPanel');
            const toggleButton = document.getElementById('testPanelToggle');
            
            if (testPanel) {
                const isVisible = testPanel.style.display !== 'none';
                testPanel.style.display = isVisible ? 'none' : 'block';
                toggleButton.textContent = isVisible ? 'Test Panel' : 'Hide Panel';
                
                if (!isVisible) {
                    populateTestMeetings();
                }
            }
        }

        function updateReminderWindow(value) {
            reminderWindowMinutes = parseInt(value, 10);
            document.getElementById('reminderWindowValue').textContent = value;
        }

        // Keyboard shortcut for test panel (Ctrl+Shift+T)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'T') {
                toggleTestPanel();
            }
        });

        // Export function
        window.toggleTestPanel = toggleTestPanel;

        // Export functions
        window.toggleChatPanel = toggleChatPanel;
        window.sendChatPanelMessage = sendChatPanelMessage;
        window.startVoicePrepForMeeting = startVoicePrepForMeeting;
        window.testReminder = testReminder;
        window.populateTestMeetings = populateTestMeetings;
        
        // Initialize test panel on load
        document.addEventListener('DOMContentLoaded', () => {
            populateTestMeetings();
        });

        async function startDayPrep() {
            const datePicker = document.getElementById('chatModeDatePicker');
            let selectedDate = datePicker.value;
            
            // Fallback to today's date if picker is empty
            if (!selectedDate) {
                selectedDate = new Date().toISOString().split('T')[0];
                datePicker.value = selectedDate;
                console.log('No date selected, using today:', selectedDate);
            }

            // Verify date format (YYYY-MM-DD)
            const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
            if (!dateRegex.test(selectedDate)) {
                console.error('Invalid date format:', selectedDate);
                alert('Invalid date format. Please select a valid date.');
                return;
            }

            console.log('Starting Day Prep for:', selectedDate, '(format: YYYY-MM-DD)');
            
            // Show loading state
            const dayPrepCard = document.querySelector('.action-card.primary');
            const originalHTML = dayPrepCard.innerHTML;
            dayPrepCard.innerHTML = '<h3>â³ Preparing...</h3><p>Analyzing all meetings for this day...</p>';
            dayPrepCard.style.pointerEvents = 'none';

            try {
                // Call day prep endpoint
                const response = await fetch('/api/day-prep', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        date: selectedDate
                    })
                });

                if (!response.ok) {
                    // Check for revoked token error
                    try {
                        const errorData = await response.json();
                        if (response.status === 401 && (errorData.error === 'TokenRevoked' || errorData.revoked === true)) {
                            // Clear session and redirect to sign-in
                            document.cookie = 'session=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
                            alert('Your session has expired. Please sign in again.');
                            window.location.href = '/';
                            return;
                        }
                        throw new Error(errorData.message || `Day prep failed: ${response.status}`);
                    } catch (parseError) {
                        throw new Error(`Day prep failed: ${response.status}`);
                    }
                }

                const dayPrepData = await response.json();
                console.log('Day Prep data:', dayPrepData);

                // Store day prep brief globally for voice prep
                window.currentDayPrepBrief = dayPrepData.dayPrep;
                window.currentDayPrepDate = selectedDate;
                
                // Restore button
                dayPrepCard.innerHTML = originalHTML;
                dayPrepCard.style.pointerEvents = 'auto';
                
                // Start voice prep with day prep content
                // Create a mock meeting brief structure for voice prep
                const dayPrepBrief = {
                    summary: dayPrepData.dayPrep.summary,
                    narrative: dayPrepData.dayPrep.narrative,
                    meetings: dayPrepData.meetings,
                    date: selectedDate
                };
                
                window.currentMeetingBrief = dayPrepBrief;
                
                // Open voice prep modal
                startVoicePrep();

            } catch (error) {
                console.error('Day Prep error:', error);
                alert('Failed to prepare day prep: ' + error.message);
                
                // Restore button
                dayPrepCard.innerHTML = originalHTML;
                dayPrepCard.style.pointerEvents = 'auto';
            }
        }

        async function startMeetingPrep() {
            const datePicker = document.getElementById('chatModeDatePicker');
            const selectedDate = datePicker.value;
            
            if (!selectedDate) {
                alert('Please select a date');
                return;
            }

            console.log('Starting Meeting Prep for:', selectedDate);

            try {
                // Fetch meetings for the day
                const response = await fetch(`/api/meetings-for-day?date=${selectedDate}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch meetings: ${response.status}`);
                }

                const data = await response.json();
                console.log('Meetings for day:', data);

                const meetings = data.meetings || [];
                if (!meetings || meetings.length === 0) {
                    alert('No meetings found for this date');
                    return;
                }

                // Show meeting selection modal
                displayMeetingSelection(meetings);

            } catch (error) {
                console.error('Meeting Prep error:', error);
                alert('Failed to fetch meetings: ' + error.message);
            }
        }

        function displayMeetingSelection(meetings) {
            const modal = document.getElementById('meetingSelectionModal');
            const meetingList = document.getElementById('meetingList');
            
            // Clear any existing content (including skeleton loaders)
            meetingList.innerHTML = '';

            if (meetings.length === 0) {
                meetingList.innerHTML = '<div class="no-events">No meetings found for this date</div>';
                modal.classList.add('active');
                return;
            }

            meetings.forEach(meeting => {
                const meetingCard = document.createElement('div');
                meetingCard.className = 'meeting-card';
                
                // Handle time display - check if it's an all-day event (date only) vs timed event
                const startTime = meeting.start?.dateTime || meeting.start?.date;
                let timeStr = 'Time TBD';
                
                if (startTime) {
                    if (meeting.start?.dateTime) {
                        // Timed event - show time
                        timeStr = new Date(startTime).toLocaleTimeString('en-US', {
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: true
                        });
                    } else if (meeting.start?.date) {
                        // All-day event - show "All day"
                        timeStr = 'All day';
                    }
                }
                
                // Clean up meeting title - remove any odd formatting
                let meetingTitle = meeting.summary || meeting.title || 'Untitled Meeting';
                // Remove any HTML-like tags or clean up formatting
                meetingTitle = meetingTitle.replace(/<[^>]*>/g, '').trim();
                
                const attendeeCount = meeting.attendees?.length || 0;
                
                meetingCard.innerHTML = `
                    <div class="meeting-card-time">${timeStr}</div>
                    <div class="meeting-card-title">${meetingTitle}</div>
                    <div class="meeting-card-attendees">${attendeeCount} attendee${attendeeCount !== 1 ? 's' : ''}</div>
                `;
                
                meetingCard.onclick = () => selectMeetingForPrep(meeting);
                meetingList.appendChild(meetingCard);
            });

            modal.classList.add('active');
        }

        function closeMeetingSelection() {
            const modal = document.getElementById('meetingSelectionModal');
            modal.classList.remove('active');
        }

        async function selectMeetingForPrep(meeting) {
            console.log('Selected meeting for prep:', meeting);
            
            closeMeetingSelection();

            // Show loading modal immediately
            const loadingModal = document.getElementById('meetingPrepLoadingModal');
            loadingModal.style.display = 'flex';

            try {
                // Fetch meeting brief
                const response = await fetch('/api/prep-meeting', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        meeting: meeting,
                        attendees: meeting.attendees || []
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || `Meeting prep failed: ${response.status}`);
                }

                const brief = await response.json();
                console.log('Meeting brief:', brief);

                // Hide loading modal
                loadingModal.style.display = 'none';

                // Start voice prep with this brief
                // Store brief globally for voice prep
                window.currentMeetingBrief = brief;
                
                // Open voice prep modal
                startVoicePrep();

            } catch (error) {
                console.error('Meeting prep error:', error);
                // Hide loading modal on error
                loadingModal.style.display = 'none';
                alert('Failed to prepare meeting: ' + error.message);
                // Restore meeting list
                displayMeetingSelection(await fetch(`/api/meetings-for-day?date=${document.getElementById('chatModeDatePicker').value}`).then(r => r.json()));
            }
        }

        // Export chat mode functions
        window.toggleChatMode = toggleChatMode;
        window.startDayPrep = startDayPrep;
        window.startMeetingPrep = startMeetingPrep;
        window.closeMeetingSelection = closeMeetingSelection;
        window.selectMeetingForPrep = selectMeetingForPrep;
        window.startVoicePrepSession = startVoicePrepSession;
        window.stopVoicePrepSession = stopVoicePrepSession;

        // ===== ACCOUNT MANAGEMENT FUNCTIONS =====

        /**
         * Open account management modal and load accounts
         */
        async function openAccountModal() {
            document.getElementById('accountModal').style.display = 'block';
            await loadAccounts();
        }

        /**
         * Close account management modal
         */
        function closeAccountModal() {
            document.getElementById('accountModal').style.display = 'none';
        }

        /**
         * Load and display connected accounts
         */
        async function loadAccounts() {
            const accountList = document.getElementById('accountList');
            accountList.innerHTML = '<li class="no-accounts">Loading accounts...</li>';

            try {
                const response = await fetch('/api/accounts', {
                    credentials: 'include'
                });

                if (!response.ok) {
                    throw new Error('Failed to load accounts');
                }

                const data = await response.json();
                const accounts = data.accounts;

                if (accounts.length === 0) {
                    accountList.innerHTML = '<li class="no-accounts">No connected accounts</li>';
                    return;
                }

                // Render accounts
                accountList.innerHTML = accounts.map(account => `
                    <li class="account-item">
                        <div class="account-info">
                            <div class="account-email">
                                ${account.email}
                                ${account.is_primary ? '<span class="account-badge">PRIMARY</span>' : ''}
                            </div>
                            <div style="font-size: 13px; color: #666; margin-top: 4px;">
                                ${account.name || ''}
                            </div>
                        </div>
                        <div class="account-actions">
                            ${!account.is_primary ? `
                                <button class="btn-set-primary" onclick="setPrimaryAccount('${account.id}')">
                                    Set Primary
                                </button>
                            ` : ''}
                            ${accounts.length > 1 ? `
                                <button class="btn-remove" onclick="removeAccount('${account.id}', '${account.email}')">
                                    Remove
                                </button>
                            ` : ''}
                        </div>
                    </li>
                `).join('');
            } catch (error) {
                console.error('Error loading accounts:', error);
                accountList.innerHTML = '<li class="no-accounts">Error loading accounts</li>';
            }
        }

        /**
         * Add a new account (initiate OAuth for additional account)
         */
        async function addNewAccount() {
            // Create a new token client for adding account
            const addAccountClient = google.accounts.oauth2.initCodeClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                ux_mode: 'popup',
                callback: async (response) => {
                    if (response.code) {
                        await exchangeCodeForAdditionalAccount(response.code);
                    }
                },
            });

            addAccountClient.requestCode();
        }

        /**
         * Exchange code for additional account
         */
        async function exchangeCodeForAdditionalAccount(code) {
            try {
                const response = await fetch('/auth/google/add-account', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ code })
                });

                const data = await response.json();

                if (data.success) {
                    alert(`Account ${data.account.email} added successfully!`);
                    await loadAccounts(); // Refresh account list
                } else {
                    alert('Failed to add account: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error adding account:', error);
                alert('Failed to add account. Please try again.');
            }
        }

        /**
         * Set an account as primary
         */
        async function setPrimaryAccount(accountId) {
            try {
                const response = await fetch(`/api/accounts/${accountId}/set-primary`, {
                    method: 'PUT',
                    credentials: 'include'
                });

                const data = await response.json();

                if (data.success) {
                    await loadAccounts(); // Refresh account list
                } else {
                    alert('Failed to set primary account: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error setting primary account:', error);
                alert('Failed to set primary account. Please try again.');
            }
        }

        /**
         * Remove an account
         */
        async function removeAccount(accountId, accountEmail) {
            if (!confirm(`Are you sure you want to remove ${accountEmail}?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/accounts/${accountId}`, {
                    method: 'DELETE',
                    credentials: 'include'
                });

                const data = await response.json();

                if (data.success) {
                    await loadAccounts(); // Refresh account list
                } else {
                    alert('Failed to remove account: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error removing account:', error);
                alert('Failed to remove account. Please try again.');
            }
        }

        // Expose functions to window for onclick handlers
        window.openAccountModal = openAccountModal;
        window.closeAccountModal = closeAccountModal;
        window.addNewAccount = addNewAccount;
        window.setPrimaryAccount = setPrimaryAccount;
        window.removeAccount = removeAccount;

    </script>
</body>
</html>
