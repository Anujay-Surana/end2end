<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Today's Agenda</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 30px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .user-profile {
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .user-info {
            text-align: right;
        }

        .user-name {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .user-email {
            color: #666;
            font-size: 12px;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #4285f4;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 16px;
        }

        #signInButton {
            background: #4285f4;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }

        #signInButton:hover {
            background: #357ae8;
        }

        .date-navigation {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .nav-button {
            background: #f0f0f0;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            transition: background 0.3s;
        }

        .nav-button:hover {
            background: #e0e0e0;
        }

        .current-date {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            min-width: 200px;
            text-align: center;
        }

        .events-container {
            display: none;
        }

        .events-container.visible {
            display: block;
        }

        .event {
            background: #f9f9f9;
            padding: 16px;
            margin-bottom: 12px;
            border-radius: 8px;
            border-left: 4px solid #4285f4;
            cursor: pointer;
            transition: all 0.3s;
        }

        .event:hover {
            background: #f0f0f0;
            transform: translateX(4px);
        }

        .event-time {
            color: #666;
            font-size: 14px;
            margin-bottom: 6px;
        }

        .event-title {
            color: #333;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .event-description {
            color: #666;
            font-size: 14px;
        }

        .event-countdown {
            color: #4285f4;
            font-size: 13px;
            font-weight: 600;
            margin-top: 6px;
        }

        .event-countdown.past {
            color: #999;
        }

        .event-countdown.happening {
            color: #34a853;
        }

        .meeting-info-toggle {
            background: #e8f0fe;
            color: #4285f4;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.3s;
        }

        .meeting-info-toggle:hover {
            background: #d2e3fc;
        }

        .meeting-details {
            display: none;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e0e0e0;
        }

        .meeting-details.visible {
            display: block;
        }

        .detail-section {
            margin-bottom: 10px;
        }

        .detail-label {
            font-weight: 600;
            color: #333;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .detail-value {
            color: #666;
            font-size: 14px;
            margin-left: 8px;
        }

        .attendee {
            color: #666;
            font-size: 13px;
            margin-left: 8px;
            margin-bottom: 4px;
        }

        .context-panel {
            background: #f0f7ff;
            padding: 12px;
            margin-top: 12px;
            border-radius: 6px;
            border-left: 3px solid #4285f4;
        }

        .context-header {
            font-weight: 600;
            color: #333;
            font-size: 13px;
            margin-bottom: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .context-content {
            display: none;
            margin-top: 8px;
        }

        .context-content.visible {
            display: block;
        }

        .email-item, .event-item {
            background: white;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #e0e0e0;
        }

        .email-item:hover, .event-item:hover {
            background: #f9f9f9;
        }

        .email-subject, .event-past-title {
            font-weight: 600;
            color: #333;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .email-date, .event-past-date {
            color: #999;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .email-snippet {
            color: #666;
            font-size: 12px;
            margin-top: 4px;
        }

        .email-body {
            display: none;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e0e0e0;
            color: #666;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .email-body.visible {
            display: block;
        }

        .loading-context {
            color: #999;
            font-size: 12px;
            font-style: italic;
        }

        .no-events {
            text-align: center;
            color: #999;
            padding: 40px;
            font-size: 16px;
        }

        .loading {
            text-align: center;
            color: #666;
            padding: 20px;
        }

        #signOutButton {
            background: #666;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            margin-top: 20px;
        }

        #signOutButton:hover {
            background: #555;
        }

        /* Meeting Detail Page Styles */
        .meeting-detail-container {
            display: none;
        }

        .meeting-detail-container.visible {
            display: block;
        }

        .back-button {
            background: #f0f0f0;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 20px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .back-button:hover {
            background: #e0e0e0;
        }

        .meeting-header {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .meeting-title-large {
            font-size: 24px;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .meeting-time-large {
            font-size: 16px;
            color: #666;
            margin-bottom: 8px;
        }

        .meeting-status-large {
            font-size: 14px;
            color: #4285f4;
            font-weight: 600;
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            gap: 8px;
            border-bottom: 2px solid #e0e0e0;
            margin-bottom: 20px;
        }

        .tab-button {
            background: none;
            border: none;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .tab-button:hover {
            color: #4285f4;
        }

        .tab-button.active {
            color: #4285f4;
            border-bottom-color: #4285f4;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Attendee Selector */
        .attendee-filters {
            background: #f9f9f9;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .filter-header {
            font-weight: 600;
            color: #333;
            font-size: 14px;
            margin-bottom: 12px;
        }

        .attendee-checkbox-list {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .attendee-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .attendee-checkbox input[type="checkbox"] {
            cursor: pointer;
        }

        .attendee-checkbox label {
            cursor: pointer;
            font-size: 13px;
            color: #666;
        }

        .select-all-btn {
            background: #e8f0fe;
            color: #4285f4;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            margin-top: 10px;
        }

        .select-all-btn:hover {
            background: #d2e3fc;
        }

        /* Attachments */
        .attachment-item {
            background: white;
            padding: 12px;
            margin-bottom: 12px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .attachment-icon {
            width: 40px;
            height: 40px;
            background: #e8f0fe;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #4285f4;
            font-weight: 600;
            font-size: 12px;
        }

        .attachment-info {
            flex: 1;
        }

        .attachment-name {
            font-weight: 600;
            color: #333;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .attachment-meta {
            color: #999;
            font-size: 12px;
        }

        .attachment-link {
            background: #4285f4;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            text-decoration: none;
        }

        .attachment-link:hover {
            background: #357ae8;
        }

        .overview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }

        .overview-card {
            background: #f9f9f9;
            padding: 16px;
            border-radius: 8px;
        }

        .overview-card-title {
            font-weight: 600;
            color: #666;
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .overview-card-content {
            color: #333;
            font-size: 14px;
        }

        .prep-button {
            background: #34a853;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-left: 12px;
            transition: background 0.3s;
        }

        .prep-button:hover {
            background: #2d8e47;
        }

        .prep-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .prep-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .prep-modal.visible {
            display: flex;
        }

        .prep-modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 1000px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .prep-modal-header {
            font-size: 24px;
            font-weight: 600;
            color: #333;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .prep-modal-close {
            background: none;
            border: none;
            font-size: 28px;
            color: #666;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            line-height: 28px;
        }

        .prep-modal-close:hover {
            color: #333;
        }

        .prep-content {
            color: #333;
            font-size: 15px;
            line-height: 1.6;
        }

        .prep-content h2 {
            font-size: 18px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #34a853;
        }

        .prep-content h3 {
            font-size: 16px;
            margin-top: 16px;
            margin-bottom: 8px;
            color: #666;
        }

        .prep-content ul {
            margin-left: 20px;
            margin-bottom: 12px;
        }

        .prep-content li {
            margin-bottom: 6px;
        }

        .prep-loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .prep-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #34a853;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Modern Brief Styles */
        .modern-brief {
            max-width: 900px;
            margin: 0 auto;
        }

        .brief-hero-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 32px;
            border-radius: 16px;
            margin-bottom: 24px;
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.25);
        }

        .brief-hero-card h2 {
            margin: 0 0 8px 0;
            font-size: 28px;
            font-weight: 700;
        }

        .meeting-time {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 16px;
        }

        .executive-summary {
            font-size: 16px;
            line-height: 1.6;
            margin: 16px 0 0 0;
            opacity: 0.95;
        }

        .brief-section {
            margin-bottom: 32px;
        }

        .brief-section h3 {
            font-size: 20px;
            font-weight: 700;
            margin: 0 0 16px 0;
            color: #333;
        }

        .attendee-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 16px;
        }

        .attendee-modern-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            display: flex;
            gap: 16px;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }

        .attendee-modern-card:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
            transform: translateY(-2px);
        }

        .attendee-avatar-modern {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 700;
            flex-shrink: 0;
        }

        .attendee-details {
            flex: 1;
            min-width: 0;
        }

        .attendee-details h4 {
            margin: 0 0 4px 0;
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .attendee-title {
            margin: 0 0 12px 0;
            font-size: 13px;
            color: #666;
        }

        .key-facts {
            margin: 0;
            padding: 0 0 0 20px;
            list-style: none;
        }

        .key-facts li {
            font-size: 13px;
            color: #555;
            line-height: 1.6;
            margin-bottom: 6px;
            position: relative;
        }

        .key-facts li:before {
            content: '‚Ä¢';
            color: #667eea;
            font-weight: bold;
            position: absolute;
            left: -15px;
        }

        .action-checklist {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }

        .action-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .action-item:last-child {
            border-bottom: none;
        }

        .action-item:hover {
            background: #f9f9f9;
            margin: 0 -8px;
            padding-left: 8px;
            padding-right: 8px;
            border-radius: 6px;
        }

        .action-item input[type="checkbox"] {
            margin-top: 3px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .action-item span {
            font-size: 14px;
            color: #333;
            line-height: 1.5;
        }

        /* Brief Tabs Styles */
        .brief-tabs {
            display: flex;
            gap: 4px;
            border-bottom: 2px solid #e0e0e0;
            margin-bottom: 24px;
            overflow-x: auto;
        }

        .brief-tab-button {
            background: none;
            border: none;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .brief-tab-button:hover {
            color: #34a853;
            background: #f5f5f5;
        }

        .brief-tab-button.active {
            color: #34a853;
            border-bottom-color: #34a853;
        }

        .brief-tab-content {
            display: none;
        }

        .brief-tab-content.active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Attendee Cards */
        .attendee-card {
            background: #f9f9f9;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            border-left: 4px solid #4285f4;
        }

        .attendee-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .attendee-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 18px;
        }

        .attendee-info h4 {
            margin: 0;
            color: #333;
            font-size: 16px;
        }

        .attendee-info p {
            margin: 4px 0 0 0;
            color: #666;
            font-size: 13px;
        }

        .attendee-insights {
            margin-top: 12px;
        }

        .insight-section {
            margin-bottom: 12px;
        }

        .insight-label {
            font-weight: 600;
            color: #555;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .insight-value {
            color: #666;
            font-size: 14px;
            line-height: 1.5;
        }

        /* Insight Cards */
        .insight-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .insight-card h4 {
            margin: 0 0 12px 0;
            color: #34a853;
            font-size: 16px;
        }

        .insight-card ul {
            margin: 8px 0;
            padding-left: 20px;
        }

        .insight-card li {
            margin-bottom: 8px;
            color: #666;
            line-height: 1.5;
        }

        /* Source Citations */
        .source-citation {
            display: inline-block;
            background: #e8f0fe;
            color: #1967d2;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            text-decoration: none;
            margin-left: 8px;
            transition: background 0.2s;
        }

        .source-citation:hover {
            background: #d2e3fc;
        }

        /* Progress Bar */
        .progress-container {
            width: 100%;
            height: 4px;
            background: #f0f0f0;
            border-radius: 2px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #34a853 0%, #4285f4 100%);
            width: 0%;
            transition: width 0.3s;
        }

        /* Copy Button */
        .copy-section-btn {
            background: #f0f0f0;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            float: right;
            transition: background 0.2s;
        }

        .copy-section-btn:hover {
            background: #e0e0e0;
        }

        /* Document Card */
        .document-card {
            background: #fff9e6;
            border-left: 4px solid #fbbc04;
            padding: 16px;
            margin-bottom: 16px;
            border-radius: 8px;
        }

        .document-card h4 {
            margin: 0 0 8px 0;
            color: #333;
            font-size: 15px;
        }

        .document-meta {
            color: #666;
            font-size: 12px;
            margin-bottom: 12px;
        }

        /* Analysis Sections */
        .analysis-section {
            padding: 24px;
            background: #ffffff;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .analysis-section h3 {
            margin: 0 0 16px 0;
            color: #333;
            font-size: 20px;
        }

        .analysis-text {
            color: #555;
            line-height: 1.8;
            font-size: 15px;
            white-space: pre-wrap;
        }

        /* Attendee Email */
        .attendee-email {
            color: #888;
            font-size: 13px;
            margin: 4px 0;
        }

        .key-facts-section {
            margin-top: 12px;
        }

        .key-facts-section strong {
            color: #666;
            font-size: 13px;
            display: block;
            margin-bottom: 8px;
        }

        /* Recommendations */
        .recommendations-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .recommendation-item {
            display: flex;
            gap: 12px;
            padding: 16px;
            background: #f8f9fa;
            border-left: 4px solid #34a853;
            border-radius: 4px;
            margin-bottom: 12px;
            align-items: flex-start;
        }

        .rec-number {
            background: #34a853;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            flex-shrink: 0;
        }

        .rec-text {
            color: #333;
            line-height: 1.6;
            font-size: 15px;
        }

        /* Real-Time Meeting Assistant Styles */
        .enter-meeting-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .enter-meeting-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .meeting-assistant {
            margin-top: 30px;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
        }

        .assistant-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e5e7eb;
        }

        .assistant-header h2 {
            margin: 0;
            font-size: 20px;
            color: #1f2937;
        }

        .stop-assistant-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .stop-assistant-btn:hover {
            background: #dc2626;
        }

        .assistant-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .transcript-panel, .suggestions-panel {
            background: #f9fafb;
            border-radius: 8px;
            padding: 15px;
            min-height: 400px;
            max-height: 600px;
            overflow-y: auto;
        }

        .transcript-panel h3, .suggestions-panel h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #374151;
            font-weight: 600;
        }

        .transcript-content, .suggestions-content {
            font-size: 14px;
            line-height: 1.6;
        }

        .transcript-item {
            margin-bottom: 12px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        .transcript-item.user {
            border-left-color: #10b981;
            background: #f0fdf4;
        }

        .transcript-speaker {
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 4px;
            font-size: 13px;
        }

        .transcript-text {
            color: #4b5563;
        }

        .transcript-timestamp {
            font-size: 11px;
            color: #9ca3af;
            margin-top: 4px;
        }

        .suggestion-item {
            margin-bottom: 12px;
            padding: 12px;
            border-radius: 6px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .suggestion-item.info {
            background: #dbeafe;
            border-left: 3px solid #3b82f6;
        }

        .suggestion-item.warning {
            background: #fef3c7;
            border-left: 3px solid #f59e0b;
        }

        .suggestion-item.error {
            background: #fee2e2;
            border-left: 3px solid #ef4444;
        }

        .suggestion-type {
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 4px;
            letter-spacing: 0.5px;
        }

        .suggestion-item.info .suggestion-type {
            color: #1e40af;
        }

        .suggestion-item.warning .suggestion-type {
            color: #b45309;
        }

        .suggestion-item.error .suggestion-type {
            color: #991b1b;
        }

        .suggestion-message {
            color: #374151;
            font-size: 13px;
            line-height: 1.5;
        }

        .suggestion-placeholder {
            text-align: center;
            color: #9ca3af;
            padding: 40px 20px;
            font-style: italic;
        }

        /* Interactive Prep Chat Styles */
        .chat-message {
            margin-bottom: 16px;
            display: flex;
            flex-direction: column;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chat-message.user {
            align-items: flex-end;
        }

        .chat-message.assistant {
            align-items: flex-start;
        }

        .chat-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 16px;
            font-size: 14px;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .chat-message.user .chat-bubble {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .chat-message.assistant .chat-bubble {
            background: white;
            color: #333;
            border: 1px solid #e5e7eb;
            border-bottom-left-radius: 4px;
        }

        .chat-timestamp {
            font-size: 11px;
            color: #9ca3af;
            margin-top: 4px;
            padding: 0 4px;
        }

        .chat-tool-call {
            font-size: 12px;
            color: #667eea;
            font-style: italic;
            margin-top: 8px;
            padding: 8px 12px;
            background: #f3f4f6;
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }

        .chat-loading {
            display: inline-flex;
            gap: 4px;
            padding: 12px 16px;
        }

        .chat-loading-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #9ca3af;
            animation: bounce 1.4s infinite;
        }

        .chat-loading-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .chat-loading-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes bounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div id="userProfile" class="user-profile" style="display: none;">
                <div class="user-info">
                    <div class="user-name" id="userName"></div>
                    <div class="user-email" id="userEmail"></div>
                </div>
                <div class="user-avatar" id="userAvatar"></div>
            </div>
            <h1>Today's Agenda</h1>
            <button id="signInButton">Sign in with Google</button>
        </div>

        <div id="eventsContainer" class="events-container">
            <div class="date-navigation">
                <button class="nav-button" id="prevDay">ÔøΩ</button>
                <div class="current-date" id="currentDate"></div>
                <button class="nav-button" id="nextDay">ÔøΩ</button>
            </div>

            <div id="eventsList"></div>

            <div style="text-align: center;">
                <button id="signOutButton">Sign Out</button>
            </div>
        </div>

        <!-- Meeting Detail View -->
        <div id="meetingDetailContainer" class="meeting-detail-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <button class="back-button" onclick="showCalendarView()">‚Üê Back to Calendar</button>
                <div style="display: flex; gap: 10px;">
                    <button class="prep-button" id="prepMeButton" onclick="prepareForMeeting()">Prep Me</button>
                    <button class="prep-button" id="interactivePrepButton" onclick="startInteractivePrep()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">üí¨ Interactive Prep</button>
                    <button class="enter-meeting-button" id="enterMeetingButton" onclick="enterMeeting()" style="display: none;">üé§ Entering Meeting</button>
                </div>
            </div>

            <div class="meeting-header">
                <div class="meeting-title-large" id="detailTitle"></div>
                <div class="meeting-time-large" id="detailTime"></div>
                <div class="meeting-status-large" id="detailStatus"></div>
            </div>

            <div class="tab-navigation">
                <button class="tab-button active" onclick="switchTab('overview')">Overview</button>
                <button class="tab-button" onclick="switchTab('attendees')">Attendees</button>
                <button class="tab-button" onclick="switchTab('emails')">Past Emails</button>
                <button class="tab-button" onclick="switchTab('attachments')">Attachments</button>
                <button class="tab-button" onclick="switchTab('files')">Drive Files</button>
            </div>

            <div id="tab-overview" class="tab-content active">
                <div class="overview-grid" id="overviewGrid"></div>
            </div>

            <div id="tab-attendees" class="tab-content">
                <div id="attendeesList"></div>
            </div>

            <div id="tab-emails" class="tab-content">
                <div class="attendee-filters" id="emailFilters">
                    <div class="filter-header">Filter by Attendee</div>
                    <div class="attendee-checkbox-list" id="emailAttendeeCheckboxes"></div>
                    <button class="select-all-btn" onclick="toggleAllEmailFilters()">Select All / None</button>
                </div>
                <div id="emailsList"></div>
            </div>

            <div id="tab-attachments" class="tab-content">
                <div class="attendee-filters" id="attachmentFilters">
                    <div class="filter-header">Filter by Attendee</div>
                    <div class="attendee-checkbox-list" id="attachmentAttendeeCheckboxes"></div>
                    <button class="select-all-btn" onclick="toggleAllAttachmentFilters()">Select All / None</button>
                </div>
                <div id="attachmentsList"></div>
            </div>

            <div id="tab-files" class="tab-content">
                <div class="attendee-filters" id="filesFilters">
                    <div class="filter-header">Filter by Attendee</div>
                    <div class="attendee-checkbox-list" id="filesAttendeeCheckboxes"></div>
                    <button class="select-all-btn" onclick="toggleAllFilesFilters()">Select All / None</button>
                </div>
                <div id="filesList"></div>
            </div>

            <!-- Real-Time Meeting Assistant -->
            <div id="meetingAssistantContainer" class="meeting-assistant" style="display: none;">
                <div class="assistant-header">
                    <h2>üé§ Real-Time Meeting Assistant</h2>
                    <button class="stop-assistant-btn" onclick="stopMeetingAssistant()">Stop</button>
                </div>

                <div class="assistant-grid">
                    <!-- Live Transcript -->
                    <div class="transcript-panel">
                        <h3>Live Transcript</h3>
                        <div id="transcriptContainer" class="transcript-content"></div>
                    </div>

                    <!-- AI Suggestions -->
                    <div class="suggestions-panel">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <h3 style="margin: 0;">AI Suggestions</h3>
                            <button onclick="clearSuggestions()" style="background: #666; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 13px; cursor: pointer;">
                                Clear
                            </button>
                        </div>
                        <div id="suggestionsContainer" class="suggestions-content">
                            <div class="suggestion-placeholder">Listening for conversation...</div>
                        </div>
                    </div>
                </div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button id="signOutButton2" style="background: #666; color: white; border: none; padding: 8px 16px; border-radius: 6px; font-size: 14px; cursor: pointer;" onclick="signOut()">Sign Out</button>
            </div>
        </div>

        <!-- Prep Modal -->
        <div id="prepModal" class="prep-modal">
            <div class="prep-modal-content">
                <div class="prep-modal-header">
                    <span>Meeting Preparation Brief</span>
                    <button class="prep-modal-close" onclick="closePrepModal()">&times;</button>
                </div>
                <div id="prepModalBody"></div>
            </div>
        </div>

        <!-- Speaker Mapping Modal -->
        <div id="speakerMappingModal" class="prep-modal" style="display: none;">
            <div class="prep-modal-content" style="max-width: 500px;">
                <div class="prep-modal-header">
                    <span>üë§ Identify Speakers</span>
                </div>
                <div style="padding: 24px;">
                    <p style="margin-bottom: 20px; color: #666;">We've detected multiple speakers. Please identify who is speaking:</p>
                    <div id="speakerMappingList"></div>
                    <button class="enter-meeting-button" onclick="confirmSpeakerMapping()" style="width: 100%; margin-top: 20px;">
                        Continue
                    </button>
                </div>
            </div>
        </div>

        <!-- Interactive Prep Chat Interface -->
        <div id="interactivePrepOverlay" class="prep-modal" style="display: none;">
            <div class="prep-modal-content" style="max-width: 1400px; max-height: 90vh; display: flex; flex-direction: row; gap: 0;">
                <!-- Meeting Brief Sidebar -->
                <div style="width: 400px; border-right: 2px solid #e5e7eb; display: flex; flex-direction: column; background: #f9fafb;">
                    <div style="padding: 16px; border-bottom: 2px solid #e5e7eb; background: white;">
                        <h3 style="margin: 0; font-size: 16px; color: #1f2937;">üìã Meeting Brief</h3>
                    </div>
                    <div id="interactiveBriefContent" style="flex: 1; overflow-y: auto; padding: 20px; font-size: 13px;">
                        <div style="text-align: center; color: #999; padding: 40px 20px;">
                            Loading brief...
                        </div>
                    </div>
                </div>

                <!-- Chat Interface -->
                <div style="flex: 1; display: flex; flex-direction: column;">
                    <div class="prep-modal-header" style="flex-shrink: 0;">
                        <span>üí¨ Interactive Prep Assistant</span>
                        <button class="prep-modal-close" onclick="closeInteractivePrep()">&times;</button>
                    </div>

                    <div style="padding: 20px; flex: 1; display: flex; flex-direction: column; overflow: hidden;">
                        <div style="color: #666; font-size: 14px; margin-bottom: 12px; padding: 12px; background: #f8f9fa; border-radius: 8px;">
                            <strong id="interactiveMeetingTitle"></strong>
                            <div style="font-size: 13px; margin-top: 4px;" id="interactiveMeetingTime"></div>
                        </div>

                        <!-- Chat History -->
                        <div id="chatHistory" style="flex: 1; overflow-y: auto; margin-bottom: 16px; padding: 16px; background: #fafafa; border-radius: 8px; min-height: 300px;">
                            <div class="chat-placeholder" style="text-align: center; color: #999; padding: 40px 20px;">
                                <div style="font-size: 24px; margin-bottom: 12px;">üí¨</div>
                                <div>Ask me anything about this meeting...</div>
                                <div style="font-size: 13px; margin-top: 8px;">Try: "Tell me about the attendees" or "What documents are attached?"</div>
                            </div>
                        </div>

                    <!-- Input Area -->
                    <div style="flex-shrink: 0;">
                        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                            <input
                                type="text"
                                id="chatInput"
                                placeholder="Type a message or use voice..."
                                style="flex: 1; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px;"
                                onkeypress="if(event.key==='Enter') sendChatMessage()"
                            />
                            <button
                                id="voiceInputBtn"
                                onclick="toggleVoiceInput()"
                                style="padding: 12px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px;"
                                title="Voice input"
                            >
                                üé§
                            </button>
                            <button
                                onclick="sendChatMessage()"
                                style="padding: 12px 20px; background: #764ba2; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px;"
                            >
                                Send
                            </button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 12px; font-size: 13px; color: #666;">
                            <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                <input type="checkbox" id="voiceOutputToggle" checked />
                                <span>Voice responses</span>
                            </label>
                            <span id="chatStatus" style="margin-left: auto;"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script>
        const CLIENT_ID = '173246695918-vbpcthe7tuo0vhmft1d1poots6cd38l3.apps.googleusercontent.com';
        const API_KEY = 'YOUR_API_KEY'; // Not needed for OAuth flow
        const SCOPES = 'https://www.googleapis.com/auth/calendar.readonly https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/drive.readonly';
        // API keys moved to backend server for security

        let tokenClient;
        let accessToken = null;
        let currentDate = new Date();
        let countdownInterval = null;
        let userEmail = null;
        let userProfile = null;
        let currentMeeting = null;
        let allEvents = [];
        let currentEmails = [];
        let currentAttachments = [];
        let currentFiles = [];

        window.onload = function() {
            // Initialize Google Identity Services
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: (response) => {
                    if (response.access_token) {
                        accessToken = response.access_token;
                        onSignIn();
                    }
                },
            });

            document.getElementById('signInButton').addEventListener('click', () => {
                tokenClient.requestAccessToken();
            });

            document.getElementById('signOutButton').addEventListener('click', signOut);
            document.getElementById('prevDay').addEventListener('click', () => changeDay(-1));
            document.getElementById('nextDay').addEventListener('click', () => changeDay(1));
        };

        async function fetchUserProfile() {
            try {
                const response = await fetch(
                    'https://www.googleapis.com/oauth2/v2/userinfo',
                    {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    }
                );

                const data = await response.json();
                userEmail = data.email;
                userProfile = data;

                // Display user profile
                document.getElementById('userName').textContent = data.name || 'User';
                document.getElementById('userEmail').textContent = data.email;

                // Get initials for avatar
                const nameParts = (data.name || data.email).split(' ');
                const initials = nameParts.length > 1
                    ? nameParts[0][0] + nameParts[nameParts.length - 1][0]
                    : nameParts[0][0];
                document.getElementById('userAvatar').textContent = initials.toUpperCase();

                document.getElementById('userProfile').style.display = 'flex';
            } catch (error) {
                console.error('Error fetching user profile:', error);
            }
        }

        async function onSignIn() {
            document.getElementById('signInButton').style.display = 'none';
            document.getElementById('eventsContainer').classList.add('visible');

            // Fetch user profile first
            await fetchUserProfile();

            // Then load events
            loadEvents();
        }

        function signOut() {
            accessToken = null;
            userEmail = null;
            userProfile = null;
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            document.getElementById('signInButton').style.display = 'block';
            document.getElementById('eventsContainer').classList.remove('visible');
            document.getElementById('userProfile').style.display = 'none';
            google.accounts.oauth2.revoke(accessToken);
        }

        function changeDay(delta) {
            currentDate.setDate(currentDate.getDate() + delta);
            loadEvents();
        }

        function formatDate(date) {
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        function formatTime(dateString) {
            const date = new Date(dateString);
            return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
        }

        async function loadEvents() {
            const eventsList = document.getElementById('eventsList');
            const currentDateEl = document.getElementById('currentDate');

            currentDateEl.textContent = formatDate(currentDate);
            eventsList.innerHTML = '<div class="loading">Loading events...</div>';

            const startOfDay = new Date(currentDate);
            startOfDay.setHours(0, 0, 0, 0);

            const endOfDay = new Date(currentDate);
            endOfDay.setHours(23, 59, 59, 999);

            try {
                const response = await fetch(
                    `https://www.googleapis.com/calendar/v3/calendars/primary/events?` +
                    `timeMin=${startOfDay.toISOString()}&` +
                    `timeMax=${endOfDay.toISOString()}&` +
                    `singleEvents=true&` +
                    `orderBy=startTime`,
                    {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    }
                );

                const data = await response.json();
                allEvents = data.items || [];
                displayEvents(allEvents);
            } catch (error) {
                console.error('Error loading events:', error);
                eventsList.innerHTML = '<div class="no-events">Error loading events. Please try again.</div>';
            }
        }

        function getTimeUntil(dateString) {
            if (!dateString) return null;

            const eventTime = new Date(dateString);
            const now = new Date();
            const diff = eventTime - now;
            const diffAbs = Math.abs(diff);

            const minutes = Math.floor(diffAbs / 60000);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (diffAbs < 60000) {
                return { text: 'Happening now', class: 'happening' };
            } else if (diff > 0) {
                // Future event
                if (days > 0) {
                    return { text: `in ${days} day${days > 1 ? 's' : ''}`, class: '' };
                } else if (hours > 0) {
                    const remainingMins = minutes % 60;
                    return { text: `in ${hours}h ${remainingMins}m`, class: '' };
                } else {
                    return { text: `in ${minutes} minute${minutes !== 1 ? 's' : ''}`, class: '' };
                }
            } else {
                // Past event
                if (days > 0) {
                    return { text: `${days} day${days > 1 ? 's' : ''} ago`, class: 'past' };
                } else if (hours > 0) {
                    const remainingMins = minutes % 60;
                    return { text: `${hours}h ${remainingMins}m ago`, class: 'past' };
                } else {
                    return { text: `${minutes} minute${minutes !== 1 ? 's' : ''} ago`, class: 'past' };
                }
            }
        }

        function getEventStatus(startString, endString) {
            if (!startString || !endString) return null;

            const start = new Date(startString);
            const end = new Date(endString);
            const now = new Date();

            const diffStart = start - now;
            const diffEnd = end - now;
            const diffStartAbs = Math.abs(diffStart);
            const diffEndAbs = Math.abs(diffEnd);

            const minutesStart = Math.floor(diffStartAbs / 60000);
            const hoursStart = Math.floor(minutesStart / 60);
            const minutesEnd = Math.floor(diffEndAbs / 60000);
            const hoursEnd = Math.floor(minutesEnd / 60);

            const duration = Math.floor((end - start) / 60000);
            const durationHours = Math.floor(duration / 60);
            const durationMins = duration % 60;

            let durationText = '';
            if (durationHours > 0) {
                durationText = `${durationHours}h ${durationMins}m`;
            } else {
                durationText = `${durationMins}m`;
            }

            // Event is happening now
            if (now >= start && now <= end) {
                const remainingMins = minutesEnd;
                const remainingHours = hoursEnd;
                const elapsedMins = minutesStart;
                const elapsedHours = hoursStart;

                let statusText = 'Happening now';
                if (elapsedHours > 0) {
                    statusText += ` ‚Ä¢ Started ${elapsedHours}h ${elapsedMins % 60}m ago`;
                } else if (elapsedMins > 0) {
                    statusText += ` ‚Ä¢ Started ${elapsedMins}m ago`;
                }

                if (remainingHours > 0) {
                    statusText += ` ‚Ä¢ Ending in ${remainingHours}h ${remainingMins % 60}m`;
                } else if (remainingMins > 0) {
                    statusText += ` ‚Ä¢ Ending in ${remainingMins}m`;
                }

                statusText += ` ‚Ä¢ Duration: ${durationText}`;
                return statusText;
            }

            // Event ended
            if (now > end) {
                let endedText = '';
                if (hoursEnd > 0) {
                    endedText = `Ended ${hoursEnd}h ${minutesEnd % 60}m ago`;
                } else {
                    endedText = `Ended ${minutesEnd}m ago`;
                }
                return `${endedText} ‚Ä¢ Duration: ${durationText}`;
            }

            // Event is upcoming
            return `Duration: ${durationText}`;
        }

        function updateCountdowns() {
            const countdowns = document.querySelectorAll('.event-countdown[data-event-time]');
            countdowns.forEach(countdown => {
                const eventTime = countdown.dataset.eventTime;
                const eventEnd = countdown.dataset.eventEnd;

                if (eventTime) {
                    const timeInfo = getTimeUntil(eventTime);
                    if (timeInfo) {
                        countdown.textContent = timeInfo.text;
                        countdown.className = `event-countdown ${timeInfo.class}`;
                    }
                }

                // Update status line if it exists
                const statusLine = countdown.nextElementSibling;
                if (statusLine && eventEnd && statusLine.classList.contains('event-countdown')) {
                    const eventStatus = getEventStatus(eventTime, eventEnd);
                    if (eventStatus) {
                        statusLine.textContent = eventStatus;
                    }
                }
            });
        }

        async function fetchPastEmails(attendeeEmails) {
            if (!attendeeEmails || attendeeEmails.length === 0) return [];

            // Filter out the user's own email
            const otherAttendees = attendeeEmails.filter(email => email !== userEmail);
            if (otherAttendees.length === 0) return [];

            try {
                // Expand time range to last 6 months
                const sixMonthsAgo = new Date();
                sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
                const afterDate = sixMonthsAgo.toISOString().split('T')[0].replace(/-/g, '/');

                const queries = otherAttendees.map(email => `from:${email} OR to:${email}`).join(' OR ');
                const fullQuery = `(${queries}) after:${afterDate}`;

                const response = await fetch(
                    `https://www.googleapis.com/gmail/v1/users/me/messages?q=${encodeURIComponent(fullQuery)}&maxResults=50`,
                    {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    }
                );

                const data = await response.json();
                if (!data.messages) return [];

                // Fetch full email details - increased to 20
                const emailPromises = data.messages.slice(0, 20).map(async (msg) => {
                    const msgResponse = await fetch(
                        `https://www.googleapis.com/gmail/v1/users/me/messages/${msg.id}?format=full`,
                        {
                            headers: {
                                'Authorization': `Bearer ${accessToken}`
                            }
                        }
                    );
                    return msgResponse.json();
                });

                const emails = await Promise.all(emailPromises);
                return emails.map(email => {
                    const headers = email.payload.headers;
                    const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject';
                    const from = headers.find(h => h.name === 'From')?.value || '';
                    const date = headers.find(h => h.name === 'Date')?.value || '';

                    let body = '';
                    if (email.payload.body?.data) {
                        body = atob(email.payload.body.data.replace(/-/g, '+').replace(/_/g, '/'));
                    } else if (email.payload.parts) {
                        const textPart = email.payload.parts.find(p => p.mimeType === 'text/plain');
                        if (textPart?.body?.data) {
                            body = atob(textPart.body.data.replace(/-/g, '+').replace(/_/g, '/'));
                        }
                    }

                    return {
                        id: email.id,
                        subject,
                        from,
                        date,
                        snippet: email.snippet,
                        body: body.substring(0, 1000) // Limit body length
                    };
                });
            } catch (error) {
                console.error('Error fetching emails:', error);
                return [];
            }
        }

        async function fetchPastEvents(attendeeEmails) {
            if (!attendeeEmails || attendeeEmails.length === 0) return [];

            // Filter out the user's own email
            const otherAttendees = attendeeEmails.filter(email => email !== userEmail);
            if (otherAttendees.length === 0) return [];

            try {
                const now = new Date();
                const pastDate = new Date(now.getTime() - 180 * 24 * 60 * 60 * 1000); // 6 months (180 days) ago

                const response = await fetch(
                    `https://www.googleapis.com/calendar/v3/calendars/primary/events?` +
                    `timeMin=${pastDate.toISOString()}&` +
                    `timeMax=${now.toISOString()}&` +
                    `singleEvents=true&` +
                    `orderBy=startTime&` +
                    `maxResults=100`,
                    {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    }
                );

                const data = await response.json();
                if (!data.items) return [];

                // Filter events that have at least one matching attendee (excluding the user)
                const relevantEvents = data.items.filter(event => {
                    if (!event.attendees) return false;
                    return event.attendees.some(att =>
                        otherAttendees.includes(att.email)
                    );
                });

                return relevantEvents.slice(0, 15).map(event => ({
                    id: event.id,
                    summary: event.summary || 'Untitled Event',
                    start: event.start.dateTime || event.start.date,
                    end: event.end.dateTime || event.end.date,
                    description: event.description || '',
                    attendees: event.attendees || []
                }));
            } catch (error) {
                console.error('Error fetching past events:', error);
                return [];
            }
        }

        function toggleMeetingInfo(eventId) {
            const details = document.getElementById(`details-${eventId}`);
            const button = document.getElementById(`toggle-${eventId}`);

            if (details.classList.contains('visible')) {
                details.classList.remove('visible');
                button.textContent = 'Show Meeting Info';
            } else {
                details.classList.add('visible');
                button.textContent = 'Hide Meeting Info';
            }
        }

        function toggleContext(contextId) {
            const content = document.getElementById(contextId);
            content.classList.toggle('visible');
        }

        function toggleEmailBody(emailId) {
            const body = document.getElementById(emailId);
            body.classList.toggle('visible');
        }

        async function loadContextData(eventId, attendeeEmails) {
            const emailsContent = document.getElementById(`emails-content-${eventId}`);
            const eventsContent = document.getElementById(`events-content-${eventId}`);

            if (emailsContent.dataset.loaded === 'true') return;

            emailsContent.innerHTML = '<div class="loading-context">Loading past emails...</div>';
            eventsContent.innerHTML = '<div class="loading-context">Loading past events...</div>';

            // Load emails and events
            const [emails, events] = await Promise.all([
                fetchPastEmails(attendeeEmails),
                fetchPastEvents(attendeeEmails)
            ]);

            // Display emails
            if (emails.length > 0) {
                emailsContent.innerHTML = emails.map((email, idx) => `
                    <div class="email-item" onclick="toggleEmailBody('email-body-${eventId}-${idx}')">
                        <div class="email-subject">${email.subject}</div>
                        <div class="email-date">${email.from} ‚Ä¢ ${new Date(email.date).toLocaleDateString()}</div>
                        <div class="email-snippet">${email.snippet}</div>
                        <div class="email-body" id="email-body-${eventId}-${idx}">
                            <strong>Full Email:</strong><br>
                            ${email.body.replace(/\n/g, '<br>')}
                        </div>
                    </div>
                `).join('');
            } else {
                emailsContent.innerHTML = '<div class="loading-context">No past emails found</div>';
            }

            // Display events
            if (events.length > 0) {
                eventsContent.innerHTML = events.map(event => `
                    <div class="event-item">
                        <div class="event-past-title">${event.summary}</div>
                        <div class="event-past-date">${new Date(event.start).toLocaleString()}</div>
                        ${event.description ? `<div class="email-snippet">${event.description.substring(0, 100)}...</div>` : ''}
                    </div>
                `).join('');
            } else {
                eventsContent.innerHTML = '<div class="loading-context">No past events found</div>';
            }

            emailsContent.dataset.loaded = 'true';
        }

        function displayEvents(events) {
            const eventsList = document.getElementById('eventsList');

            if (countdownInterval) {
                clearInterval(countdownInterval);
            }

            if (events.length === 0) {
                eventsList.innerHTML = '<div class="no-events">No events scheduled for this day</div>';
                return;
            }

            eventsList.innerHTML = events.map((event, index) => {
                const start = event.start.dateTime || event.start.date;
                const end = event.end.dateTime || event.end.date;
                const isAllDay = !event.start.dateTime;

                let timeString;
                if (isAllDay) {
                    timeString = 'All day';
                } else {
                    timeString = `${formatTime(start)} - ${formatTime(end)}`;
                }

                const eventId = `event-${index}`;
                const timeInfo = !isAllDay && start ? getTimeUntil(start) : null;
                const eventStatus = !isAllDay && start && end ? getEventStatus(start, end) : null;

                // Prepare meeting details
                const attendees = event.attendees || [];
                const attendeeEmails = attendees.map(att => att.email).filter(Boolean);
                const location = event.location || '';
                const hangoutLink = event.hangoutLink || '';
                const description = event.description || '';
                const timezone = event.start.timeZone || 'Local time';

                return `
                    <div class="event" onclick="showMeetingDetail(${index})">
                        <div class="event-time">${timeString}</div>
                        <div class="event-title">${event.summary || 'Untitled Event'}</div>
                        ${timeInfo ? `<div class="event-countdown ${timeInfo.class}" data-event-time="${start}" data-event-end="${end}">${timeInfo.text}</div>` : ''}
                        ${eventStatus ? `<div class="event-countdown" style="margin-top: 4px;">${eventStatus}</div>` : ''}
                        <div style="margin-top: 10px; color: #4285f4; font-size: 13px; font-weight: 600;">Click for details ‚Üí</div>
                    </div>
                `;
            }).join('');

            // Update countdowns every minute
            countdownInterval = setInterval(updateCountdowns, 60000);
        }

        // View Navigation Functions
        function showMeetingDetail(index) {
            currentMeeting = allEvents[index];
            document.getElementById('eventsContainer').classList.remove('visible');
            document.getElementById('meetingDetailContainer').classList.add('visible');

            loadMeetingDetails();
        }

        function showCalendarView() {
            document.getElementById('eventsContainer').classList.add('visible');
            document.getElementById('meetingDetailContainer').classList.remove('visible');
            currentMeeting = null;
        }

        // Tab Switching
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');

            // Load data for specific tabs
            if (tabName === 'emails') {
                loadEmailsTab();
            } else if (tabName === 'attachments') {
                loadAttachmentsTab();
            } else if (tabName === 'files') {
                loadFilesTab();
            }
        }

        // Load Meeting Detail Data
        async function loadMeetingDetails() {
            const meeting = currentMeeting;
            const start = meeting.start.dateTime || meeting.start.date;
            const end = meeting.end.dateTime || meeting.end.date;
            const isAllDay = !meeting.start.dateTime;

            // Set header
            document.getElementById('detailTitle').textContent = meeting.summary || 'Untitled Event';

            let timeString;
            if (isAllDay) {
                timeString = 'All day';
            } else {
                timeString = `${formatTime(start)} - ${formatTime(end)}`;
            }
            document.getElementById('detailTime').textContent = timeString;

            const eventStatus = !isAllDay && start && end ? getEventStatus(start, end) : '';
            document.getElementById('detailStatus').textContent = eventStatus;

            // Load Overview Tab
            loadOverviewTab();

            // Load Attendees Tab
            loadAttendeesTab();
        }

        function loadOverviewTab() {
            const meeting = currentMeeting;
            const start = meeting.start.dateTime || meeting.start.date;
            const end = meeting.end.dateTime || meeting.end.date;
            const isAllDay = !meeting.start.dateTime;

            let timeString;
            if (isAllDay) {
                timeString = 'All day';
            } else {
                timeString = `${formatTime(start)} - ${formatTime(end)}`;
            }

            const timezone = meeting.start.timeZone || 'Local time';
            const location = meeting.location || 'No location specified';
            const hangoutLink = meeting.hangoutLink || '';
            const description = meeting.description || 'No description';
            const attendees = meeting.attendees || [];

            let overviewHTML = `
                <div class="overview-card">
                    <div class="overview-card-title">Time</div>
                    <div class="overview-card-content">${timeString}${!isAllDay ? ` (${timezone})` : ''}</div>
                </div>
                <div class="overview-card">
                    <div class="overview-card-title">Location</div>
                    <div class="overview-card-content">${location}</div>
                </div>
                <div class="overview-card">
                    <div class="overview-card-title">Attendees</div>
                    <div class="overview-card-content">${attendees.length} participant${attendees.length !== 1 ? 's' : ''}</div>
                </div>
            `;

            if (hangoutLink) {
                overviewHTML += `
                    <div class="overview-card">
                        <div class="overview-card-title">Meeting Link</div>
                        <div class="overview-card-content"><a href="${hangoutLink}" target="_blank">Join Meeting</a></div>
                    </div>
                `;
            }

            overviewHTML += `
                <div class="overview-card" style="grid-column: 1 / -1;">
                    <div class="overview-card-title">Description</div>
                    <div class="overview-card-content">${description.replace(/\n/g, '<br>')}</div>
                </div>
            `;

            document.getElementById('overviewGrid').innerHTML = overviewHTML;
        }

        function loadAttendeesTab() {
            const attendees = currentMeeting.attendees || [];

            if (attendees.length === 0) {
                document.getElementById('attendeesList').innerHTML = '<div class="loading-context">No attendees</div>';
                return;
            }

            let html = '<div class="overview-grid">';
            attendees.forEach(att => {
                html += `
                    <div class="overview-card">
                        <div class="overview-card-title">${att.displayName || att.email}</div>
                        <div class="overview-card-content">
                            ${att.email}<br>
                            ${att.organizer ? '<strong>Organizer</strong>' : ''}
                            ${att.responseStatus ? `Status: ${att.responseStatus}` : ''}
                        </div>
                    </div>
                `;
            });
            html += '</div>';

            document.getElementById('attendeesList').innerHTML = html;
        }

        async function loadEmailsTab() {
            const attendees = currentMeeting.attendees || [];
            const attendeeEmails = attendees.map(att => att.email).filter(Boolean);

            // Setup filters
            setupAttendeeFilters('email', attendeeEmails);

            // Load emails
            document.getElementById('emailsList').innerHTML = '<div class="loading-context">Loading emails...</div>';

            currentEmails = await fetchPastEmails(attendeeEmails);
            displayFilteredEmails();
        }

        async function loadAttachmentsTab() {
            const attendees = currentMeeting.attendees || [];
            const attendeeEmails = attendees.map(att => att.email).filter(Boolean);

            // Setup filters
            setupAttendeeFilters('attachment', attendeeEmails);

            // Load attachments
            document.getElementById('attachmentsList').innerHTML = '<div class="loading-context">Loading attachments...</div>';

            currentAttachments = await fetchAttachments(attendeeEmails);
            displayFilteredAttachments();
        }

        function setupAttendeeFilters(type, attendeeEmails) {
            const otherAttendees = attendeeEmails.filter(email => email !== userEmail);
            let containerId, filterFunctionName;

            if (type === 'email') {
                containerId = 'emailAttendeeCheckboxes';
                filterFunctionName = 'Emails';
            } else if (type === 'attachment') {
                containerId = 'attachmentAttendeeCheckboxes';
                filterFunctionName = 'Attachments';
            } else if (type === 'files') {
                containerId = 'filesAttendeeCheckboxes';
                filterFunctionName = 'Files';
            }

            let html = '';
            otherAttendees.forEach((email, idx) => {
                html += `
                    <div class="attendee-checkbox">
                        <input type="checkbox" id="${type}-filter-${idx}" value="${email}" checked onchange="filter${filterFunctionName}()">
                        <label for="${type}-filter-${idx}">${email}</label>
                    </div>
                `;
            });

            document.getElementById(containerId).innerHTML = html;
        }

        function toggleAllEmailFilters() {
            const checkboxes = document.querySelectorAll('#emailAttendeeCheckboxes input[type="checkbox"]');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);

            checkboxes.forEach(cb => cb.checked = !allChecked);
            filterEmails();
        }

        function toggleAllAttachmentFilters() {
            const checkboxes = document.querySelectorAll('#attachmentAttendeeCheckboxes input[type="checkbox"]');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);

            checkboxes.forEach(cb => cb.checked = !allChecked);
            filterAttachments();
        }

        function filterEmails() {
            displayFilteredEmails();
        }

        function filterAttachments() {
            displayFilteredAttachments();
        }

        function displayFilteredEmails() {
            const checkboxes = document.querySelectorAll('#emailAttendeeCheckboxes input[type="checkbox"]:checked');
            const selectedEmails = Array.from(checkboxes).map(cb => cb.value);

            const filtered = currentEmails.filter(email => {
                return selectedEmails.some(selectedEmail =>
                    email.from.includes(selectedEmail)
                );
            });

            const emailsList = document.getElementById('emailsList');

            if (filtered.length === 0) {
                emailsList.innerHTML = '<div class="loading-context">No emails found for selected attendees</div>';
                return;
            }

            emailsList.innerHTML = filtered.map((email, idx) => `
                <div class="email-item" onclick="toggleEmailBody('detail-email-${idx}')">
                    <div class="email-subject">${email.subject}</div>
                    <div class="email-date">${email.from} ‚Ä¢ ${new Date(email.date).toLocaleDateString()}</div>
                    <div class="email-snippet">${email.snippet}</div>
                    <div class="email-body" id="detail-email-${idx}">
                        <strong>Full Email:</strong><br>
                        ${email.body.replace(/\n/g, '<br>')}
                    </div>
                </div>
            `).join('');
        }

        function displayFilteredAttachments() {
            const checkboxes = document.querySelectorAll('#attachmentAttendeeCheckboxes input[type="checkbox"]:checked');
            const selectedEmails = Array.from(checkboxes).map(cb => cb.value);

            const filtered = currentAttachments.filter(att => {
                return selectedEmails.some(selectedEmail =>
                    att.from.includes(selectedEmail)
                );
            });

            const attachmentsList = document.getElementById('attachmentsList');

            if (filtered.length === 0) {
                attachmentsList.innerHTML = '<div class="loading-context">No attachments found for selected attendees</div>';
                return;
            }

            attachmentsList.innerHTML = filtered.map(att => {
                const ext = att.filename.split('.').pop().toUpperCase();
                return `
                    <div class="attachment-item">
                        <div class="attachment-icon">${ext}</div>
                        <div class="attachment-info">
                            <div class="attachment-name">${att.filename}</div>
                            <div class="attachment-meta">From: ${att.from} ‚Ä¢ ${att.date} ‚Ä¢ ${formatBytes(att.size)}</div>
                        </div>
                        <a href="${att.url}" class="attachment-link" target="_blank">View</a>
                    </div>
                `;
            }).join('');
        }

        async function fetchAttachments(attendeeEmails) {
            const otherAttendees = attendeeEmails.filter(email => email !== userEmail);
            if (otherAttendees.length === 0) return [];

            try {
                // Expand time range to last 6 months
                const sixMonthsAgo = new Date();
                sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
                const afterDate = sixMonthsAgo.toISOString().split('T')[0].replace(/-/g, '/');

                const queries = otherAttendees.map(email => `from:${email} OR to:${email} has:attachment`).join(' OR ');
                const fullQuery = `(${queries}) after:${afterDate}`;

                const response = await fetch(
                    `https://www.googleapis.com/gmail/v1/users/me/messages?q=${encodeURIComponent(fullQuery)}&maxResults=50`,
                    {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    }
                );

                const data = await response.json();
                if (!data.messages) return [];

                // Fetch messages with attachments - increased to 25
                const messagePromises = data.messages.slice(0, 25).map(async (msg) => {
                    try {
                        const msgResponse = await fetch(
                            `https://www.googleapis.com/gmail/v1/users/me/messages/${msg.id}`,
                            {
                                headers: {
                                    'Authorization': `Bearer ${accessToken}`
                                }
                            }
                        );
                        if (!msgResponse.ok) {
                            console.warn(`Failed to fetch message ${msg.id}: ${msgResponse.status}`);
                            return null;
                        }
                        return msgResponse.json();
                    } catch (error) {
                        console.warn(`Error fetching message ${msg.id}:`, error);
                        return null;
                    }
                });

                const messages = await Promise.all(messagePromises);
                const attachments = [];

                messages.forEach(message => {
                    // Skip if message is undefined or invalid (due to rate limiting or errors)
                    if (!message || !message.payload || !message.payload.headers) {
                        return;
                    }

                    const headers = message.payload.headers;
                    const from = headers.find(h => h.name === 'From')?.value || '';
                    const date = headers.find(h => h.name === 'Date')?.value || '';

                    // Recursive function to find attachments in nested parts
                    function extractAttachments(parts) {
                        if (!parts) return;
                        parts.forEach(part => {
                            if (part.filename && part.body && (part.body.attachmentId || part.body.size > 0)) {
                                attachments.push({
                                    filename: part.filename,
                                    mimeType: part.mimeType,
                                    size: part.body.size || 0,
                                    attachmentId: part.body.attachmentId,
                                    messageId: message.id,
                                    from,
                                    date: new Date(date).toLocaleDateString(),
                                    url: `https://mail.google.com/mail/u/0/#inbox/${message.id}`
                                });
                            }
                            // Recursively check nested parts
                            if (part.parts) {
                                extractAttachments(part.parts);
                            }
                        });
                    }

                    extractAttachments(message.payload.parts);
                });

                return attachments;
            } catch (error) {
                console.error('Error fetching attachments:', error);
                return [];
            }
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        async function loadFilesTab() {
            const attendees = currentMeeting.attendees || [];
            const attendeeEmails = attendees.map(att => att.email).filter(Boolean);

            // Setup filters
            setupAttendeeFilters('files', attendeeEmails);

            // Load files
            document.getElementById('filesList').innerHTML = '<div class="loading-context">Loading Drive files...</div>';

            currentFiles = await fetchDriveFiles(attendeeEmails);
            displayFilteredFiles();
        }

        async function fetchDriveFiles(attendeeEmails) {
            const otherAttendees = attendeeEmails.filter(email => email !== userEmail);
            if (otherAttendees.length === 0) return [];

            try {
                // Expand time range to last 6 months
                const sixMonthsAgo = new Date();
                sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

                // Build query to find files shared with or by any of the attendees
                // Using correct Drive API query syntax
                const queries = otherAttendees.map(email => `'${email}' in readers or '${email}' in writers`).join(' or ');

                const response = await fetch(
                    `https://www.googleapis.com/drive/v3/files?` +
                    `q=${encodeURIComponent(`(${queries}) and modifiedTime > '${sixMonthsAgo.toISOString()}'`)}&` +
                    `fields=files(id,name,mimeType,modifiedTime,owners,size,webViewLink,iconLink)&` +
                    `orderBy=modifiedTime desc&` +
                    `pageSize=50`,
                    {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    }
                );

                const data = await response.json();
                if (!data.files) return [];

                return data.files.map(file => ({
                    id: file.id,
                    name: file.name,
                    mimeType: file.mimeType,
                    size: file.size || 0,
                    modifiedTime: file.modifiedTime,
                    owner: file.owners && file.owners.length > 0 ? file.owners[0].displayName || file.owners[0].emailAddress : 'Unknown',
                    ownerEmail: file.owners && file.owners.length > 0 ? file.owners[0].emailAddress : '',
                    url: file.webViewLink,
                    iconLink: file.iconLink
                }));
            } catch (error) {
                console.error('Error fetching Drive files:', error);
                return [];
            }
        }

        function toggleAllFilesFilters() {
            const checkboxes = document.querySelectorAll('#filesAttendeeCheckboxes input[type="checkbox"]');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);

            checkboxes.forEach(cb => cb.checked = !allChecked);
            filterFiles();
        }

        function filterFiles() {
            displayFilteredFiles();
        }

        function displayFilteredFiles() {
            const checkboxes = document.querySelectorAll('#filesAttendeeCheckboxes input[type="checkbox"]:checked');
            const selectedEmails = Array.from(checkboxes).map(cb => cb.value);

            const filtered = currentFiles.filter(file => {
                return selectedEmails.some(selectedEmail =>
                    file.ownerEmail === selectedEmail
                );
            });

            const filesList = document.getElementById('filesList');

            if (filtered.length === 0) {
                filesList.innerHTML = '<div class="loading-context">No Drive files found for selected attendees</div>';
                return;
            }

            filesList.innerHTML = filtered.map(file => {
                const fileType = getFileType(file.mimeType, file.name);
                const modifiedDate = new Date(file.modifiedTime).toLocaleDateString();

                return `
                    <div class="attachment-item">
                        <div class="attachment-icon">${fileType}</div>
                        <div class="attachment-info">
                            <div class="attachment-name">${file.name}</div>
                            <div class="attachment-meta">
                                Owner: ${file.owner} ‚Ä¢ Modified: ${modifiedDate}
                                ${file.size ? ` ‚Ä¢ ${formatBytes(parseInt(file.size))}` : ''}
                            </div>
                        </div>
                        <a href="${file.url}" class="attachment-link" target="_blank">Open</a>
                    </div>
                `;
            }).join('');
        }

        function getFileType(mimeType, filename) {
            // Check for Google Workspace types
            if (mimeType.includes('spreadsheet')) return 'SHEET';
            if (mimeType.includes('document')) return 'DOC';
            if (mimeType.includes('presentation')) return 'SLIDE';
            if (mimeType.includes('folder')) return 'FLDR';
            if (mimeType.includes('form')) return 'FORM';

            // Check by file extension
            if (filename) {
                const ext = filename.split('.').pop().toUpperCase();
                if (ext && ext.length <= 4) return ext;
            }

            // Check by MIME type
            if (mimeType.includes('pdf')) return 'PDF';
            if (mimeType.includes('image')) return 'IMG';
            if (mimeType.includes('video')) return 'VID';
            if (mimeType.includes('audio')) return 'AUD';
            if (mimeType.includes('zip') || mimeType.includes('compressed')) return 'ZIP';
            if (mimeType.includes('text')) return 'TXT';

            return 'FILE';
        }

        async function fetchDriveFileContents(files) {
            const filesWithContent = [];
            const MAX_CONTENT_PER_FILE = 20000; // 20k chars per file - reasonable for analysis

            for (const file of files) {
                try {
                    let content = '';
                    let fetchUrl = '';
                    let mimeType = '';

                    // Handle Google Docs
                    if (file.mimeType.includes('document')) {
                        fetchUrl = `https://www.googleapis.com/drive/v3/files/${file.id}/export?mimeType=text/plain`;
                        mimeType = 'text/plain';
                    }
                    // Handle Google Sheets
                    else if (file.mimeType.includes('spreadsheet')) {
                        fetchUrl = `https://www.googleapis.com/drive/v3/files/${file.id}/export?mimeType=text/csv`;
                        mimeType = 'text/csv';
                    }
                    // Handle Google Slides
                    else if (file.mimeType.includes('presentation')) {
                        fetchUrl = `https://www.googleapis.com/drive/v3/files/${file.id}/export?mimeType=text/plain`;
                        mimeType = 'text/plain';
                    }
                    // Handle PDFs
                    else if (file.mimeType.includes('pdf')) {
                        fetchUrl = `https://www.googleapis.com/drive/v3/files/${file.id}/export?mimeType=text/plain`;
                        mimeType = 'text/plain';
                    }
                    // Handle plain text files
                    else if (file.mimeType.includes('text/plain') || file.mimeType.includes('text/')) {
                        fetchUrl = `https://www.googleapis.com/drive/v3/files/${file.id}?alt=media`;
                        mimeType = 'text/plain';
                    }

                    if (fetchUrl) {
                        console.log(`Fetching content for: ${file.name}`);
                        const response = await fetch(fetchUrl, {
                            headers: {
                                'Authorization': `Bearer ${accessToken}`
                            }
                        });

                        if (response.ok) {
                            content = await response.text();
                            // Limit but keep substantial content
                            if (content.length > MAX_CONTENT_PER_FILE) {
                                content = content.substring(0, MAX_CONTENT_PER_FILE) + '\n\n[Content truncated due to length - showing first 80k chars]';
                            }
                            console.log(`‚úì Fetched ${content.length} chars for: ${file.name}`);
                        } else {
                            console.warn(`Failed to fetch ${file.name}: ${response.status} ${response.statusText}`);
                        }
                    }

                    filesWithContent.push({
                        ...file,
                        content: content,
                        hasContent: content.length > 0
                    });

                } catch (error) {
                    console.warn(`Error fetching content for file ${file.name}:`, error);
                    filesWithContent.push({
                        ...file,
                        content: '',
                        hasContent: false
                    });
                }

                // Small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 150));
            }

            return filesWithContent;
        }

        // ===== PARALLEL AI WEB RESEARCH FUNCTIONS =====

        // Use GPT to craft optimized search queries
        async function craftSearchQueries(context) {
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [{
                            role: 'system',
                            content: 'You are a search query optimization expert. Generate EXACTLY 3 highly specific, effective web search queries that will find the most relevant and recent information. Return ONLY a JSON array of 3 query strings, no other text. Example: ["query 1", "query 2", "query 3"]'
                        }, {
                            role: 'user',
                            content: context
                        }],
                        temperature: 0.7,
                        max_tokens: 200
                    })
                });

                const data = await response.json();
                const queriesText = data.choices[0].message.content.trim();

                // Parse JSON array from GPT response
                try {
                    let queries = JSON.parse(queriesText);
                    if (Array.isArray(queries)) {
                        // Limit to maximum 5 queries (Parallel AI limit)
                        return queries.slice(0, 5);
                    }
                    return [];
                } catch {
                    // Fallback: split by newlines if not valid JSON
                    const queries = queriesText.split('\n')
                        .filter(q => q.trim().length > 0)
                        .map(q => q.replace(/^[-‚Ä¢*"'\d.)\]]\s*/, '').replace(/["']$/, '').trim())
                        .filter(q => q.length > 5);
                    return queries.slice(0, 5);
                }
            } catch (error) {
                console.error('Error crafting search queries:', error);
                return [];
            }
        }

        async function searchAttendee(attendee) {
            const name = attendee.displayName || attendee.email.split('@')[0];
            const domain = attendee.email.split('@')[1];
            const company = domain.split('.')[0];

            try {
                // Simple, effective search queries (max 5 per Parallel AI limit)
                const queries = [
                    `${name} ${company} LinkedIn profile`,
                    `${name} ${company} role position`,
                    `${name} ${company} news ${new Date().getFullYear()}`
                ];

                const response = await fetch('/api/parallel-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        objective: `Find comprehensive professional information about ${name} from ${company}: background, current role, recent activities, achievements, and public presence`,
                        search_queries: queries,
                        mode: 'one-shot',
                        max_results: 8,
                        max_chars_per_result: 3000
                    })
                });

                if (!response.ok) {
                    console.warn(`Parallel AI search failed for ${name}: ${response.status}`);
                    return { attendee, results: [] };
                }

                const data = await response.json();
                console.log(`‚úì Web research for ${name}: ${data.results?.length || 0} results`);
                return { attendee, results: data.results || [] };
            } catch (error) {
                console.error(`Error researching ${name}:`, error);
                return { attendee, results: [] };
            }
        }

        async function searchCompany(companyDomain) {
            const companyName = companyDomain.split('.')[0];

            try {
                // Simple, effective search queries (max 5 per Parallel AI limit)
                const queries = [
                    `${companyName} company overview ${new Date().getFullYear()}`,
                    `${companyName} news announcements ${new Date().getFullYear()}`,
                    `${companyName} products services`
                ];

                const response = await fetch('/api/parallel-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        objective: `Find comprehensive company information for ${companyName}: business overview, recent news, products, funding, market position, and key developments`,
                        search_queries: queries,
                        mode: 'one-shot',
                        max_results: 8,
                        max_chars_per_result: 3000
                    })
                });

                if (!response.ok) {
                    console.warn(`Parallel AI search failed for ${companyName}: ${response.status}`);
                    return { company: companyName, results: [] };
                }

                const data = await response.json();
                console.log(`‚úì Web research for ${companyName}: ${data.results?.length || 0} results`);
                return { company: companyName, results: data.results || [] };
            } catch (error) {
                console.error(`Error researching ${companyName}:`, error);
                return { company: companyName, results: [] };
            }
        }

        async function searchMeetingContext(meeting) {
            const title = meeting.summary || 'Meeting';
            const description = meeting.description || '';

            try {
                // Simple, effective search queries (max 5 per Parallel AI limit)
                const queries = [
                    `${title} ${new Date().getFullYear()}`,
                    `${title} trends news`,
                    `${title} insights`
                ].filter(q => q.length > 10); // Only valid queries

                const response = await fetch('/api/parallel-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        objective: `Find comprehensive contextual information for meeting topic "${title}": recent developments, industry trends, relevant news, and strategic insights`,
                        search_queries: queries,
                        mode: 'one-shot',
                        max_results: 8,
                        max_chars_per_result: 3000
                    })
                });

                if (!response.ok) {
                    console.warn(`Parallel AI search failed for meeting context: ${response.status}`);
                    return { results: [] };
                }

                const data = await response.json();
                console.log(`‚úì Web research for meeting context: ${data.results?.length || 0} results`);
                return { results: data.results || [] };
            } catch (error) {
                console.error('Error researching meeting context:', error);
                return { results: [] };
            }
        }

        function extractCompaniesFromAttendees(attendees) {
            const domains = attendees.map(att => att.email.split('@')[1]).filter(Boolean);
            return [...new Set(domains)];
        }

        // ===== SPECIALIZED GPT ANALYSIS FUNCTIONS =====

        async function analyzeEmailsWithGPT(emails) {
            if (!emails || emails.length === 0) return null;

            try {
                const emailContext = emails.slice(0, 10).map((email, idx) => `
Email ${idx + 1}: ${email.subject}
From: ${email.from}
Date: ${email.date}
Content: ${email.body || email.snippet}
---`).join('\n\n');

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [{
                            role: 'system',
                            content: 'Analyze email threads and extract: key themes, pending issues, relationship dynamics, important quotes, and sentiment patterns. Be specific and cite emails.'
                        }, {
                            role: 'user',
                            content: `Analyze these email threads:\n\n${emailContext}`
                        }],
                        temperature: 0.7,
                        max_tokens: 2000
                    })
                });

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('Error analyzing emails:', error);
                return null;
            }
        }

        async function analyzeDocumentsWithGPT(files) {
            if (!files || files.length === 0) return null;

            try {
                const docContext = files.filter(f => f.hasContent).slice(0, 5).map(file => `
Document: ${file.name}
Owner: ${file.owner}
Content: ${file.content.substring(0, 15000)}
---`).join('\n\n');

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [{
                            role: 'system',
                            content: 'Deeply analyze documents and extract: key insights, decisions made, action items, data points, concerns raised, and proposals. Be specific and quote relevant sections.'
                        }, {
                            role: 'user',
                            content: `Analyze these documents:\n\n${docContext}`
                        }],
                        temperature: 0.7,
                        max_tokens: 2500
                    })
                });

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('Error analyzing documents:', error);
                return null;
            }
        }

        async function analyzeAttendeeDynamicsWithGPT(attendees, emails, webResearch) {
            try {
                const attendeeList = attendees.map(att =>
                    `${att.displayName || att.email} (${att.email})${att.organizer ? ' [ORGANIZER]' : ''}`
                ).join('\n');

                const webInsights = webResearch.map(wr => `
${wr.attendee.displayName || wr.attendee.email}:
${wr.results?.map(r => `- ${(r.excerpts?.join(' ') || 'No content').substring(0, 300)}`).join('\n') || 'No web research available'}
`).join('\n');

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [{
                            role: 'system',
                            content: 'Analyze attendee relationships, power dynamics, likely positions, and strategic insights. Identify decision makers, influencers, and potential allies/concerns.'
                        }, {
                            role: 'user',
                            content: `Attendees:\n${attendeeList}\n\nWeb Research:\n${webInsights}\n\nEmail history: ${emails.length} emails available\n\nAnalyze the dynamics.`
                        }],
                        temperature: 0.7,
                        max_tokens: 2000
                    })
                });

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('Error analyzing dynamics:', error);
                return null;
            }
        }

        async function generateStrategyWithGPT(meeting, allContext) {
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [{
                            role: 'system',
                            content: 'Generate strategic recommendations including: key talking points, questions to ask, positions to take, risks to mitigate, and opportunities to seize. Be specific and actionable.'
                        }, {
                            role: 'user',
                            content: `Meeting: ${meeting.summary}\n\nBased on all available context (emails, documents, web research), provide strategic recommendations for this meeting.`
                        }],
                        temperature: 0.7,
                        max_tokens: 2000
                    })
                });

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('Error generating strategy:', error);
                return null;
            }
        }

        async function synthesizeWebIntelligenceWithGPT(webResearch, companyResearch, meetingContext) {
            try {
                const attendeeIntel = webResearch.map(wr => `
${wr.attendee.displayName || wr.attendee.email}:
${wr.results?.map(r => `- ${r.title || 'Result'}: ${(r.excerpts?.join(' ') || 'No content').substring(0, 400)} [${r.url || ''}]`).join('\n') || 'No results'}
`).join('\n\n');

                const companyIntel = companyResearch.map(cr => `
${cr.company}:
${cr.results?.map(r => `- ${r.title || 'Result'}: ${(r.excerpts?.join(' ') || 'No content').substring(0, 400)} [${r.url || ''}]`).join('\n') || 'No results'}
`).join('\n\n');

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [{
                            role: 'system',
                            content: 'Synthesize web research into actionable intelligence: attendee backgrounds, company news, industry context, and strategic implications. Include source citations.'
                        }, {
                            role: 'user',
                            content: `Attendee Research:\n${attendeeIntel}\n\nCompany Research:\n${companyIntel}\n\nMeeting Context: ${meetingContext.results?.length || 0} results\n\nSynthesize this intelligence.`
                        }],
                        temperature: 0.7,
                        max_tokens: 3000
                    })
                });

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('Error synthesizing web intelligence:', error);
                return null;
            }
        }

        async function prepareForMeeting() {
            const button = document.getElementById('prepMeButton');
            button.disabled = true;
            button.textContent = 'Preparing...';

            // Open modal with loading state
            const modal = document.getElementById('prepModal');
            const modalBody = document.getElementById('prepModalBody');
            modalBody.innerHTML = `
                <div class="prep-loading">
                    <div class="prep-spinner"></div>
                    <div id="loadingMessage">Generating your meeting brief...</div>
                    <p style="color: #666; font-size: 13px; margin-top: 10px;">This may take 15-20 seconds</p>
                </div>
            `;
            modal.classList.add('visible');

            try {
                const meeting = currentMeeting;
                const attendees = meeting.attendees || [];
                const attendeeEmails = attendees.map(att => att.email).filter(Boolean);

                // Fetch local context
                let emails = currentEmails;
                let files = currentFiles;

                if (emails.length === 0) {
                    emails = await fetchPastEmails(attendeeEmails);
                }
                if (files.length === 0) {
                    files = await fetchDriveFiles(attendeeEmails);
                }

                // Fetch file contents for analysis
                console.log(`üìÑ Fetching content for ${files.length} files...`);
                const filesWithContent = await fetchDriveFileContents(files.slice(0, 5));
                console.log(`‚úì Fetched content for ${filesWithContent.length} files`);

                // Call backend to generate brief
                const response = await fetch('/api/prep-meeting', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        meeting,
                        attendees,
                        emails: emails.slice(0, 15).map(e => ({
                            subject: e.subject,
                            snippet: e.snippet,
                            from: e.from,
                            body: e.body || e.snippet,
                            date: e.date
                        })),
                        files: filesWithContent.map(f => ({
                            name: f.name,
                            mimeType: f.mimeType,
                            modifiedTime: f.modifiedTime,
                            id: f.id,
                            content: f.content || ''
                        }))
                    })
                });

                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }

                const brief = await response.json();

                // Store brief globally for meeting assistant
                meetingBrief = brief;
                currentMeetingId = meeting.id;

                // Render the clean brief
                renderModernBrief(brief, meeting);

                // Show "Entering Meeting" button
                const enterMeetingBtn = document.getElementById('enterMeetingButton');
                if (enterMeetingBtn) {
                    enterMeetingBtn.style.display = 'inline-block';
                }

            } catch (error) {
                console.error('Error preparing meeting brief:', error);
                modalBody.innerHTML = `
                    <div class="prep-content">
                        <p style="color: #d32f2f;">Failed to generate meeting brief. Please try again.</p>
                        <p style="color: #666; font-size: 13px; margin-top: 10px;">Error: ${error.message}</p>
                    </div>
                `;
            } finally {
                button.disabled = false;
                button.textContent = 'Prep Me';
            }
        }

        // ===== MODERN BRIEF RENDERING =====

        function renderModernBrief(brief, meeting) {
            const modalBody = document.getElementById('prepModalBody');

            const getInitials = (name) => {
                return name.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);
            };

            // Create tabbed interface with comprehensive sections
            modalBody.innerHTML = `
                <div class="modern-brief">
                    <!-- Hero Card -->
                    <div class="brief-hero-card">
                        <h2>${meeting.summary}</h2>
                        <div class="meeting-time">${formatMeetingTime(meeting)}</div>
                        ${brief.summary ? `<p class="executive-summary">${brief.summary}</p>` : ''}
                    </div>

                    <!-- Tab Navigation -->
                    <div class="brief-tabs">
                        <button class="brief-tab-button active" onclick="switchBriefTab('attendees')">Attendees</button>
                        <button class="brief-tab-button" onclick="switchBriefTab('emails')">Email Analysis</button>
                        <button class="brief-tab-button" onclick="switchBriefTab('documents')">Documents</button>
                        <button class="brief-tab-button" onclick="switchBriefTab('company')">Company Intel</button>
                        <button class="brief-tab-button" onclick="switchBriefTab('strategy')">Recommendations</button>
                        <button class="brief-tab-button" onclick="switchBriefTab('actions')">Action Items</button>
                    </div>

                    <!-- Tab: Attendees -->
                    <div id="brief-tab-attendees" class="brief-tab-content active">
                        ${brief.attendees && brief.attendees.length > 0 ? `
                            <div class="attendee-grid">
                                ${brief.attendees.map(att => `
                                    <div class="attendee-modern-card">
                                        <div class="attendee-avatar-modern">${getInitials(att.name)}</div>
                                        <div class="attendee-details">
                                            <h4>${att.name}</h4>
                                            <p class="attendee-title">${att.title}</p>
                                            <p class="attendee-email">${att.email}</p>
                                            ${att.keyFacts && att.keyFacts.length > 0 ? `
                                                <div class="key-facts-section">
                                                    <strong>Key Information:</strong>
                                                    <ul class="key-facts">
                                                        ${att.keyFacts.map(fact => `<li>${fact}</li>`).join('')}
                                                    </ul>
                                                </div>
                                            ` : '<p style="color: #888;">No additional information found</p>'}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : '<p>No attendee information available.</p>'}
                    </div>

                    <!-- Tab: Email Analysis -->
                    <div id="brief-tab-emails" class="brief-tab-content">
                        <div class="analysis-section">
                            <h3>üìß Email Thread Analysis</h3>
                            ${brief.emailAnalysis ? `
                                <p class="analysis-text">${brief.emailAnalysis}</p>
                            ` : '<p style="color: #888;">No recent email activity to analyze.</p>'}
                        </div>
                    </div>

                    <!-- Tab: Documents -->
                    <div id="brief-tab-documents" class="brief-tab-content">
                        <div class="analysis-section">
                            <h3>üìÑ Document Review</h3>
                            ${brief.documentAnalysis ? `
                                <p class="analysis-text">${brief.documentAnalysis}</p>
                            ` : '<p style="color: #888;">No relevant documents identified.</p>'}
                        </div>
                    </div>

                    <!-- Tab: Company Intel -->
                    <div id="brief-tab-company" class="brief-tab-content">
                        <div class="analysis-section">
                            <h3>üè¢ Company & Context Research</h3>
                            ${brief.companyResearch ? `
                                <p class="analysis-text">${brief.companyResearch}</p>
                            ` : '<p style="color: #888;">No company research available.</p>'}
                        </div>
                    </div>

                    <!-- Tab: Strategic Recommendations -->
                    <div id="brief-tab-strategy" class="brief-tab-content">
                        <div class="analysis-section">
                            <h3>üí° Strategic Recommendations</h3>
                            ${brief.recommendations && brief.recommendations.length > 0 ? `
                                <ul class="recommendations-list">
                                    ${brief.recommendations.map((rec, idx) => `
                                        <li class="recommendation-item">
                                            <span class="rec-number">${idx + 1}</span>
                                            <span class="rec-text">${rec}</span>
                                        </li>
                                    `).join('')}
                                </ul>
                            ` : '<p style="color: #888;">No recommendations generated.</p>'}
                        </div>
                    </div>

                    <!-- Tab: Action Items -->
                    <div id="brief-tab-actions" class="brief-tab-content">
                        <div class="analysis-section">
                            <h3>‚úÖ Preparation Checklist</h3>
                            ${brief.actionItems && brief.actionItems.length > 0 ? `
                                <div class="action-checklist">
                                    ${brief.actionItems.map(item => `
                                        <label class="action-item">
                                            <input type="checkbox">
                                            <span>${item}</span>
                                        </label>
                                    `).join('')}
                                </div>
                            ` : '<p style="color: #888;">No action items identified.</p>'}
                        </div>
                    </div>
                </div>
            `;
        }

        // Tab switching function
        window.switchBriefTab = function(tabName) {
            // Hide all tabs
            document.querySelectorAll('.brief-tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.brief-tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            const selectedTab = document.getElementById(`brief-tab-${tabName}`);
            const selectedButton = event.target;
            if (selectedTab) {
                selectedTab.classList.add('active');
                selectedButton.classList.add('active');
            }
        };

        function formatMeetingTime(meeting) {
            const start = new Date(meeting.start.dateTime || meeting.start.date);
            const end = new Date(meeting.end.dateTime || meeting.end.date);
            return `${start.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} - ${end.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
        }

        // ===== TABBED BRIEF RENDERING (OLD - KEEPING FOR NOW) =====

        function renderBriefWithTabs(briefData) {
            const modalBody = document.getElementById('prepModalBody');
            const { meeting, attendees, attendeeResearch, companyResearch, emails, filesWithContent,
                    emailAnalysis, docAnalysis, dynamicsAnalysis, strategyAnalysis, webIntelAnalysis } = briefData;

            modalBody.innerHTML = `
                <div class="brief-tabs">
                    <button class="brief-tab-button active" onclick="switchBriefTab('overview')">Overview</button>
                    <button class="brief-tab-button" onclick="switchBriefTab('attendees')">Attendees</button>
                    <button class="brief-tab-button" onclick="switchBriefTab('emails')">Email Analysis</button>
                    <button class="brief-tab-button" onclick="switchBriefTab('documents')">Documents</button>
                    <button class="brief-tab-button" onclick="switchBriefTab('web')">Web Research</button>
                    <button class="brief-tab-button" onclick="switchBriefTab('strategy')">Strategy</button>
                </div>

                <div id="brief-tab-overview" class="brief-tab-content active">
                    ${renderOverviewTab(meeting, dynamicsAnalysis)}
                </div>

                <div id="brief-tab-attendees" class="brief-tab-content">
                    ${renderAttendeesTab(attendees, attendeeResearch)}
                </div>

                <div id="brief-tab-emails" class="brief-tab-content">
                    ${renderEmailAnalysisTab(emails, emailAnalysis)}
                </div>

                <div id="brief-tab-documents" class="brief-tab-content">
                    ${renderDocumentsTab(filesWithContent, docAnalysis)}
                </div>

                <div id="brief-tab-web" class="brief-tab-content">
                    ${renderWebResearchTab(webIntelAnalysis, companyResearch)}
                </div>

                <div id="brief-tab-strategy" class="brief-tab-content">
                    ${renderStrategyTab(strategyAnalysis)}
                </div>
            `;
        }

        function switchBriefTab(tabName) {
            document.querySelectorAll('.brief-tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.brief-tab-content').forEach(content => content.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(`brief-tab-${tabName}`).classList.add('active');
        }

        function renderOverviewTab(meeting, dynamicsAnalysis) {
            const start = meeting.start.dateTime || meeting.start.date;
            const end = meeting.end.dateTime || meeting.end.date;
            const status = getEventStatus(start, end) || '';

            return `
                <div class="insight-card">
                    <h4>Meeting Overview</h4>
                    <p><strong>Title:</strong> ${meeting.summary || 'Untitled Meeting'}</p>
                    <p><strong>Time:</strong> ${new Date(start).toLocaleString()}</p>
                    <p><strong>Status:</strong> ${status}</p>
                    ${meeting.location ? `<p><strong>Location:</strong> ${meeting.location}</p>` : ''}
                    ${meeting.description ? `<p><strong>Description:</strong> ${meeting.description}</p>` : ''}
                </div>

                <div class="insight-card">
                    <h4>Attendee Dynamics & Power Structure</h4>
                    <div>${formatMarkdown(dynamicsAnalysis || 'Analysis unavailable')}</div>
                </div>
            `;
        }

        function renderAttendeesTab(attendees, attendeeResearch) {
            return attendees.map(att => {
                const research = attendeeResearch.find(r => r.attendee.email === att.email);
                const initials = (att.displayName || att.email).split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);

                return `
                    <div class="attendee-card">
                        <div class="attendee-card-header">
                            <div class="attendee-avatar">${initials}</div>
                            <div class="attendee-info">
                                <h4>${att.displayName || att.email}</h4>
                                <p>${att.email}${att.organizer ? ' ‚Ä¢ <strong>Organizer</strong>' : ''}</p>
                            </div>
                        </div>
                        <div class="attendee-insights">
                            ${research && research.results && research.results.length > 0 ? `
                                <div class="insight-section">
                                    <div class="insight-label">Web Research:</div>
                                    ${research.results.slice(0, 3).map(r => `
                                        <div class="insight-value">
                                            <strong>${r.title || 'Web Result'}</strong><br>
                                            ${(r.excerpts?.join(' ') || 'No content available').substring(0, 300)}...
                                            <a href="${r.url || '#'}" class="source-citation" target="_blank">Source</a>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : '<p style="color: #999;">No web research available</p>'}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderEmailAnalysisTab(emails, emailAnalysis) {
            return `
                <div class="insight-card">
                    <h4>Email Thread Analysis (${emails.length} emails)</h4>
                    <button class="copy-section-btn" onclick="navigator.clipboard.writeText(this.nextElementSibling.innerText)">Copy</button>
                    <div>${formatMarkdown(emailAnalysis || 'No email analysis available')}</div>
                </div>

                <div class="insight-card">
                    <h4>Recent Email Threads</h4>
                    ${emails.slice(0, 5).map((email, idx) => `
                        <div style="margin-bottom: 16px; padding-bottom: 16px; border-bottom: 1px solid #e0e0e0;">
                            <strong>${email.subject}</strong><br>
                            <span style="color: #666; font-size: 13px;">From: ${email.from} ‚Ä¢ ${email.date}</span><br>
                            <p style="margin-top: 8px;">${email.snippet}</p>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderDocumentsTab(filesWithContent, docAnalysis) {
            return `
                <div class="insight-card">
                    <h4>Document Analysis</h4>
                    <button class="copy-section-btn" onclick="navigator.clipboard.writeText(this.nextElementSibling.innerText)">Copy</button>
                    <div>${formatMarkdown(docAnalysis || 'No document analysis available')}</div>
                </div>

                ${filesWithContent.filter(f => f.hasContent).map(file => `
                    <div class="document-card">
                        <h4>${file.name}</h4>
                        <div class="document-meta">
                            Owner: ${file.owner} ‚Ä¢ Modified: ${new Date(file.modifiedTime).toLocaleDateString()}
                        </div>
                        <p>${file.content.substring(0, 500)}...</p>
                        <a href="${file.url}" target="_blank" class="source-citation">View Full Document</a>
                    </div>
                `).join('')}
            `;
        }

        function renderWebResearchTab(webIntelAnalysis, companyResearch) {
            return `
                <div class="insight-card">
                    <h4>Web Intelligence Synthesis</h4>
                    <button class="copy-section-btn" onclick="navigator.clipboard.writeText(this.nextElementSibling.innerText)">Copy</button>
                    <div>${formatMarkdown(webIntelAnalysis || 'No web intelligence available')}</div>
                </div>

                ${companyResearch.map(cr => `
                    <div class="insight-card">
                        <h4>Company: ${cr.company}</h4>
                        ${cr.results && cr.results.length > 0 ? cr.results.map(r => `
                            <div style="margin-bottom: 12px;">
                                <strong>${r.title || 'Research Result'}</strong><br>
                                <p>${(r.excerpts?.join(' ') || 'No content available').substring(0, 400)}...</p>
                                <a href="${r.url || '#'}" class="source-citation" target="_blank">Read More</a>
                            </div>
                        `).join('') : '<p>No results found</p>'}
                    </div>
                `).join('')}
            `;
        }

        function renderStrategyTab(strategyAnalysis) {
            return `
                <div class="insight-card">
                    <h4>Strategic Recommendations</h4>
                    <button class="copy-section-btn" onclick="navigator.clipboard.writeText(this.nextElementSibling.innerText)">Copy</button>
                    <div>${formatMarkdown(strategyAnalysis || 'No strategic analysis available')}</div>
                </div>
            `;
        }

        function buildPrepPrompt(meeting, attendees, emails, attachments, files, pastEvents) {
            const start = meeting.start.dateTime || meeting.start.date;
            const end = meeting.end.dateTime || meeting.end.date;

            let prompt = `I need you to prepare me for an upcoming meeting. Here is all the context:\n\n`;

            // User information
            prompt += `## MY INFORMATION\n`;
            prompt += `Name: ${userProfile?.name || 'Unknown'}\n`;
            prompt += `Email: ${userEmail}\n\n`;

            // Meeting details
            prompt += `## MEETING DETAILS\n`;
            prompt += `Title: ${meeting.summary || 'Untitled Meeting'}\n`;
            prompt += `Date & Time: ${new Date(start).toLocaleString()} - ${new Date(end).toLocaleTimeString()}\n`;
            if (meeting.location) prompt += `Location: ${meeting.location}\n`;
            if (meeting.description) prompt += `Description: ${meeting.description}\n`;
            prompt += `\n`;

            // Attendees
            prompt += `## ATTENDEES (${attendees.length} people)\n`;
            attendees.forEach(att => {
                prompt += `- ${att.displayName || att.email} (${att.email})`;
                if (att.organizer) prompt += ` [ORGANIZER]`;
                if (att.responseStatus) prompt += ` - Status: ${att.responseStatus}`;
                prompt += `\n`;
            });
            prompt += `\n`;

            // Past interactions via email - include MORE context
            if (emails.length > 0) {
                prompt += `## RECENT EMAIL HISTORY (${emails.length} emails)\n\n`;
                emails.slice(0, 15).forEach((email, idx) => {
                    prompt += `### Email ${idx + 1}: ${email.subject}\n`;
                    prompt += `**From:** ${email.from}\n`;
                    prompt += `**Date:** ${email.date}\n`;
                    prompt += `**Preview:** ${email.snippet}\n\n`;
                    if (email.body && email.body.length > 0) {
                        // Include FULL email body, not just snippet - critical for context
                        prompt += `**FULL EMAIL CONTENT:**\n${email.body}\n`;
                    }
                    prompt += `\n--- END EMAIL ${idx + 1} ---\n\n`;
                });
            }

            // Past meetings
            if (pastEvents.length > 0) {
                prompt += `## PAST MEETINGS WITH ATTENDEES (${pastEvents.length} meetings)\n`;
                pastEvents.slice(0, 5).forEach(event => {
                    prompt += `- ${event.summary} on ${new Date(event.start).toLocaleDateString()}`;
                    if (event.description) prompt += ` - ${event.description.substring(0, 100)}`;
                    prompt += `\n`;
                });
                prompt += `\n`;
            }

            // Shared files with content
            if (files.length > 0) {
                prompt += `## RELEVANT SHARED FILES (${files.length} files)\n\n`;
                files.forEach(file => {
                    prompt += `### File: ${file.name}\n`;
                    prompt += `Type: ${getFileType(file.mimeType, file.name)}\n`;
                    prompt += `Owner: ${file.owner}\n`;
                    prompt += `Modified: ${new Date(file.modifiedTime).toLocaleDateString()}\n`;

                    if (file.hasContent && file.content) {
                        prompt += `\n**FULL CONTENT:**\n`;
                        prompt += `${file.content}\n`;
                        prompt += `--- END OF ${file.name} ---\n\n`;
                    } else {
                        prompt += `(Content not available for this file type)\n\n`;
                    }
                });
            }

            // Attachments from emails
            if (attachments.length > 0) {
                prompt += `## EMAIL ATTACHMENTS (${attachments.length} attachments)\n`;
                attachments.slice(0, 10).forEach(att => {
                    prompt += `- ${att.filename} from ${att.from} on ${att.date}\n`;
                });
                prompt += `\n`;
            }

            prompt += `## YOUR TASK\n\n`;
            prompt += `You have been provided with EXTENSIVE context including full document contents, email threads, and relationship history. `;
            prompt += `This is NOT a surface-level brief - you must deeply analyze ALL the information provided.\n\n`;

            prompt += `Create a comprehensive, executive-level meeting preparation brief that includes:\n\n`;

            prompt += `1. **Executive Summary** (2-3 sentences)\n`;
            prompt += `   - What is this meeting really about at its core?\n`;
            prompt += `   - What are the stakes?\n\n`;

            prompt += `2. **Meeting Context & Objectives**\n`;
            prompt += `   - Analyze the meeting agenda and documents in detail\n`;
            prompt += `   - What are the explicit and implicit goals?\n`;
            prompt += `   - What decisions need to be made?\n\n`;

            prompt += `3. **Key Participants Analysis**\n`;
            prompt += `   - For each important attendee: their role, interests, and likely positions\n`;
            prompt += `   - What does our email history reveal about their priorities?\n`;
            prompt += `   - Who are the decision makers and influencers?\n\n`;

            prompt += `4. **Document Deep Dive**\n`;
            prompt += `   - Synthesize the KEY insights from all shared documents\n`;
            prompt += `   - What are the main themes, concerns, or proposals?\n`;
            prompt += `   - What specific details or data points are most relevant?\n`;
            prompt += `   - What questions or gaps exist in the materials?\n\n`;

            prompt += `5. **Relationship & History Analysis**\n`;
            prompt += `   - What patterns emerge from past emails and meetings?\n`;
            prompt += `   - What's the trajectory of this relationship?\n`;
            prompt += `   - Any concerns or wins from recent interactions?\n\n`;

            prompt += `6. **Strategic Preparation Points**\n`;
            prompt += `   - Specific talking points I should prepare\n`;
            prompt += `   - Questions I should be ready to answer\n`;
            prompt += `   - Data or information I should have at hand\n`;
            prompt += `   - Potential objections and how to address them\n\n`;

            prompt += `7. **Likely Discussion Topics & Your Position**\n`;
            prompt += `   - Based on documents and context, what will be discussed?\n`;
            prompt += `   - What should my stance be on each topic?\n`;
            prompt += `   - Where might there be disagreement?\n\n`;

            prompt += `8. **Recommendations & Action Items**\n`;
            prompt += `   - What should I do before the meeting?\n`;
            prompt += `   - What outcomes should I push for?\n`;
            prompt += `   - What follow-ups will likely be needed?\n\n`;

            prompt += `Be thorough, insightful, and strategic. Reference specific details from the documents and emails. `;
            prompt += `This brief should make me the most prepared person in the meeting. Format using clear markdown sections.`;

            return prompt;
        }

        function formatMarkdown(text) {
            // Simple markdown formatting
            return text
                .replace(/### (.*)/g, '<h3>$1</h3>')
                .replace(/## (.*)/g, '<h2>$1</h2>')
                .replace(/# (.*)/g, '<h2>$1</h2>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/^- (.*)/gm, '<li>$1</li>')
                .replace(/^\d+\. (.*)/gm, '<li>$1</li>')
                .replace(/\n\n/g, '</p><p>')
                .replace(/^(?!<[h|l|p])/gm, '<p>')
                .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
                .replace(/<\/li>\n<li>/g, '</li><li>');
        }

        function closePrepModal() {
            document.getElementById('prepModal').classList.remove('visible');
        }

        // Make functions available globally
        window.toggleMeetingInfo = toggleMeetingInfo;
        window.toggleContext = toggleContext;
        window.toggleEmailBody = toggleEmailBody;
        window.loadContextData = loadContextData;
        window.showMeetingDetail = showMeetingDetail;
        window.showCalendarView = showCalendarView;
        window.switchTab = switchTab;
        window.toggleAllEmailFilters = toggleAllEmailFilters;
        window.toggleAllAttachmentFilters = toggleAllAttachmentFilters;
        window.toggleAllFilesFilters = toggleAllFilesFilters;
        window.filterEmails = filterEmails;
        window.filterAttachments = filterAttachments;
        window.filterFiles = filterFiles;
        window.prepareForMeeting = prepareForMeeting;
        window.closePrepModal = closePrepModal;
        window.switchBriefTab = switchBriefTab;

        // ===== REAL-TIME MEETING ASSISTANT =====

        let meetingAssistantWs = null;
        let mediaRecorder = null;
        let audioContext = null;
        let scriptProcessor = null;
        let mediaStream = null;
        let meetingBrief = null;
        let currentMeetingId = null;

        // Speaker mapping state
        let detectedSpeakers = new Set();
        let speakerMappings = new Map();
        let pendingMappingModal = false;
        let recentSuggestions = new Set(); // Client-side deduplication

        async function enterMeeting() {
            try {
                // Check browser compatibility
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert('Your browser does not support audio recording. Please use Chrome, Firefox, or Safari.');
                    return;
                }

                if (!window.MediaRecorder) {
                    alert('Your browser does not support MediaRecorder API. Please update your browser.');
                    return;
                }

                if (!window.WebSocket) {
                    alert('Your browser does not support WebSocket. Please update your browser.');
                    return;
                }

                // Show the assistant UI
                document.getElementById('meetingAssistantContainer').style.display = 'block';
                document.getElementById('enterMeetingButton').disabled = true;
                document.getElementById('enterMeetingButton').textContent = 'üé§ Active...';

                // Get microphone access
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 16000
                    }
                });

                // Connect to WebSocket
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const host = window.location.host;
                meetingAssistantWs = new WebSocket(`${protocol}//${host}`);

                meetingAssistantWs.onopen = () => {
                    console.log('‚úì Connected to meeting assistant');

                    // Send initialization with meeting context
                    meetingAssistantWs.send(JSON.stringify({
                        type: 'init',
                        meetingId: currentMeetingId,
                        context: meetingBrief || {},
                        userEmail: userEmail || ''
                    }));
                };

                meetingAssistantWs.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    if (data.type === 'ready') {
                        console.log('‚úì Meeting assistant ready');
                        startAudioCapture(stream);
                    }
                    else if (data.type === 'deepgram_ready') {
                        console.log('‚úì Deepgram connection ready');
                        // Show visual feedback
                        const suggestionsContainer = document.getElementById('suggestionsContainer');
                        suggestionsContainer.innerHTML = '<div class="suggestion-placeholder">üé§ Listening... Start speaking.</div>';
                    }
                    else if (data.type === 'transcript') {
                        // Track detected speakers
                        if (data.speakerId !== null && data.speakerId !== undefined) {
                            if (!detectedSpeakers.has(data.speakerId) && !speakerMappings.has(data.speakerId)) {
                                detectedSpeakers.add(data.speakerId);
                                // Show mapping modal after 2-3 speakers detected
                                if (detectedSpeakers.size >= 2 && !pendingMappingModal) {
                                    pendingMappingModal = true;
                                    showSpeakerMappingModal();
                                }
                            }
                        }
                        addTranscriptItem(data);
                    }
                    else if (data.type === 'speaker_mapped') {
                        console.log(`‚úì Speaker ${data.speakerId} mapped to ${data.name}`);
                    }
                    else if (data.type === 'suggestions') {
                        addSuggestions(data.suggestions);
                    }
                    else if (data.type === 'error') {
                        console.error('Assistant error:', data.message);
                        // Show error in UI
                        const suggestionsContainer = document.getElementById('suggestionsContainer');
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'suggestion-item error';
                        errorDiv.innerHTML = `
                            <div class="suggestion-type">Error</div>
                            <div class="suggestion-message">${data.message}</div>
                        `;
                        suggestionsContainer.insertBefore(errorDiv, suggestionsContainer.firstChild);
                    }
                };

                meetingAssistantWs.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    alert('Connection error. Please try again.');
                };

                meetingAssistantWs.onclose = () => {
                    console.log('Meeting assistant disconnected');
                    stopAudioCapture();
                };

            } catch (error) {
                console.error('Failed to start meeting assistant:', error);
                alert('Failed to access microphone. Please check permissions.');
                document.getElementById('enterMeetingButton').disabled = false;
                document.getElementById('enterMeetingButton').textContent = 'üé§ Entering Meeting';
            }
        }

        function startAudioCapture(stream) {
            try {
                mediaStream = stream;

                // Create AudioContext with 16kHz sample rate (Deepgram requirement)
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000
                });

                console.log(`‚úì AudioContext created (${audioContext.sampleRate}Hz)`);

                // Create source from microphone stream
                const source = audioContext.createMediaStreamSource(stream);

                // Create ScriptProcessor for raw PCM extraction
                // Buffer size 4096 gives good balance of latency vs processing overhead
                scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);

                scriptProcessor.onaudioprocess = (e) => {
                    if (meetingAssistantWs && meetingAssistantWs.readyState === WebSocket.OPEN) {
                        const inputData = e.inputBuffer.getChannelData(0); // Float32Array [-1, 1]

                        // Convert Float32 to Int16 PCM (linear16 format for Deepgram)
                        const pcmData = new Int16Array(inputData.length);
                        for (let i = 0; i < inputData.length; i++) {
                            // Clamp to [-1, 1] and convert to 16-bit signed integer
                            const s = Math.max(-1, Math.min(1, inputData[i]));
                            pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                        }

                        // Convert Int16Array to base64
                        const uint8Array = new Uint8Array(pcmData.buffer);
                        const base64Audio = btoa(String.fromCharCode(...uint8Array));

                        // Send raw PCM audio to backend
                        meetingAssistantWs.send(JSON.stringify({
                            type: 'audio',
                            audio: base64Audio
                        }));
                    }
                };

                // Connect audio pipeline: microphone -> processor -> destination
                source.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);

                console.log('‚úì Audio capture started (raw PCM, 16kHz, Int16)');

            } catch (error) {
                console.error('Failed to start audio capture:', error);
                alert(`Failed to start audio: ${error.message}`);
            }
        }

        function stopAudioCapture() {
            // Disconnect and clean up ScriptProcessor
            if (scriptProcessor) {
                scriptProcessor.disconnect();
                scriptProcessor = null;
            }

            // Close AudioContext
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            // Stop all media stream tracks
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }

            console.log('‚úì Audio capture stopped');
        }

        function addTranscriptItem(data) {
            const container = document.getElementById('transcriptContainer');
            const placeholder = container.querySelector('.suggestion-placeholder');
            if (placeholder) placeholder.remove();

            const item = document.createElement('div');
            item.className = `transcript-item ${data.isUser ? 'user' : ''}`;
            item.innerHTML = `
                <div class="transcript-speaker">${data.speaker}${data.isUser ? ' (You)' : ''}</div>
                <div class="transcript-text">${data.text}</div>
                <div class="transcript-timestamp">${new Date(data.timestamp).toLocaleTimeString()}</div>
            `;

            container.appendChild(item);
            container.scrollTop = container.scrollHeight;
        }

        function addSuggestions(suggestions) {
            const container = document.getElementById('suggestionsContainer');
            const placeholder = container.querySelector('.suggestion-placeholder');
            if (placeholder) placeholder.remove();

            suggestions.forEach(sugg => {
                // Client-side deduplication
                const normalized = sugg.message.toLowerCase().replace(/[^\w\s]/g, '').trim().substring(0, 80);
                if (recentSuggestions.has(normalized)) {
                    console.log('Skipping duplicate suggestion:', sugg.message.substring(0, 40) + '...');
                    return; // Skip duplicate
                }
                recentSuggestions.add(normalized);

                // Auto-cleanup after 60 seconds
                setTimeout(() => recentSuggestions.delete(normalized), 60000);

                const item = document.createElement('div');
                item.className = `suggestion-item ${sugg.severity}`;
                item.innerHTML = `
                    <div class="suggestion-type">${sugg.type}</div>
                    <div class="suggestion-message">${sugg.message}</div>
                `;

                container.insertBefore(item, container.firstChild);

                // Keep only last 15 suggestions (reduced from 20 to prevent clutter)
                const items = container.querySelectorAll('.suggestion-item');
                if (items.length > 15) {
                    items[items.length - 1].remove();
                }
            });
        }

        function stopMeetingAssistant() {
            if (meetingAssistantWs) {
                meetingAssistantWs.send(JSON.stringify({ type: 'stop' }));
                meetingAssistantWs.close();
                meetingAssistantWs = null;
            }

            stopAudioCapture();

            document.getElementById('meetingAssistantContainer').style.display = 'none';
            document.getElementById('enterMeetingButton').disabled = false;
            document.getElementById('enterMeetingButton').textContent = 'üé§ Entering Meeting';

            // Clear content
            document.getElementById('transcriptContainer').innerHTML = '<div class="suggestion-placeholder">Session ended</div>';
            document.getElementById('suggestionsContainer').innerHTML = '<div class="suggestion-placeholder">Session ended</div>';
        }

        // Show speaker mapping modal
        function showSpeakerMappingModal() {
            const modal = document.getElementById('speakerMappingModal');
            const listContainer = document.getElementById('speakerMappingList');

            // Build dropdown options from meeting attendees
            const attendees = meetingBrief?.attendees || [];
            const options = [
                '<option value="You">You</option>',
                ...attendees.map(att => `<option value="${att.name}">${att.name} (${att.email})</option>`)
            ];

            // Create a mapping UI for each detected speaker
            listContainer.innerHTML = Array.from(detectedSpeakers).map(speakerId => `
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 6px; font-weight: 500;">Speaker ${speakerId}:</label>
                    <select id="speaker-${speakerId}-mapping" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;">
                        ${options.join('')}
                    </select>
                </div>
            `).join('');

            modal.style.display = 'flex';
        }

        // Confirm speaker mapping and send to server
        function confirmSpeakerMapping() {
            detectedSpeakers.forEach(speakerId => {
                const select = document.getElementById(`speaker-${speakerId}-mapping`);
                const name = select.value;
                speakerMappings.set(speakerId, name);

                // Send mapping to server
                if (meetingAssistantWs && meetingAssistantWs.readyState === WebSocket.OPEN) {
                    meetingAssistantWs.send(JSON.stringify({
                        type: 'map_speaker',
                        speakerId,
                        name
                    }));
                }
            });

            // Close modal
            document.getElementById('speakerMappingModal').style.display = 'none';

            // Update all existing transcript items with new labels
            updateTranscriptLabels();
        }

        // Update transcript labels after mapping
        function updateTranscriptLabels() {
            const items = document.querySelectorAll('.transcript-item');
            items.forEach(item => {
                const speakerDiv = item.querySelector('.transcript-speaker');
                if (speakerDiv) {
                    const speakerText = speakerDiv.textContent;
                    // Extract speaker ID from "Speaker X" format
                    const match = speakerText.match(/Speaker (\d+)/);
                    if (match) {
                        const speakerId = parseInt(match[1]);
                        const mappedName = speakerMappings.get(speakerId);
                        if (mappedName) {
                            const isYou = mappedName === 'You';
                            speakerDiv.textContent = mappedName + (isYou ? '' : '');
                            if (isYou) {
                                item.classList.add('user');
                            }
                        }
                    }
                }
            });
        }

        // Clear all suggestions
        function clearSuggestions() {
            document.getElementById('suggestionsContainer').innerHTML = '<div class="suggestion-placeholder">Suggestions cleared. Listening...</div>';
            recentSuggestions.clear();
        }

        window.enterMeeting = enterMeeting;
        window.stopMeetingAssistant = stopMeetingAssistant;
        window.confirmSpeakerMapping = confirmSpeakerMapping;
        window.clearSuggestions = clearSuggestions;

        // ===== INTERACTIVE PREP FUNCTIONS =====

        let interactivePrepWs = null;
        let interactiveBrief = null;
        let chatMessagesArray = []; // Renamed to avoid conflict with DOM element id
        let isVoiceActive = false;
        let isSpeaking = false;
        let chatAudioContext = null;
        let chatScriptProcessor = null;
        let chatMediaStream = null;
        let conversationHistory = [];
        let voiceConversationMode = false; // True = continuous conversation, False = single utterance
        let currentAIUtterance = null; // For TTS interruption

        async function startInteractivePrep() {
            const button = document.getElementById('interactivePrepButton');
            button.disabled = true;
            button.textContent = '‚è≥ Preparing...';

            try {
                const meeting = currentMeeting;
                if (!meeting) {
                    throw new Error('No meeting selected');
                }

                const attendees = meeting.attendees || [];
                const attendeeEmails = attendees.map(att => att.email).filter(Boolean);

                // Fetch local context (use cached if available)
                let emails = currentEmails;
                let files = currentFiles;

                if (emails.length === 0) {
                    emails = await fetchPastEmails(attendeeEmails);
                }
                if (files.length === 0) {
                    files = await fetchDriveFiles(attendeeEmails);
                }

                // Fetch file contents
                const filesWithContent = await fetchDriveFileContents(files.slice(0, 5));

                const response = await fetch('/api/prep-meeting', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        meeting,
                        attendees,
                        emails: emails.slice(0, 15).map(e => ({
                            subject: e.subject,
                            snippet: e.snippet,
                            from: e.from,
                            body: e.body || e.snippet,
                            date: e.date
                        })),
                        files: filesWithContent.map(f => ({
                            name: f.name,
                            mimeType: f.mimeType,
                            modifiedTime: f.modifiedTime,
                            id: f.id,
                            content: f.content || ''
                        }))
                    })
                });

                if (!response.ok) throw new Error('Failed to generate meeting prep');

                interactiveBrief = await response.json();

                // Add meeting info to brief for context
                interactiveBrief.meeting = meeting;

                // Format meeting time
                const startTime = new Date(meeting.start.dateTime || meeting.start.date);
                const endTime = new Date(meeting.end.dateTime || meeting.end.date);
                const timeStr = `${startTime.toLocaleDateString()} ${startTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} - ${endTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;

                // Populate the brief sidebar
                populateBriefSidebar(interactiveBrief);

                // Open chat interface
                document.getElementById('interactiveMeetingTitle').textContent = meeting.summary;
                document.getElementById('interactiveMeetingTime').textContent = timeStr;
                document.getElementById('interactivePrepOverlay').style.display = 'flex';

                // Initialize WebSocket connection for interactive prep
                initializeInteractiveWebSocket();

                // Add initial AI greeting
                addChatMessage('assistant', `Hi! I've prepared all the context for your meeting "${meeting.summary}". Ask me anything about the attendees, agenda, related documents, or any other preparation you need.`);

            } catch (error) {
                console.error('Error starting interactive prep:', error);
                alert('Failed to start interactive prep: ' + error.message);
            } finally {
                button.disabled = false;
                button.textContent = 'üí¨ Interactive Prep';
            }
        }

        function populateBriefSidebar(brief) {
            const container = document.getElementById('interactiveBriefContent');

            let html = '';

            // Summary
            if (brief.summary) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 8px 0; color: #1f2937; font-size: 14px;">üìù Summary</h4>
                        <p style="margin: 0; color: #4b5563; line-height: 1.6;">${brief.summary}</p>
                    </div>
                `;
            }

            // Attendees
            if (brief.attendees && brief.attendees.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 12px 0; color: #1f2937; font-size: 14px;">üë• Attendees (${brief.attendees.length})</h4>
                `;
                brief.attendees.forEach(att => {
                    html += `
                        <div style="margin-bottom: 12px; padding: 10px; background: white; border-radius: 6px; border-left: 3px solid #667eea;">
                            <div style="font-weight: 600; color: #1f2937; margin-bottom: 4px;">${att.name}</div>
                            <div style="font-size: 12px; color: #6b7280; margin-bottom: 6px;">${att.title || att.email}</div>
                            ${att.keyFacts && att.keyFacts.length > 0 ? `
                                <ul style="margin: 6px 0 0 0; padding-left: 18px; font-size: 12px; color: #4b5563;">
                                    ${att.keyFacts.map(fact => `<li style="margin-bottom: 4px;">${fact}</li>`).join('')}
                                </ul>
                            ` : ''}
                        </div>
                    `;
                });
                html += `</div>`;
            }

            // Action Items
            if (brief.actionItems && brief.actionItems.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 12px 0; color: #1f2937; font-size: 14px;">‚úÖ Action Items</h4>
                        <ul style="margin: 0; padding-left: 18px; color: #4b5563; line-height: 1.6;">
                            ${brief.actionItems.map(item => `<li style="margin-bottom: 8px;">${item}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            // Recommendations
            if (brief.recommendations && brief.recommendations.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 12px 0; color: #1f2937; font-size: 14px;">üí° Recommendations</h4>
                        <ul style="margin: 0; padding-left: 18px; color: #4b5563; line-height: 1.6;">
                            ${brief.recommendations.map(rec => `<li style="margin-bottom: 8px;">${rec}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            // Email Analysis
            if (brief.emailAnalysis && brief.emailAnalysis.length > 20) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 8px 0; color: #1f2937; font-size: 14px;">üìß Email Context</h4>
                        <p style="margin: 0; color: #4b5563; line-height: 1.6; font-size: 12px;">${brief.emailAnalysis}</p>
                    </div>
                `;
            }

            // Document Analysis
            if (brief.documentAnalysis && brief.documentAnalysis.length > 20) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 8px 0; color: #1f2937; font-size: 14px;">üìÑ Document Insights</h4>
                        <p style="margin: 0; color: #4b5563; line-height: 1.6; font-size: 12px;">${brief.documentAnalysis}</p>
                    </div>
                `;
            }

            // Company Research
            if (brief.companyResearch && brief.companyResearch.length > 20) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 8px 0; color: #1f2937; font-size: 14px;">üè¢ Company Context</h4>
                        <p style="margin: 0; color: #4b5563; line-height: 1.6; font-size: 12px;">${brief.companyResearch}</p>
                    </div>
                `;
            }

            container.innerHTML = html || '<div style="text-align: center; color: #999; padding: 40px 20px;">No brief data available</div>';
        }

        function initializeInteractiveWebSocket() {
            // Use same WebSocket server for interactive prep
            interactivePrepWs = new WebSocket('ws://localhost:8080');

            interactivePrepWs.onopen = () => {
                console.log('‚úÖ Interactive prep WebSocket connected');

                // Send initial context
                interactivePrepWs.send(JSON.stringify({
                    type: 'interactive_prep_init',
                    meetingBrief: interactiveBrief
                }));

                updateChatStatus('Connected', '#10b981');
            };

            interactivePrepWs.onmessage = (event) => {
                const data = JSON.parse(event.data);

                if (data.type === 'interactive_response') {
                    // AI response received
                    addChatMessage('assistant', data.message, data.toolCall);

                    // Speak response if voice output enabled
                    const voiceEnabled = document.getElementById('voiceOutputToggle').checked;
                    if (voiceEnabled && data.message) {
                        speakText(data.message);
                    }
                }
                else if (data.type === 'interactive_error') {
                    addChatMessage('system', `Error: ${data.message}`);
                }
                // Voice Conversation events
                else if (data.type === 'voice_ready') {
                    console.log('‚úÖ Voice conversation ready');
                    updateChatStatus('Voice conversation ready', '#10b981');
                }
                else if (data.type === 'voice_transcript') {
                    // Live transcript from user
                    console.log('üìù Transcript:', data.text);
                    // Could show interim results in UI
                }
                else if (data.type === 'ai_response') {
                    // AI response in voice conversation mode
                    addChatMessage('assistant', data.text);
                    // Speak the response
                    speakText(data.text);
                }
                else if (data.type === 'stop_tts') {
                    // User interrupted - stop speaking
                    if (currentAIUtterance) {
                        window.speechSynthesis.cancel();
                        currentAIUtterance = null;
                    }
                }
                else if (data.type === 'state_change') {
                    // Update UI based on conversation state
                    const stateLabels = {
                        'listening': 'Listening...',
                        'processing': 'Thinking...',
                        'speaking': 'Speaking...',
                        'interrupted': 'Interrupted'
                    };
                    updateChatStatus(stateLabels[data.state] || 'Connected', '#10b981');
                }
                else if (data.type === 'function_call') {
                    // Web search indicator
                    console.log('üîç Function call:', data.function, data.query);
                    updateChatStatus(`Searching: ${data.query}`, '#3b82f6');
                }
            };

            interactivePrepWs.onerror = (error) => {
                console.error('Interactive prep WebSocket error:', error);
                updateChatStatus('Connection error', '#ef4444');
            };

            interactivePrepWs.onclose = () => {
                console.log('Interactive prep WebSocket closed');
                updateChatStatus('Disconnected', '#6b7280');
            };
        }

        function closeInteractivePrep() {
            // Stop any ongoing speech
            stopTTS();

            // Stop voice input if active
            if (isVoiceActive) {
                if (voiceConversationMode) {
                    stopVoiceConversation();
                } else {
                    stopChatVoiceInput();
                }
            }

            // Close WebSocket
            if (interactivePrepWs && interactivePrepWs.readyState === WebSocket.OPEN) {
                interactivePrepWs.close();
            }

            // Clear state
            interactivePrepWs = null;
            interactiveBrief = null;
            chatMessagesArray = [];
            conversationHistory = [];
            voiceConversationMode = false;

            // Clear chat UI
            document.getElementById('chatHistory').innerHTML = `
                <div class="chat-placeholder" style="text-align: center; color: #999; padding: 40px 20px;">
                    <div style="font-size: 24px; margin-bottom: 12px;">üí¨</div>
                    <div>Ask me anything about this meeting...</div>
                    <div style="font-size: 13px; margin-top: 8px;">Try: "Tell me about the attendees" or "What documents are attached?"</div>
                </div>
            `;
            document.getElementById('chatInput').value = '';

            // Close overlay
            document.getElementById('interactivePrepOverlay').style.display = 'none';
        }

        function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();

            if (!message) return;
            if (!interactivePrepWs || interactivePrepWs.readyState !== WebSocket.OPEN) {
                alert('Not connected to server');
                return;
            }

            // Add user message to UI
            addChatMessage('user', message);

            // Add to conversation history
            conversationHistory.push({ role: 'user', content: message });

            // Clear input
            input.value = '';

            // Show loading indicator
            showChatLoading();

            // Send to backend
            interactivePrepWs.send(JSON.stringify({
                type: 'interactive_message',
                message: message,
                conversationHistory: conversationHistory
            }));
        }

        async function toggleVoiceInput() {
            if (!isVoiceActive) {
                // Check if we should use conversation mode or single utterance mode
                // Use conversation mode by default for better UX
                voiceConversationMode = true;

                if (voiceConversationMode) {
                    await startVoiceConversation();
                } else {
                    await startChatVoiceInput();
                }
            } else {
                if (voiceConversationMode) {
                    stopVoiceConversation();
                } else {
                    stopChatVoiceInput();
                }
            }
        }

        async function startChatVoiceInput() {
            try {
                const button = document.getElementById('voiceInputBtn');
                button.style.background = '#ef4444';
                button.textContent = '‚è∫Ô∏è';
                updateChatStatus('Listening...', '#ef4444');

                // Request microphone access
                chatMediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });

                // Set up audio context
                chatAudioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                const source = chatAudioContext.createMediaStreamSource(chatMediaStream);
                chatScriptProcessor = chatAudioContext.createScriptProcessor(4096, 1, 1);

                chatScriptProcessor.onaudioprocess = (e) => {
                    if (!isVoiceActive) return;

                    const float32Audio = e.inputBuffer.getChannelData(0);
                    const int16Audio = new Int16Array(float32Audio.length);

                    for (let i = 0; i < float32Audio.length; i++) {
                        const s = Math.max(-1, Math.min(1, float32Audio[i]));
                        int16Audio[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }

                    if (interactivePrepWs && interactivePrepWs.readyState === WebSocket.OPEN) {
                        interactivePrepWs.send(JSON.stringify({
                            type: 'interactive_voice_data',
                            audio: Array.from(int16Audio)
                        }));
                    }
                };

                source.connect(chatScriptProcessor);
                chatScriptProcessor.connect(chatAudioContext.destination);

                isVoiceActive = true;

                // Send voice start signal
                if (interactivePrepWs && interactivePrepWs.readyState === WebSocket.OPEN) {
                    interactivePrepWs.send(JSON.stringify({
                        type: 'interactive_voice_start'
                    }));
                }

            } catch (error) {
                console.error('Error starting voice input:', error);
                alert('Failed to access microphone: ' + error.message);
                stopChatVoiceInput();
            }
        }

        function stopChatVoiceInput() {
            const button = document.getElementById('voiceInputBtn');
            button.style.background = '#667eea';
            button.textContent = 'üé§';
            updateChatStatus('Connected', '#10b981');

            isVoiceActive = false;

            if (chatScriptProcessor) {
                chatScriptProcessor.disconnect();
                chatScriptProcessor = null;
            }

            if (chatAudioContext) {
                chatAudioContext.close();
                chatAudioContext = null;
            }

            if (chatMediaStream) {
                chatMediaStream.getTracks().forEach(track => track.stop());
                chatMediaStream = null;
            }

            // Send voice stop signal
            if (interactivePrepWs && interactivePrepWs.readyState === WebSocket.OPEN) {
                interactivePrepWs.send(JSON.stringify({
                    type: 'interactive_voice_stop'
                }));
            }
        }

        // ===== VOICE CONVERSATION MODE (Continuous back-and-forth) =====

        async function startVoiceConversation() {
            try {
                const button = document.getElementById('voiceInputBtn');
                button.style.background = '#ef4444';
                button.textContent = 'üî¥ Stop';
                updateChatStatus('Starting voice conversation...', '#ef4444');

                // Request microphone access
                chatMediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // Set up audio context for streaming
                chatAudioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                const source = chatAudioContext.createMediaStreamSource(chatMediaStream);
                chatScriptProcessor = chatAudioContext.createScriptProcessor(4096, 1, 1);

                chatScriptProcessor.onaudioprocess = (e) => {
                    if (!isVoiceActive) return;

                    const float32Audio = e.inputBuffer.getChannelData(0);
                    const int16Audio = new Int16Array(float32Audio.length);

                    // Convert float32 to int16
                    for (let i = 0; i < float32Audio.length; i++) {
                        const s = Math.max(-1, Math.min(1, float32Audio[i]));
                        int16Audio[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }

                    // Stream audio to backend
                    if (interactivePrepWs && interactivePrepWs.readyState === WebSocket.OPEN) {
                        // Convert to base64 for transmission
                        const audioArray = Array.from(int16Audio);
                        const base64Audio = btoa(String.fromCharCode.apply(null, new Uint8Array(int16Audio.buffer)));

                        interactivePrepWs.send(JSON.stringify({
                            type: 'voice_conversation_audio',
                            audio: base64Audio
                        }));
                    }
                };

                source.connect(chatScriptProcessor);
                chatScriptProcessor.connect(chatAudioContext.destination);

                isVoiceActive = true;

                // Initialize voice conversation on backend
                if (interactivePrepWs && interactivePrepWs.readyState === WebSocket.OPEN) {
                    interactivePrepWs.send(JSON.stringify({
                        type: 'voice_conversation_start'
                    }));
                }

                console.log('‚úÖ Voice conversation started');

            } catch (error) {
                console.error('Error starting voice conversation:', error);
                alert('Failed to start voice conversation: ' + error.message);
                stopVoiceConversation();
            }
        }

        function stopVoiceConversation() {
            const button = document.getElementById('voiceInputBtn');
            button.style.background = '#667eea';
            button.textContent = 'üé§';
            updateChatStatus('Connected', '#10b981');

            isVoiceActive = false;

            // Stop audio processing
            if (chatScriptProcessor) {
                chatScriptProcessor.disconnect();
                chatScriptProcessor = null;
            }

            if (chatAudioContext) {
                chatAudioContext.close();
                chatAudioContext = null;
            }

            if (chatMediaStream) {
                chatMediaStream.getTracks().forEach(track => track.stop());
                chatMediaStream = null;
            }

            // Stop any ongoing speech
            if (currentAIUtterance) {
                window.speechSynthesis.cancel();
                currentAIUtterance = null;
            }

            // Notify backend to stop voice conversation
            if (interactivePrepWs && interactivePrepWs.readyState === WebSocket.OPEN) {
                interactivePrepWs.send(JSON.stringify({
                    type: 'voice_conversation_stop'
                }));
            }

            console.log('üõë Voice conversation stopped');
        }

        function addChatMessage(role, content, toolCall = null) {
            const chatHistory = document.getElementById('chatHistory');
            const placeholder = chatHistory.querySelector('.chat-placeholder');
            if (placeholder) placeholder.remove();

            // Remove loading indicator
            const loading = chatHistory.querySelector('.chat-loading-message');
            if (loading) loading.remove();

            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}`;

            if (role === 'system') {
                messageDiv.innerHTML = `
                    <div class="chat-bubble" style="background: #fef3c7; color: #92400e; border: 1px solid #fbbf24;">
                        ${content}
                    </div>
                `;
            } else {
                let bubbleContent = content;

                // Add tool call indicator if present
                if (toolCall) {
                    bubbleContent = `
                        <div class="chat-tool-call" style="background: #f0f9ff; border-left: 3px solid #3b82f6; padding: 8px; margin-bottom: 8px; border-radius: 6px; font-size: 13px;">
                            <strong>üîç Web Search:</strong> ${toolCall.query || 'Searching...'}
                        </div>
                        ${content}
                    `;
                }

                messageDiv.innerHTML = `
                    <div class="chat-bubble">${bubbleContent}</div>
                    <div class="chat-timestamp" style="font-size: 11px; color: #9ca3af; margin-top: 4px;">
                        ${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                    </div>
                `;
            }

            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;

            // Add to history if not system message
            if (role !== 'system') {
                chatMessagesArray.push({ role, content });
            }
        }

        function showChatLoading() {
            const chatHistory = document.getElementById('chatHistory');

            // Remove existing loading indicator
            const existing = chatHistory.querySelector('.chat-loading-message');
            if (existing) existing.remove();

            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'chat-message assistant chat-loading-message';
            loadingDiv.innerHTML = `
                <div class="chat-loading">
                    <div class="chat-loading-dot" style="animation-delay: 0s"></div>
                    <div class="chat-loading-dot" style="animation-delay: 0.2s"></div>
                    <div class="chat-loading-dot" style="animation-delay: 0.4s"></div>
                </div>
            `;
            chatHistory.appendChild(loadingDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        function updateChatStatus(text, color) {
            const status = document.getElementById('chatStatus');
            status.textContent = text;
            status.style.color = color;
        }

        // Audio queue for TTS playback
        let ttsAudioQueue = [];
        let currentTTSAudio = null;
        let isTTSPlaying = false;

        async function speakText(text) {
            // Stop any ongoing speech
            stopTTS();

            try {
                isSpeaking = true;
                updateChatStatus('Generating speech...', '#3b82f6');

                // Call our backend TTS endpoint (which proxies OpenAI)
                const response = await fetch('/api/tts', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ text })
                });

                if (!response.ok) {
                    throw new Error('TTS generation failed');
                }

                // Get audio blob
                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);

                // Play audio
                currentTTSAudio = new Audio(audioUrl);
                currentAIUtterance = currentTTSAudio;

                currentTTSAudio.onplay = () => {
                    isSpeaking = true;
                    isTTSPlaying = true;
                    updateChatStatus('Speaking...', '#10b981');
                };

                currentTTSAudio.onended = () => {
                    isSpeaking = false;
                    isTTSPlaying = false;
                    currentTTSAudio = null;
                    currentAIUtterance = null;
                    URL.revokeObjectURL(audioUrl);
                    updateChatStatus('Connected', '#10b981');
                };

                currentTTSAudio.onerror = (error) => {
                    console.error('Audio playback error:', error);
                    isSpeaking = false;
                    isTTSPlaying = false;
                    currentTTSAudio = null;
                    currentAIUtterance = null;
                    updateChatStatus('Connected', '#10b981');
                };

                await currentTTSAudio.play();

            } catch (error) {
                console.error('TTS error:', error);
                // Fallback to Web Speech API
                console.log('Falling back to Web Speech API');
                fallbackToWebSpeech(text);
            }
        }

        function fallbackToWebSpeech(text) {
            window.speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1.1;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            utterance.onstart = () => {
                isSpeaking = true;
                currentAIUtterance = utterance;
            };

            utterance.onend = () => {
                isSpeaking = false;
                currentAIUtterance = null;
            };

            utterance.onerror = (error) => {
                console.error('Speech synthesis error:', error);
                isSpeaking = false;
                currentAIUtterance = null;
            };

            window.speechSynthesis.speak(utterance);
        }

        function stopTTS() {
            // Stop HTML5 audio
            if (currentTTSAudio) {
                currentTTSAudio.pause();
                currentTTSAudio.currentTime = 0;
                currentTTSAudio = null;
            }

            // Stop Web Speech API fallback
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }

            currentAIUtterance = null;
            isSpeaking = false;
            isTTSPlaying = false;
        }

        // Export functions
        window.startInteractivePrep = startInteractivePrep;
        window.closeInteractivePrep = closeInteractivePrep;
        window.sendChatMessage = sendChatMessage;
        window.toggleVoiceInput = toggleVoiceInput;

    </script>
</body>
</html>
